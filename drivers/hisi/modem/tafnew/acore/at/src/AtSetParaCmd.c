/*
* Copyright (C) Huawei Technologies Co., Ltd. 2012-2015. All rights reserved.
* foss@huawei.com
*
* If distributed as part of the Linux kernel, the following license terms
* apply:
*
* * This program is free software; you can redistribute it and/or modify
* * it under the terms of the GNU General Public License version 2 and
* * only version 2 as published by the Free Software Foundation.
* *
* * This program is distributed in the hope that it will be useful,
* * but WITHOUT ANY WARRANTY; without even the implied warranty of
* * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* * GNU General Public License for more details.
* *
* * You should have received a copy of the GNU General Public License
* * along with this program; if not, write to the Free Software
* * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
*
* Otherwise, the following license terms apply:
*
* * Redistribution and use in source and binary forms, with or without
* * modification, are permitted provided that the following conditions
* * are met:
* * 1) Redistributions of source code must retain the above copyright
* *    notice, this list of conditions and the following disclaimer.
* * 2) Redistributions in binary form must reproduce the above copyright
* *    notice, this list of conditions and the following disclaimer in the
* *    documentation and/or other materials provided with the distribution.
* * 3) Neither the name of Huawei nor the names of its contributors may
* *    be used to endorse or promote products derived from this software
* *    without specific prior written permission.
*
* * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*
*/

/*****************************************************************************
   1 头文件包含
*****************************************************************************/
#include "mdrv.h"
#include "TafTypeDef.h"
#include "ATCmdProc.h"
#include "AtInputProc.h"
#include "AtCheckFunc.h"
#include "AtParseCmd.h"
#include "PppInterface.h"
#include "AtMsgPrint.h"
#include "Taf_MmiStrParse.h"
#include "siappstk.h"
#include "siapppih.h"
#include "siapppb.h"
#include "AtPhyInterface.h"
#include "AtDataProc.h"
#include "AtInputProc.h"
#include "TafDrvAgent.h"
#include "MnCommApi.h"
#include "AtCmdMsgProc.h"
#include "AtRabmInterface.h"
#include "AtSndMsg.h"
#include "AtDeviceCmd.h"
#include "AtRnicInterface.h"
#include "AtTafAgentInterface.h"
#include "TafAgentInterface.h"
#include "TafAppXsmsInterface.h"
#include "AtMtaInterface.h"
#include "TafStdlib.h"
#include "mnmsgcbencdec.h"

#if (FEATURE_LTE == FEATURE_ON)
#include "msp_nvim.h"
#include "at_common.h"
#include "gen_msg.h"
#include "at_lte_common.h"
#endif

#include "nv_stru_gucnas.h"
#include "nv_stru_sys.h"
#include "nv_stru_gas.h"
#include "nv_stru_pam.h"
#include "nv_stru_msp_interface.h"
#include "acore_nv_stru_msp.h"

#include "MnCallApi.h"
#include "AtCtx.h"
#include "AppVcApi.h"
#include "AtImsaInterface.h"
#include "AtInit.h"

#include "gunas_errno.h"

#if (VOS_OS_VER == VOS_LINUX)
#include <linux/kconfig.h>
#include <linux/pm_wakeup.h>
#ifdef CONFIG_HISI_BALONG_MODEM
#include <linux/mtd/hisi_nve_interface.h>
#if (FEATURE_AGPS_GPIO == FEATURE_ON)
#include <linux/version.h>
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0))
#include <huawei_platform/connectivity/huawei_gps.h>
#else
#include <linux/huawei/gps/huawei_gps.h>
#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)) */
#endif /* #if (FEATURE_ON == FEATURE_AGPS_GPIO) */
#endif /* #ifdef CONFIG_HISI_BALONG_MODEM */
#else
#include "Linuxstub.h"
#endif /* #if (VOS_OS_VER == VOS_LINUX) */

#include "CssAtInterface.h"
#include "AtCmdSimProc.h"
#include "TafAppMma.h"
#include "TafMtcApi.h"
#include "AtCmdMiscProc.h"
#include "TafCcmApi.h"
#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON)
#include "ads_dev_i.h"
#else
#include "AdsDeviceInterface.h"
#endif
#include "AtCmdCallProc.h"
#include "securec.h"

/*lint -esym(516,free,malloc)*/


/*****************************************************************************
    协议栈打印打点方式下的.C文件宏定义
*****************************************************************************/
#define    THIS_FILE_ID        PS_FILE_ID_AT_SETPARACMD_C


#define AT_CSND_PLAYLOAD_MAX_LEN        1400

extern VOS_UINT32 CBTCPM_NotifyChangePort(AT_PHY_PORT_ENUM_UINT32 enPhyPort);

/*****************************************************************************
   2 全局变量定义
*****************************************************************************/
#if(FEATURE_UE_MODE_NR == FEATURE_ON)
extern AT_MT_INFO_STRU                         g_stMtInfoCtx;
#else
extern AT_DEVICE_CMD_CTRL_STRU                 g_stAtDevCmdCtrl;
#endif
AT_SET_PORT_PARA_MAP_STRU    g_astSetPortParaMap[AT_SETPORT_DEV_MAP_LEN]
                                = {{"A1", AT_DEV_CDROM,        "CDROM"        },
                                   {"A2", AT_DEV_SD,           "SD"           },
                                   {"A3", AT_DEV_RNDIS,        "RNDIS"        },
                                   {"A",  AT_DEV_BLUE_TOOTH,   "BLUE TOOTH"   },
                                   {"B",  AT_DEV_FINGER_PRINT, "FINGER PRINT" },
                                   {"D",  AT_DEV_MMS,          "MMS"          },
#if(FEATURE_LTE == FEATURE_ON)
                                   {"E",  AT_DEV_PC_VOICE,     "3G PC VOICE"  },
                                   {"1",  AT_DEV_MODEM,        "3G MODEM"     },
                                   {"2",  AT_DEV_PCUI,         "3G PCUI"      },
                                   {"3",  AT_DEV_DIAG,         "3G DIAG"      },
#else
                                   {"E",  AT_DEV_PC_VOICE,     "PC VOICE"     },
                                   {"1",  AT_DEV_MODEM,        "MODEM"        },
                                   {"2",  AT_DEV_PCUI,         "PCUI"         },
                                   {"3",  AT_DEV_DIAG,         "DIAG"         },
#endif
                                   {"4",  AT_DEV_PCSC,         "PCSC"         },
#if(FEATURE_LTE == FEATURE_ON)
                                   {"5",  AT_DEV_GPS,          "3G GPS"       },
#else
                                   {"5",  AT_DEV_GPS,          "GPS"          },
#endif
                                   {"6",  AT_DEV_GPS_CONTROL,  "GPS CONTROL"  },
                                   {"7",  AT_DEV_NDIS,         "3G NDIS"      },
                                   {"16", AT_DEV_NCM,          "NCM"          },
                                   {"10",AT_DEV_4G_MODEM,      "4G MODEM"        },
                                   {"11",AT_DEV_4G_NDIS,       "4G NDIS"         },
                                   {"12",AT_DEV_4G_PCUI,       "4G PCUI"         },
                                   {"13",AT_DEV_4G_DIAG,       "4G DIAG"         },
                                   {"14",AT_DEV_4G_GPS,        "4G GPS"          },
                                   {"15",AT_DEV_4G_PCVOICE,    "4G PCVOICE"      },
                                   {"FF", AT_DEV_NONE,         "NO FIRST PORT"}
                                  };

TAF_UINT8                               gucSTKCmdQualify    =0x0;

/*AT/OM通道的链路索引*/
TAF_UINT8                               gucAtOmIndex        = AT_MAX_CLIENT_NUM;

/*纪录查询错误码的类型*/
TAF_UINT32                              gulErrType          = 1;

VOS_BOOL                                g_bSetFlg = VOS_FALSE;

VOS_UINT32                              g_ulWifiFreq;
VOS_UINT32                              g_ulWifiRate;
VOS_UINT32                              g_ulWifiMode;
VOS_INT32                               g_lWifiPower;
#if(FEATURE_LTE == FEATURE_ON)
VOS_UINT32                              g_ulWifiRF = 0xffffffffU;
AT_TMODE_RAT_FLAG_STRU g_stTmodeRat = {0};
VOS_UINT32 g_ulTmodeNum             = 0;
VOS_UINT32 g_ulGuTmodeCnfNum        = 0;
VOS_UINT32 g_ulLteOnly              = 0;
VOS_UINT32 g_ulGuOnly               = 0;
VOS_UINT32 g_ulLteIsSend2Dsp        = 0;

#endif
VOS_UINT                                g_ulUcastWifiRxPkts;
VOS_UINT                                g_ulMcastWifiRxPkts;

/* +CLCK命令参数CLASS与Service Type Code对应表 */
AT_CLCK_CLASS_SERVICE_TBL_STRU          g_astClckClassServiceTbl[] = {
    {AT_CLCK_PARA_CLASS_VOICE,                      TAF_SS_TELE_SERVICE,        TAF_ALL_SPEECH_TRANSMISSION_SERVICES_TSCODE},
    {AT_CLCK_PARA_CLASS_DATA,                       TAF_SS_BEARER_SERVICE,      TAF_ALL_BEARERSERVICES_BSCODE},
    {AT_CLCK_PARA_CLASS_FAX,                        TAF_SS_TELE_SERVICE,        TAF_ALL_FACSIMILE_TRANSMISSION_SERVICES_TSCODE},
    {AT_CLCK_PARA_CLASS_VOICE_FAX,                  TAF_SS_TELE_SERVICE,        TAF_ALL_TELESERVICES_EXEPTSMS_TSCODE},
    {AT_CLCK_PARA_CLASS_VOICE_DATA_FAX,             TAF_SS_TELE_SERVICE,        TAF_ALL_TELESERVICES_EXEPTSMS_TSCODE},
    {AT_CLCK_PARA_CLASS_SMS,                        TAF_SS_TELE_SERVICE,        TAF_ALL_SMS_SERVICES_TSCODE},
    {AT_CLCK_PARA_CLASS_VOICE_FAX_SMS,              TAF_SS_TELE_SERVICE,        TAF_ALL_TELESERVICES_TSCODE},
    {AT_CLCK_PARA_CLASS_VOICE_DATA_FAX_SMS,         TAF_SS_TELE_SERVICE,        TAF_ALL_TELESERVICES_TSCODE},
    {AT_CLCK_PARA_CLASS_DATA_SYNC,                  TAF_SS_BEARER_SERVICE,      TAF_ALL_DATA_CIRCUIT_SYNCHRONOUS_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_ASYNC,                 TAF_SS_BEARER_SERVICE,      TAF_ALL_DATA_CIRCUIT_ASYNCHRONOUS_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_PKT,                   TAF_SS_BEARER_SERVICE,      TAF_ALL_DATAPDS_SERVICES_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_SYNC_PKT,              TAF_SS_BEARER_SERVICE,      TAF_ALL_SYNCHRONOUS_SERVICES_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_PAD,                   TAF_SS_BEARER_SERVICE,      TAF_ALL_PADACCESSCA_SERVICES_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_ASYNC_PAD,             TAF_SS_BEARER_SERVICE,      TAF_ALL_ASYNCHRONOUS_SERVICES_BSCODE},
    {AT_CLCK_PARA_CLASS_DATA_SYNC_ASYNC_PKT_PKT,    TAF_SS_BEARER_SERVICE,      TAF_ALL_BEARERSERVICES_BSCODE},
};

TAF_WRITE_ACORE_NV_STRU                 g_stWriteAcoreNv = {0};

AT_MTA_BODY_SAR_STATE_ENUM_UINT16       g_enAtBodySarState = AT_MTA_BODY_SAR_OFF;

#if ( VOS_WIN32 == VOS_OS_VER )
EXTERN AT_USIMM_FILE_NUM_TO_ID_STRU g_aenAtUsimFileNumToIdTab[];
EXTERN VOS_UINT32 g_aenAtUsimFileNumToIdTabLen;

EXTERN AT_USIMM_FILE_NUM_TO_ID_STRU g_aenAtSimFileNumToIdTab[];
EXTERN VOS_UINT32 g_aenAtSimFileNumToIdTabLen;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
EXTERN AT_USIMM_FILE_NUM_TO_ID_STRU g_aenAtCsimFileNumToIdTab[];

EXTERN VOS_UINT32 g_aenAtCsimFileNumToIdTabLen;
#endif

#endif
#if ((FEATURE_UE_MODE_CDMA == FEATURE_ON)&&(FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)&&(FEATURE_CHINA_TELECOM_VOICE_ENCRYPT == FEATURE_ON))
#define             ENCRYPT_VOICE_DATA_FILE_MAX_NUM      5
EXTERN VOS_UINT8    gucCurrEncVoiceDataWriteFileNum;
EXTERN VOS_UINT32   gulAtCurrEncVoiceDataCount;
EXTERN VOS_UINT8    gucAtCurrEncVoiceTestFileNum;
EXTERN TAF_CHAR    *g_pacCurrEncVoiceDataWriteFilePath[];
EXTERN TAF_CHAR     gacAtCurrDocName[AT_TEST_ECC_FILE_NAME_MAX_LEN];
#endif


/*****************************************************************************
   3 函数、变量声明
*****************************************************************************/

extern void       TTF_SetGcfTestFlag(VOS_UINT32 ulGctTestFlag);

#if (VOS_WIN32 == VOS_OS_VER)
/* 输出TAF的回放数据 */
VOS_VOID NAS_MMA_SndNVData(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part1(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part2(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part3(VOS_VOID);

extern VOS_UINT32 NAS_SetLteRplmnId(TAF_PLMN_ID_STRU *pstPlmnId,
                                                                      VOS_UINT32               ulLai,
                                                                      VOS_UINT32 ulRac);


VOS_VOID NAS_STUB_AT_ResetNplmn(VOS_VOID);
VOS_VOID NAS_STUB_AT_SetNplmn(
    VOS_UINT8                           ucNplmnNum,
    TAF_MMA_PLMN_WITH_SIM_RAT_STRU     *pstNplmnList
);
extern VOS_VOID NAS_SetCsgCfg(
    VOS_UINT32 ulIsSupportCsgFlag,
    VOS_UINT32 ulEfadCsgDisplayIndicator,
    VOS_UINT32 ulOnlyReportOperatorCsgList);

extern VOS_UINT32 NAS_SetDamCfg(
    VOS_UINT8  ucDamActiveFlg,
     VOS_UINT8 ucEnableLteTrigPlmnSearch,
     VOS_UINT8 ucAddDamPlmnInDisabledPlmnList,
     VOS_UINT8 ucImsiPlmnNum,
     TAF_PLMN_ID_STRU *pstImsiPlmnList,
     VOS_UINT8 ucDamPlmnNum,
     TAF_PLMN_ID_STRU *pstDamPlmnList);

extern  VOS_UINT32 NAS_SetTinType(VOS_UINT8  ucTinType);
extern VOS_UINT32 NAS_SetPsBearerIsrFlg(VOS_UINT8  ucNsapi,VOS_UINT8  ucPdpIsrFlg,VOS_UINT8 ucPdpStatus);

extern VOS_UINT32 NAS_SetEonsPara(VOS_UINT8 ucNum, VOS_UINT8 *pucEnosPrioType, VOS_UINT8 ucRefreshAllFileRestartFlag);

extern VOS_UINT32 NAS_SetDisableRatPlmn(VOS_UINT32  ulFlg);

extern VOS_UINT32 NAS_SetHighPrioPlmnRefreshTriggerBGSearchCfg(VOS_UINT8 ulOnOff, VOS_UINT32 ulDelayLen);

extern VOS_UINT32 NAS_SetPsRegContainDrx(VOS_UINT8 ucDrx);
extern  VOS_UINT32 NAS_SetLteImsSupportFlag(VOS_UINT8 ucLteImsSupportFlg, VOS_UINT8 ucLteEmsSupportFlg);
extern  VOS_UINT32 NAS_SetImsLteCapabilitySupportFlag(
    VOS_UINT8                           ucVoiceCallOnImsSupportFlg,
    VOS_UINT8                           ucVideoCallOnImsSupportFlg,
    VOS_UINT8                           ucSmsOnImsSupportFlg
);

extern  VOS_UINT32 NAS_SetPreferDomain(VOS_UINT8 ucVoiceDomain, VOS_UINT8 ucSmsDomain, VOS_UINT8 ucUpdateMmlVoiceDomainFlag);


extern VOS_UINT32 NAS_SetImsRoaming(VOS_UINT8 ucImsRoamingFlag);
extern VOS_UINT32 NAS_SetRedialCfg(
    VOS_UINT8                           ucCallRedialImsToCs,
    VOS_UINT8                           ucSmsRedialImsToCs,
    VOS_UINT8                           ucSsRedialImsToCs,
    VOS_UINT8                           ucCallRedialCsToIms,
    VOS_UINT8                           ucSmsRedialCsToIms,
    VOS_UINT8                           ucSsRedialCsToIms
);

extern  VOS_UINT32 NAS_SetImsVoiceInterSysLauEnable(VOS_UINT8 ucLauFlag);
extern  VOS_UINT32 NAS_SetImsVoiceMMEnableFlg(VOS_UINT8 ucMMFlag);


extern VOS_UINT32 NAS_SetImsUssd(VOS_UINT8 ucImsUssdFlag);

extern VOS_UINT32 NAS_SetWildCardPara(VOS_CHAR cWildcard);

extern VOS_UINT32 NAS_SetCsUnAvailPlmnId(
    VOS_UINT32                          ulFlg,
    TAF_PLMN_ID_STRU                   *pstPlmnId
);

LOCAL VOS_UINT32 AT_IsSpecRatSupported(
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enRatMode,
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder
);

LOCAL VOS_UINT32 AT_IsModeConflictingDomain(
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
);


extern VOS_UINT32 NAS_SetForbRoamTa(VOS_UINT32 ulPara);
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (2 <= MULTI_MODEM_NUMBER)
LOCAL VOS_UINT32  At_QryCdmaModemSwitchCdmaCapCheck(
    VOS_UINT32                          ulModem0SupportCMode,
    VOS_UINT32                          ulModem1SupportCMode,
#if (3 == MULTI_MODEM_NUMBER)
    VOS_UINT32                          ulModem2SupportCMode,
#endif
    VOS_UINT32                         *pulAllModemNotSupportCMode
    );
#endif
#endif

/*****************************************************************************
   4 函数实现
*****************************************************************************/


PPP_AUTH_TYPE_ENUM_UINT8 AT_CtrlGetPDPAuthType(
    VOS_UINT32                          Value,
    VOS_UINT16                          usTotalLen
)
{
    /*获取验证方法*/
    if (usTotalLen == 0)
    {
        return TAF_PDP_AUTH_TYPE_NONE;
    }
    else
    {
        if(Value == 0)
        {
            return TAF_PDP_AUTH_TYPE_NONE;
        }
        else if (Value == 1)
        {
            return TAF_PDP_AUTH_TYPE_PAP;
        }
        else
        {
            return TAF_PDP_AUTH_TYPE_CHAP;
        }
    }
}



TAF_PDP_AUTH_TYPE_ENUM_UINT8 AT_ClGetPdpAuthType(
    VOS_UINT32                          Value,
    VOS_UINT16                          usTotalLen
)
{
    /*获取验证方法*/
    if (usTotalLen == 0)
    {
        return TAF_PDP_AUTH_TYPE_NONE;
    }
    else
    {
        switch (Value)
        {
            case 0:
                return TAF_PDP_AUTH_TYPE_NONE;
            case 1:
                return TAF_PDP_AUTH_TYPE_PAP;
            case 2:
                return TAF_PDP_AUTH_TYPE_CHAP;
            case 3:
                return TAF_PDP_AUTH_TYPE_PAP_OR_CHAP;
            default :
                return TAF_PDP_AUTH_TYPE_BUTT;

        }
    }
}

TAF_UINT32 At_SsPrint2Class(TAF_SS_BASIC_SERVICE_STRU *pBsService,TAF_UINT8 ucClass)
{
    VOS_UINT32                          ulLoop;
    VOS_UINT32                          ulItemsNum;

    ulItemsNum = sizeof(g_astClckClassServiceTbl) / sizeof(AT_CLCK_CLASS_SERVICE_TBL_STRU);

    /* 查表填写对应Class的服务类型及服务码 */
    for (ulLoop = 0; ulLoop < ulItemsNum; ulLoop++)
    {
        if (g_astClckClassServiceTbl[ulLoop].enClass == ucClass)
        {
            pBsService->BsType = g_astClckClassServiceTbl[ulLoop].enServiceType;
            pBsService->BsServiceCode = g_astClckClassServiceTbl[ulLoop].enServiceCode;
            return AT_SUCCESS;
        }
    }

    return AT_FAILURE;
}

/*****************************************************************************
 Prototype      : At_SsPrint2Code
 Description    :
 Input          : ucClass --- SSA的Code
 Output         : ---
 Return Value   : ulRtn输出结果
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_VOID At_SsPrint2Code(TAF_SS_CODE *pSsCode,TAF_UINT8 ucType)
{
    switch(ucType)
    {
    case AT_CLCK_AO_TYPE:
        *pSsCode = TAF_BAOC_SS_CODE;
        break;

    case AT_CLCK_OI_TYPE:
        *pSsCode = TAF_BOIC_SS_CODE;
        break;

    case AT_CLCK_OX_TYPE:
        *pSsCode = TAF_BOICEXHC_SS_CODE;
        break;

    case AT_CLCK_AI_TYPE:
        *pSsCode = TAF_BAIC_SS_CODE;
        break;

    case AT_CLCK_IR_TYPE:
        *pSsCode = TAF_BICROAM_SS_CODE;
        break;

    case AT_CLCK_AB_TYPE:
        *pSsCode = TAF_ALL_BARRING_SS_CODE;
        break;

    case AT_CLCK_AG_TYPE:
        *pSsCode = TAF_BARRING_OF_OUTGOING_CALLS_SS_CODE;
        break;

    default:
        *pSsCode = TAF_BARRING_OF_INCOMING_CALLS_SS_CODE;
        break;
    }
}

#if ( VOS_WIN32 == VOS_OS_VER )

VOS_UINT32 AT_ReadValueFromNvim(
    const NV_ID_ENUM_U16                enNVItemType,
    VOS_VOID                           *pData,
    VOS_UINT32                          usDataLen,
    MODEM_ID_ENUM_UINT16                enModemId
)
{
    VOS_UINT32                          ulRst;
    ulRst = TAF_ACORE_NV_READ(enModemId, enNVItemType, pData, usDataLen);
    switch ( ulRst)
    {
        case NV_OK :
            return AT_OK;
        case NV_ID_NOT_EXIST:
        case NV_BUFFER_TOO_LONG :
            return AT_CME_INCORRECT_PARAMETERS;
        default:
            return AT_ERROR ;
    }
}
#endif

TAF_UINT32 At_AsciiNum2HexString(TAF_UINT8 *pucSrc, TAF_UINT16 *pusSrcLen)
{
    TAF_UINT16 usChkLen = 0;
    TAF_UINT16 usTmp = 0;
    TAF_UINT8  ucLeft = 0;
    TAF_UINT16 usSrcLen = *pusSrcLen;
    TAF_UINT8 *pucDst = pucSrc;

    /* 如果是奇数个半字节则返回错误 */
    if((usSrcLen % 2) != 0)
    {
        return AT_FAILURE;
    }

    while(usChkLen < usSrcLen)
    {
        if( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            ucLeft = pucSrc[usChkLen] - '0';
        }
        else if( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        pucDst[usTmp] = 0xf0 & (ucLeft << 4);
        usChkLen += 1;

        if( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            pucDst[usTmp] |= pucSrc[usChkLen] - '0';
        }
        else if( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            pucDst[usTmp] |= (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            pucDst[usTmp] |= (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        usChkLen += 1;
        usTmp += 1;
    }

    *pusSrcLen = usSrcLen / 2;
    return AT_SUCCESS;
}


LOCAL VOS_UINT32 At_CheckAsciiStringLen(
    VOS_UINT16                          usSrcLen
)
{
    if( (usSrcLen < 2) || (usSrcLen > 255) )
    {
        return VOS_ERR;
    }

    return VOS_OK;
}


TAF_UINT32 At_AsciiString2HexText(SI_STK_TEXT_STRING_STRU *pTextStr,TAF_UINT8 *pucSrc,TAF_UINT16 usSrcLen)
{
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucTmp = 0;
    TAF_UINT8  ucLeft = 0;
    TAF_UINT8 *pucDst = pTextStr->pucText;

    if (At_CheckAsciiStringLen(usSrcLen) != VOS_OK)
    {
        AT_ERR_LOG1("At_AsciiString2HexText: usSrcLen is wrong.",usSrcLen);
        return AT_FAILURE;
    }

    while(usChkLen < usSrcLen)
    {
        if( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            ucLeft = pucSrc[usChkLen] - '0';
        }
        else if( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        pucDst[ucTmp] = 0xf0 & (ucLeft << 4);

        usChkLen += 1;

        if( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= pucSrc[usChkLen] - '0';
        }
        else if( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        usChkLen += 1;

        ucTmp += 1;
    }

    pTextStr->ucLen = ucTmp;

    return AT_SUCCESS;
}


TAF_UINT32 At_AsciiString2HexSimple(TAF_UINT8 *pTextStr,TAF_UINT8 *pucSrc,TAF_UINT16 usSrcLen)
{
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucTmp = 0;
    TAF_UINT8  ucLeft = 0;
    TAF_UINT8 *pucDst = pTextStr;

    if(usSrcLen == 0)
    {
        return AT_FAILURE;
    }

    while(usChkLen < usSrcLen)
    {
        if ( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            ucLeft = pucSrc[usChkLen] - '0';
        }
        else if ( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if ( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            ucLeft = (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        pucDst[ucTmp] = 0xf0 & (ucLeft << 4);

        usChkLen += 1;

        if ( (pucSrc[usChkLen] >= '0') && (pucSrc[usChkLen] <= '9') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= pucSrc[usChkLen] - '0';
        }
        else if ( (pucSrc[usChkLen] >= 'a') && (pucSrc[usChkLen] <= 'f') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= (pucSrc[usChkLen] - 'a') + 0x0a;
        }
        else if ( (pucSrc[usChkLen] >= 'A') && (pucSrc[usChkLen] <= 'F') ) /* the number is 0-9 */
        {
            pucDst[ucTmp] |= (pucSrc[usChkLen] - 'A') + 0x0a;
        }
        else
        {
            return AT_FAILURE;
        }

        usChkLen += 1;

        ucTmp += 1;
    }

    return AT_SUCCESS;
}

/* Del At_AbortCmdProc */


TAF_UINT32 AT_HexToAsciiString(
    TAF_UINT8                          *pucDstStr,
    TAF_UINT32                          ulDstLen,
    TAF_UINT8                          *pucSrcStr,
    TAF_UINT32                          ulSrcLen
)
{
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucHigh   = 0;
    TAF_UINT8  ucLow    = 0;
    TAF_UINT8 *pRead    = pucSrcStr;
    TAF_UINT8 *pWrite   = pucDstStr;

    if ((pucSrcStr == VOS_NULL_PTR)||(pucDstStr == VOS_NULL_PTR)||(ulSrcLen == 0))
    {
        return AT_ERROR;
    }

    /* 扫完整个字串 */
    while (usChkLen++ < ulSrcLen)
    {
        ucHigh = 0x0F & (*pRead >> 4);
        ucLow = 0x0F & *pRead;

        if (ucHigh <= 0x09)
        {
            /* 0-9 */
            *pWrite++ = ucHigh + 0x30;
        }
        else
        {
            /* A-F */
            *pWrite++ = ucHigh + 0x37;
        }

        if (ucLow <= 0x09)
        {
            *pWrite++ = ucLow + 0x30;
        }
        else
        {
            *pWrite++ = ucLow + 0x37;
        }

        /* 下一个字符 */
        pRead++;
    }
    *pWrite = '\0';
    return AT_OK;
}


TAF_UINT32 At_AsciiNum2BcdNum (TAF_UINT8 *pucDst, TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen)
{
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucTmp = 0;
    TAF_UINT8  ucBcdCode;

    for(usChkLen = 0; usChkLen < usSrcLen; usChkLen++)
    {
        ucTmp = usChkLen % 2;   /* 判断高低位 */

        if ((pucSrc[usChkLen] >= 0x30) && (pucSrc[usChkLen] <= 0x39)) /* the number is 0-9 */
        {
            ucBcdCode = pucSrc[usChkLen] - 0x30;
        }
        else if (pucSrc[usChkLen] == '*')
        {
            ucBcdCode = 0x0a;
        }
        else if (pucSrc[usChkLen] == '#')
        {
            ucBcdCode = 0x0b;
        }
        else if ((pucSrc[usChkLen] == 'a')
              || (pucSrc[usChkLen] == 'b')
              || (pucSrc[usChkLen] == 'c'))
        {
            ucBcdCode = (VOS_UINT8)((pucSrc[usChkLen] - 'a') + 0x0c);
        }
        else
        {
            return AT_FAILURE;
        }

        ucTmp = usChkLen % 2;   /* 判断高低位 */
        if(ucTmp == 0)
        {
            pucDst[usChkLen/2] = ucBcdCode;   /* 低位 */
        }
        else
        {
            pucDst[usChkLen/2] |= (TAF_UINT8)(ucBcdCode << 4);   /* 高位 */
        }
    }

    if((usSrcLen % 2) == 1)
    {
        pucDst[usSrcLen/2] |= 0xf0; /* 高位 */
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_AsciiNum2Num (TAF_UINT8 *pucDst, TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen)
{
    TAF_UINT16 usChkLen = 0;

    for(usChkLen = 0; usChkLen < usSrcLen; usChkLen++)
    {

        if( (pucSrc[usChkLen] >= 0x30) && (pucSrc[usChkLen] <= 0x39) ) /* the number is 0-9 */
        {
                pucDst[usChkLen] = pucSrc[usChkLen] - 0x30;   /* 低位 */
        }
        else
        {
            return AT_FAILURE;
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_CheckDialString(TAF_UINT8 *pData, TAF_UINT16 usLen)
{
    TAF_UINT16 usCount = 0;
    TAF_UINT8 *pTmp = pData;

    if (*pTmp == '+')
    {
        pTmp++;
        usCount++;
    }

    while(usCount++ < usLen)
    {
        if ((*pTmp >= '0') && (*pTmp <= '9'))
        {
        }
        else if ((*pTmp >= 'a') && (*pTmp <= 'c'))
        {
        }
        else if ((*pTmp >= 'A') && (*pTmp <= 'C'))
        {
        }
        else if ((*pTmp == '*') || (*pTmp == '#'))
        {
        }
        else
        {
            return AT_FAILURE;
        }
        pTmp++;
    }
    return AT_SUCCESS;
}


TAF_UINT32 At_CheckPBString(TAF_UINT8 *pData, TAF_UINT16 *pusLen)
{
    TAF_UINT16                          usCount = 0;
    TAF_UINT8                          *pTmp = pData;
    TAF_UINT8                           usInvalidNum = 0;

    while(usCount++ < *pusLen)
    {
        if((*pTmp == '(')||(*pTmp == ')')||(*pTmp == '-')||(*pTmp == '"'))
        {
            TAF_MEM_MOVE_S(pTmp, (VOS_SIZE_T)(*pusLen - usCount), pTmp+1, (VOS_SIZE_T)(*pusLen - usCount));
            usInvalidNum++;
        }
        else
        {
            pTmp++;
        }
    }

    usCount = 0;
    pTmp = pData;
    *pusLen -= usInvalidNum;

    while(usCount++ < *pusLen)
    {
        if(!( ((*pTmp >= '0') && (*pTmp <= '9'))
           || (*pTmp == '*') || (*pTmp == '#') || (*pTmp == '?')
           || (*pTmp == ',') || (*pTmp == 'P') || (*pTmp == 'p')))
        {
            return AT_FAILURE;
        }
        pTmp++;
    }
    return AT_SUCCESS;
}

/*****************************************************************************
 Prototype      : At_CheckNumLen
 Description    :
 Input          :
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32  At_CheckNumLen(TAF_UINT16 usMax,TAF_UINT16 usLen)
{
    /* 如果号码过长，直接返回错误 */
    if(gucAtCscsType == AT_CSCS_UCS2_CODE)
    {
        if((usMax * 4) < usLen)
        {
            return AT_FAILURE;
        }
    }
    else
    {
        if(usMax < usLen)
        {
            return AT_FAILURE;
        }
    }
    return AT_SUCCESS;
}

TAF_UINT32  At_CheckUssdNumLen(
    VOS_UINT8                           ucIndex,
    TAF_SS_DATA_CODING_SCHEME           dcs,
    TAF_UINT16                          usLen
)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);




    if(pstSsCtx->usUssdTransMode == AT_USSD_NON_TRAN_MODE)
    {
        if(usLen > TAF_SS_MAX_USSDSTRING_LEN)
        {
            return AT_FAILURE;
        }
    }
    else
    {
        if(usLen > (TAF_SS_MAX_USS_CHAR * 2))
        {
            return AT_FAILURE;
        }

    }

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo81CalcLength(const TAF_UINT8 *pucData,
                                            TAF_UINT16      usLen,
                                            TAF_UINT16      *pusBaseCode,
                                            TAF_UINT16      *pusDstLen)
{
    TAF_UINT16      usUnicodeChar;
    TAF_UINT16      usBaseCode = 0;
    TAF_UINT16      usIndex;
    TAF_BOOL        bIsBaseSet = TAF_FALSE;
    TAF_UINT16      usDstLen = 0;
    TAF_UINT8       aucGsmData[2];
    TAF_UINT16      usGsmDataLen = 0;

    /* 输入参数赋初值 */
    *pusDstLen = 0;
    *pusBaseCode = 0;

    for (usIndex = 0; usIndex < (usLen >> 1); usIndex++)
    {
        usUnicodeChar = (*pucData << 8) | (*(pucData + 1));

        pucData += 2;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(usUnicodeChar, aucGsmData, sizeof(aucGsmData), &usGsmDataLen) == AT_SUCCESS)
        {
            usDstLen += usGsmDataLen;

            continue;
        }

        /* 81编码用第8到第15bit进行编码，即0hhh hhhh hXXX XXXX，因此第16bit为1一定不能进行81编码 */
        if ((usUnicodeChar & 0x8000) != 0)
        {
            AT_ERR_LOG("At_UnicodeTransferTo81CalcLength error: no16 bit is 1");

            return AT_FAILURE;
        }

        if (bIsBaseSet == TAF_FALSE)
        {
            /* 取第一个UCS2的第8到第15bit作为BaseCode，BaseCode右移7位即为基址针 */
            bIsBaseSet = TAF_TRUE;
            usBaseCode = usUnicodeChar & AT_PB_81_CODE_BASE_POINTER;
        }
        else
        {
            if (usBaseCode != (usUnicodeChar & AT_PB_81_CODE_BASE_POINTER))
            {
                AT_ERR_LOG("At_UnicodeTransferTo81CalcLength error: code base error");

               return AT_FAILURE;
            }
        }

        usDstLen++;
    }

    /* 能进行81编码，返回基本码和81编码总长度 */
    *pusBaseCode = usBaseCode;
    *pusDstLen   = usDstLen + AT_PB_81CODE_HEADER_LEN;

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo82CalcLength(const TAF_UINT8 *pucData,
                                            TAF_UINT16      usLen,
                                            TAF_UINT16      *pusBaseCode,
                                            TAF_UINT16      *pusDstLen)
{
    TAF_UINT16      usUnicodeChar;
    TAF_UINT16      usIndex;
    TAF_BOOL        bIsBaseSet = TAF_FALSE;
    TAF_UINT16      us82BaseHigh = 0;
    TAF_UINT16      us82BaseLow = 0;
    TAF_UINT16      usDstLen = 0;
    TAF_UINT8       aucGsmData[2];
    TAF_UINT16      usGsmDataLen = 0;

    /* 输入参数赋初值 */
    *pusDstLen = 0;
    *pusBaseCode = 0;

    for (usIndex = 0; usIndex < (usLen >> 1); usIndex++)
    {
        usUnicodeChar = (*pucData << 8) | (*(pucData + 1));

        pucData += 2;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(usUnicodeChar, aucGsmData, sizeof(aucGsmData), &usGsmDataLen) == AT_SUCCESS)
        {
            usDstLen += usGsmDataLen;

            continue;
        }


        if (bIsBaseSet == TAF_FALSE)
        {
            bIsBaseSet = TAF_TRUE;
            us82BaseHigh = usUnicodeChar;
            us82BaseLow  = usUnicodeChar;
        }
        else
        {
            if (usUnicodeChar < us82BaseLow)
            {
                us82BaseLow = usUnicodeChar;
            }

            if (usUnicodeChar > us82BaseHigh)
            {
                us82BaseHigh = usUnicodeChar;
            }

            /* UCS2码流中最大编码和最小编码差值超过127就不能进行82编码 */
            if ((us82BaseHigh - us82BaseLow) > AT_PB_GSM7_CODE_MAX_VALUE)
            {
                 AT_ERR_LOG("At_UnicodeTransferTo82CalcLength error: code base error");

                return AT_FAILURE;
            }
        }

        usDstLen++;
    }

    /* 能进行82编码，返回基本码和82编码总长度 */
    *pusBaseCode = us82BaseLow;
    *pusDstLen   = usDstLen + AT_PB_82CODE_HEADER_LEN;

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo81(const TAF_UINT8 *pucData,
                                  TAF_UINT16      usLen,
                                  TAF_UINT16      usCodeBase,
                                  TAF_UINT8       *pucDest)
{
    errno_t         lMemResult;
    TAF_UINT16      usUnicodeChar;
    TAF_UINT16      i;
    TAF_UINT8       aucGsmData[2];
    TAF_UINT16      usGsmDataLen = 0;
    TAF_UINT16      usDstLen     = AT_PB_81CODE_HEADER_LEN;

    for (i = 0; i < (usLen >> 1); i++)
    {
        usUnicodeChar = (*pucData << 8) | (*(pucData + 1));

        pucData += 2;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(usUnicodeChar, aucGsmData, sizeof(aucGsmData), &usGsmDataLen) == AT_SUCCESS)
        {
            lMemResult = memcpy_s((pucDest + usDstLen), SI_PB_ALPHATAG_MAX_LEN - usDstLen, aucGsmData, usGsmDataLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, SI_PB_ALPHATAG_MAX_LEN - usDstLen, usGsmDataLen);
            usDstLen += usGsmDataLen;

            continue;
        }

        /* 容错处理 */
        if ((usCodeBase | (usUnicodeChar & AT_PB_GSM7_CODE_MAX_VALUE)) == usUnicodeChar)
        {
            /* 转为81的编码方式 */
            pucDest[usDstLen++] =(TAF_UINT8)( AT_PB_CODE_NO8_BIT | (usUnicodeChar & AT_PB_GSM7_CODE_MAX_VALUE));
        }
        else
        {
            AT_ERR_LOG("At_UnicodeTransferTo81 error");

            return AT_FAILURE;
        }
    }

    /* 设置81编码header信息 */
    pucDest[0] = SI_PB_ALPHATAG_TYPE_UCS2_81;
    pucDest[1] = (TAF_UINT8)(usDstLen - AT_PB_81CODE_HEADER_LEN);
    pucDest[2] = (TAF_UINT8)((usCodeBase & AT_PB_81_CODE_BASE_POINTER)>>7);

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo82(const TAF_UINT8 *pucData,
                                  TAF_UINT16      usLen,
                                  TAF_UINT16      usCodeBase,
                                  TAF_UINT8       *pucDest)
{
    errno_t         lMemResult;
    TAF_UINT16      usUnicodeChar;
    TAF_UINT16      i;
    TAF_UINT8       aucGsmData[2];
    TAF_UINT16      usGsmDataLen = 0;
    TAF_UINT16      usDstLen     = AT_PB_82CODE_HEADER_LEN;

    for (i = 0; i < (usLen >> 1); i++)
    {
        usUnicodeChar = (*pucData << 8) | (*(pucData + 1));

        pucData += 2;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(usUnicodeChar, aucGsmData, sizeof(aucGsmData), &usGsmDataLen) == AT_SUCCESS)
        {
            lMemResult = memcpy_s(pucDest + usDstLen, SI_PB_ALPHATAG_MAX_LEN - usDstLen, aucGsmData, usGsmDataLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, SI_PB_ALPHATAG_MAX_LEN - usDstLen, usGsmDataLen);
            usDstLen += usGsmDataLen;

            continue;
        }

        /* 容错处理 */
        if ((usUnicodeChar - usCodeBase) <= AT_PB_GSM7_CODE_MAX_VALUE)
        {
            /* 转为82的编码方式 */
            pucDest[usDstLen++] = ((TAF_UINT8)(usUnicodeChar - usCodeBase)) |  AT_PB_CODE_NO8_BIT;
        }
        else
        {
            AT_ERR_LOG("At_UnicodeTransferTo81 error");

            return AT_FAILURE;
        }
    }

    /* 设置82编码header信息 */
    pucDest[0] = SI_PB_ALPHATAG_TYPE_UCS2_82;
    pucDest[1] = (TAF_UINT8)(usDstLen - AT_PB_82CODE_HEADER_LEN);
    pucDest[2] = (TAF_UINT8)((usCodeBase & 0xff00)>> 8);
    pucDest[3] = (TAF_UINT8)(usCodeBase & 0x00ff);

    return AT_SUCCESS;
}


TAF_UINT32 At_Gsm7BitFormat(TAF_UINT8   *pucSrc,
                            TAF_UINT16  usSrcLen,
                            TAF_UINT8   *pucDst,
                            TAF_UINT8   *pucDstLen)
{
   TAF_UINT16       usIndex;

   for (usIndex = 0; usIndex < usSrcLen; usIndex++)
   {
        /* GSM模式下输入码流大于0x7f时提示用户输入中含有非法字符 */
        if (pucSrc[usIndex] > AT_PB_GSM7_CODE_MAX_VALUE)
        {
            return AT_FAILURE;
        }

        pucDst[usIndex] = pucSrc[usIndex];
   }

   *pucDstLen = (TAF_UINT8)usSrcLen;

   return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrint2Unicode(TAF_UINT8 *pData,TAF_UINT16 *pLen)
{
    TAF_UINT8 *pCheck   = pData;
    TAF_UINT8 *pWrite   = pData;
    TAF_UINT8 *pRead    = pData;
    TAF_UINT16 usLen    = 0;
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucHigh   = 0;
    TAF_UINT8  ucLow    = 0;

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while( usChkLen++ < *pLen )
    {
        if( (*pCheck >= '0') && (*pCheck <= '9') )
        {
            *pCheck = *pCheck - '0';
        }
        else if( (*pCheck >= 'a') && (*pCheck <= 'f') )
        {
            *pCheck = (*pCheck - 'a') + 10;
        }
        else if( (*pCheck >= 'A') && (*pCheck <= 'F') )
        {
            *pCheck = (*pCheck - 'A') + 10;
        }
        else
        {
            return AT_FAILURE;
        }
        pCheck++;
    }

    while(usLen < *pLen)                    /* 判断结尾 */
    {
        ucHigh = *pRead++;                  /* 高位 */
        usLen++;
        ucLow  = *pRead++;                  /* 低位 */
        usLen++;

        *pWrite++ = (TAF_UINT8)(ucHigh * 16) + ucLow;    /* 写入UNICODE的一个字节 */
    }

    *pLen = usLen >> 1;
    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrintToAscii(TAF_UINT8 *pData,TAF_UINT16 *pLen)
{
    TAF_UINT8 *pCheck        = pData;
    TAF_UINT8 *pWrite        = pData;
    TAF_UINT8 *pRead         = pData;
    TAF_UINT16 usLen         = 0;
    TAF_UINT16 usChkLen      = 0;
    TAF_UINT8  ucFirstByte   = 0;
    TAF_UINT8  ucSecondByte  = 0;
    TAF_UINT8  ucHigh        = 0;
    TAF_UINT8  ucLow         = 0;

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while (usChkLen++ < *pLen)
    {
        if ((*pCheck >= '0') && (*pCheck <= '9'))
        {
            *pCheck = *pCheck - '0';
        }
        else if ((*pCheck >= 'a') && (*pCheck <= 'f'))
        {
            *pCheck = (*pCheck - 'a') + 10;
        }
        else if ((*pCheck >= 'A') && (*pCheck <= 'F'))
        {
            *pCheck = (*pCheck - 'A') + 10;
        }
        else
        {
            return AT_FAILURE;
        }
        pCheck++;
    }

    while(usLen < *pLen)                                                        /* 判断结尾 */
    {
        ucFirstByte  = *pRead++;                                                /* 前两位必须为0 */
        usLen++;
        ucSecondByte = *pRead++;
        usLen++;

        if ((ucFirstByte != 0) || (ucSecondByte != 0))
        {
            return AT_FAILURE;
        }

        ucHigh       = *pRead++;                                                /* 高位 */
        usLen++;
        ucLow        = *pRead++;                                                /* 低位 */
        usLen++;

        *pWrite++ = (TAF_UINT8)(ucHigh * 16) + ucLow;                          /* 写入Unicode的一个字节 */
    }

    *pLen = usLen >> 2;
    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrint2Ascii(TAF_UINT8 *pucDst, TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen)
{
    TAF_UINT8 *pWrite   = pucDst;
    TAF_UINT8 *pRead    = pucSrc;
    TAF_UINT8  aucTmp[4];
    TAF_UINT16 usChkLen = 0;
    TAF_UINT8  ucIndex = 0;

    /* 每4个字符可以转成一个ASCII码 */
    if((usSrcLen % 4) != 0)
    {
        return AT_FAILURE;
    }

    /* 清空临时缓存 */
    memset_s(aucTmp, sizeof(aucTmp), 0x00, 4);

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while( usChkLen++ < usSrcLen )
    {
        if( (*pRead >= '0') && (*pRead <= '9') )
        {
            aucTmp[ucIndex++] = *pRead - '0';
        }
        else if( (*pRead >= 'a') && (*pRead <= 'f') )
        {
            aucTmp[ucIndex++] = (*pRead - 'a') + 10;
        }
        else if( (*pRead >= 'A') && (*pRead <= 'F') )
        {
            aucTmp[ucIndex++] = (*pRead - 'A') + 10;
        }
        else
        {
            return AT_FAILURE;
        }

        /* 每四个字符得出一个字符 */
        if(ucIndex == 4)
        {
            /* 必须是数字类型 */
            if((aucTmp[0] != 0) || (aucTmp[1] != 0))
            {
                return AT_FAILURE;
            }

            *pWrite++ = (TAF_UINT8)(aucTmp[2] * 16) + aucTmp[3];    /* 写入一个字节 */
            if(At_CheckDialNum(*(pWrite-1)) == AT_FAILURE)
            {
                return AT_FAILURE;
            }
            /* 重新开始 */
            ucIndex = 0;
        }

        /* 下一个字符 */
        pRead++;
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_CheckNameUCS2Code(TAF_UINT8 *pucData, TAF_UINT16 *pusLen)
{
    TAF_UINT8 ucAlphType = *pucData;
    TAF_UINT16 usAlphLen = *(pucData+1);

    if ((ucAlphType == SI_PB_ALPHATAG_TYPE_UCS2_80) && (((*pusLen-1)%2) == 0))
    {
        /* 80编码，除了标记字节其余长度必须为偶数字节 */
        return AT_SUCCESS;
    }

    if ((ucAlphType == SI_PB_ALPHATAG_TYPE_UCS2_81) && ((*pusLen-3) >= usAlphLen))
    {
        /* 81编码，实际字符长度必须大于码流中长度字节的值 */
        *pusLen = usAlphLen + 3;
        return AT_SUCCESS;
    }

    if ((ucAlphType == SI_PB_ALPHATAG_TYPE_UCS2_82) && ((*pusLen-4) >= usAlphLen))
    {
        /* 82编码，同上，区别是基址是2个字节 */
        *pusLen = usAlphLen + 4;
        return AT_SUCCESS;
    }

    return AT_FAILURE;

}


VOS_VOID AT_PhSendRestoreFactParm( VOS_VOID )
{
    VOS_UINT16                          usLength;
    VOS_UINT32                          i;

    for(i = 0; i < AT_MAX_CLIENT_NUM; i++)
    {
        if (gastAtClientTab[i].UserType == AT_APP_USER)
        {
            break;
        }
    }

    /* 未找到E5 User,则不用上报 */
    if ( i >= AT_MAX_CLIENT_NUM )
    {
        return ;
    }

    usLength = 0;
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                     "%s",gaucAtCrLf);
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                      "^FACTORY");
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                     "%s",gaucAtCrLf);

    At_SendResultData((VOS_UINT8)i,pgucAtSndCodeAddr,usLength);
}


VOS_VOID AT_PhSendRestoreFactParmNoReset( VOS_VOID )
{
    VOS_UINT16                          usLength;
    VOS_UINT32                          i;

    for(i = 0; i < AT_MAX_CLIENT_NUM; i++)
    {
        if (gastAtClientTab[i].UserType == AT_APP_USER)
        {
            break;
        }
    }

    /* 未找到E5 User,则不用上报 */
    if ( i >= AT_MAX_CLIENT_NUM )
    {
        return ;
    }

    usLength = 0;
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                     "%s",gaucAtCrLf);
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                      "^NORSTFACT");
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                     "%s",gaucAtCrLf);

    At_SendResultData((VOS_UINT8)i,pgucAtSndCodeAddr,usLength);
}


/*****************************************************************************
 Prototype      : At_SetNumTypePara
 Description    : 设置UNICODE或者ASCII类型的号码
 Input          : pucDst   --- 目的字串
                  pucSrc   --- 源字串
                  usSrcLen --- 源字串长度
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetNumTypePara(TAF_UINT8 *pucDst, TAF_UINT32 ulDstLen,
                                     TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen)
{
    errno_t                             lMemResult;
    TAF_UINT32                          ulRet;
    TAF_UINT16                          usAsciiStrLen;

    if(gucAtCscsType == AT_CSCS_UCS2_CODE)
    {
        ulRet = At_UnicodePrint2Ascii(pucDst,pucSrc,usSrcLen);
        if (ulRet != AT_SUCCESS)
        {
            return ulRet;
        }
    }
    else
    {
        lMemResult = memcpy_s(pucDst, ulDstLen, pucSrc, usSrcLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, ulDstLen, usSrcLen);
    }

    usAsciiStrLen = (TAF_UINT16)VOS_StrLen((TAF_CHAR *)pucDst);
    if(At_CheckDialString(pucDst, usAsciiStrLen) == AT_SUCCESS)
    {
        return AT_SUCCESS;
    }
    else
    {
        return AT_FAILURE;
    }
}



TAF_UINT32 At_UpdateMsgRcvAct(
    TAF_UINT8                           ucIndex,
    AT_CSMS_MSG_VERSION_ENUM_U8         ucCsmsVersion,
    AT_CNMI_MT_TYPE                     CnmiMtType,
    AT_CNMI_DS_TYPE                     CnmiDsType
)
{
    MN_MSG_SET_RCVMSG_PATH_PARM_STRU    stRcvPath;
    MN_MSG_RCVMSG_ACT_ENUM_U8           enRcvSmAct[AT_CNMI_MT_TYPE_MAX] = {MN_MSG_RCVMSG_ACT_STORE,
                                                                           MN_MSG_RCVMSG_ACT_STORE,
                                                                           MN_MSG_RCVMSG_ACT_TRANSFER_AND_ACK,
                                                                           MN_MSG_RCVMSG_ACT_STORE};
    MN_MSG_RCVMSG_ACT_ENUM_U8           enRcvStaRptAct[AT_CNMI_DS_TYPE_MAX] = {MN_MSG_RCVMSG_ACT_STORE,
                                                                               MN_MSG_RCVMSG_ACT_TRANSFER_AND_ACK,
                                                                               MN_MSG_RCVMSG_ACT_STORE};

    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;
    errno_t                             lMemResult;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(&stRcvPath, sizeof(stRcvPath), 0x00, sizeof(MN_MSG_SET_RCVMSG_PATH_PARM_STRU));

    if ((CnmiMtType >= AT_CNMI_MT_TYPE_MAX)
     || (CnmiDsType >= AT_CNMI_DS_TYPE_MAX))
    {
        return AT_ERROR;
    }

    lMemResult = memcpy_s(&stRcvPath, sizeof(stRcvPath), &(pstSmsCtx->stCpmsInfo.stRcvPath), sizeof(stRcvPath));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stRcvPath), sizeof(stRcvPath));
    if (ucCsmsVersion == AT_CSMS_MSG_VERSION_PHASE2_PLUS)
    {
        enRcvSmAct[2] = MN_MSG_RCVMSG_ACT_TRANSFER_ONLY;
        enRcvStaRptAct[1] = MN_MSG_RCVMSG_ACT_TRANSFER_ONLY;
    }

    stRcvPath.enRcvSmAct        = enRcvSmAct[CnmiMtType];
    stRcvPath.enRcvStaRptAct    = enRcvStaRptAct[CnmiDsType];
    stRcvPath.enSmsServVersion  = ucCsmsVersion;

    memset_s(stRcvPath.aucReserve1, sizeof(stRcvPath.aucReserve1), 0x00, sizeof(stRcvPath.aucReserve1));


    /* 将CNMI设置的MT type类型传输给TAF,在<MT>=3，收到CLASS3短信时候，按照CMT方式上报 */
    stRcvPath.enCnmiMtType      = CnmiMtType;

    if (MN_MSG_SetRcvMsgPath(gastAtClientTab[ucIndex].usClientId,
                             gastAtClientTab[ucIndex].opId,
                             &stRcvPath) != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    return AT_OK;
}

#if (FEATURE_RSTRIGGER_SMS == FEATURE_ON)

VOS_UINT32 AT_ReadActiveMessage(
    MODEM_ID_ENUM_UINT16                enModemId,
    MN_MSG_ACTIVE_MESSAGE_STRU         *pstActiveMessage
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulRet;
    VOS_UINT8                          *pucActiveMessageInfo = VOS_NULL_PTR;
    VOS_UINT8                          *pucEvaluate = VOS_NULL_PTR;

    pucActiveMessageInfo = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT,
                                                     MN_MSG_ACTIVE_MESSAGE_PARA_LEN);
    if (pucActiveMessageInfo == VOS_NULL_PTR)
    {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to alloc memory . ");
        return MN_ERR_NOMEM;
    }

    ulRet = TAF_ACORE_NV_READ(enModemId,
                      en_NV_Item_SMS_ActiveMessage_Para,
                      pucActiveMessageInfo,
                      MN_MSG_ACTIVE_MESSAGE_PARA_LEN);
    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to read NVIM . ");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pucActiveMessageInfo);/*lint !e830*/
        /*lint -restore */
        return MN_ERR_CLASS_SMS_NVIM;
    }

    pucEvaluate                         = pucActiveMessageInfo;

    pstActiveMessage->enActiveStatus    = *pucEvaluate;
    pucEvaluate++;

    pstActiveMessage->enMsgCoding       = *pucEvaluate;
    pucEvaluate++;

    pstActiveMessage->stUrl.ulLen       = *pucEvaluate;
    pucEvaluate++;
    pstActiveMessage->stUrl.ulLen      |= (VOS_UINT32)(*pucEvaluate) << 8;
    pucEvaluate++;
    pstActiveMessage->stUrl.ulLen      |= (VOS_UINT32)(*pucEvaluate) << 16;
    pucEvaluate++;
    pstActiveMessage->stUrl.ulLen      |= (VOS_UINT32)(*pucEvaluate) << 24;
    pucEvaluate++;

    if (pstActiveMessage->stUrl.ulLen > MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN)
    {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to read NVIM . ");
        pstActiveMessage->stUrl.ulLen = MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN;
    }

    lMemResult = memcpy_s(pstActiveMessage->stUrl.aucUrl,
                          sizeof(pstActiveMessage->stUrl.aucUrl),
                          pucEvaluate,
                          (VOS_UINT16)pstActiveMessage->stUrl.ulLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstActiveMessage->stUrl.aucUrl), (VOS_UINT16)pstActiveMessage->stUrl.ulLen);

    PS_MEM_FREE(WUEPS_PID_AT, pucActiveMessageInfo);
    return MN_ERR_NO_ERROR;
}
#endif


VOS_UINT32 At_ProcAppReqUssdStr_Nontrans(
    TAF_SS_USSD_STRING_STRU            *pstUssdStr,
    TAF_SS_DATA_CODING_SCHEME           DatacodingScheme
)
{
    TAF_UINT8                           aucUssdStr[TAF_SS_MAX_USSDSTRING_LEN * 2];
    MN_MSG_CBDCS_CODE_STRU              stDcsInfo;
    VOS_UINT32                          ulAsciiStrLen;
    VOS_UINT32                          ulRet;
    errno_t                             lMemResult;

    memset_s(aucUssdStr, sizeof(aucUssdStr), 0, sizeof(aucUssdStr));
    memset_s(&stDcsInfo, sizeof(stDcsInfo), 0, sizeof(stDcsInfo));

    /* USSD与CBS的DCS的协议相同，调用CBS的DCS解析函数解码，详细情况参考23038 */
    ulRet = MN_MSG_DecodeCbsDcs(DatacodingScheme,
                                pstUssdStr->aucUssdStr,
                                pstUssdStr->usCnt,
                                &stDcsInfo);

    if (ulRet != MN_ERR_NO_ERROR)
    {
        AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans:WARNING: Decode Failure");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (stDcsInfo.enMsgCoding == MN_MSG_MSG_CODING_UCS2)
    {
        /* 先进行DCS:UCS2的处理 */
        ulRet = At_UnicodePrint2Unicode(pstUssdStr->aucUssdStr, &(pstUssdStr->usCnt));

        if (ulRet != AT_SUCCESS)
        {
            AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans: convert Unicode fail");
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        /* 7Bit8Bit在非透传模式下先做CSCS的处理 */
        if (gucAtCscsType == AT_CSCS_UCS2_CODE)
        {
            ulRet = At_UnicodePrintToAscii(pstUssdStr->aucUssdStr, &(pstUssdStr->usCnt));

            if (ulRet != AT_SUCCESS)
            {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : CSCS Proc failed");
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        /* 再将7Bit做压缩编码处理 */
        if (stDcsInfo.enMsgCoding == MN_MSG_MSG_CODING_7_BIT)
        {
            ulAsciiStrLen = 0;
            ulRet         = TAF_STD_ConvertAsciiToDefAlpha(pstUssdStr->aucUssdStr,
                                                           pstUssdStr->usCnt,
                                                           aucUssdStr,
                                                           &ulAsciiStrLen,
                                                           TAF_SS_MAX_USSDSTRING_LEN * 2);

            pstUssdStr->usCnt = (VOS_UINT16)ulAsciiStrLen;

            if (ulRet != MN_ERR_NO_ERROR)
            {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : Conv7Bit Def Err");
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 清除原码流残余信息 */
            lMemResult = memset_s(pstUssdStr->aucUssdStr,
                                  TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8),
                                  0,
                                  TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8));
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8),
                                TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8));

            ulRet = TAF_STD_Pack7Bit(aucUssdStr,
                                     pstUssdStr->usCnt, 0,
                                     pstUssdStr->aucUssdStr,
                                     (VOS_UINT32*)&(pstUssdStr->usCnt));

            if (ulRet != MN_ERR_NO_ERROR)
            {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : Conv7Bit pack Err");
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_CheckCgtftParaNum(
    VOS_UINT8                           ucParaIndex
)
{
    if (AT_IsSupportReleaseRst(AT_ACCESS_STRATUM_REL11))
    {
        if ( ucParaIndex > AT_SET_CGTFT_PARA_MAX_NUMBER )
        {
            return AT_FAILURE;
        }
    }
    else
    {
        if ( ucParaIndex > AT_SET_CGTFT_PARA_MAX_NUMBER - 1 )
        {
            return AT_FAILURE;
        }
    }

    return AT_SUCCESS;
}


VOS_VOID AT_SetTftPfIdPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if ( gastAtParaList[1].usParaLen != 0 )
    {
        pstTftInfo->bitOpPktFilterId  = 1;
        pstTftInfo->ucPacketFilterId  = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }

    return;
}


VOS_VOID AT_SetTftPrecedencePara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if ( gastAtParaList[2].usParaLen != 0 )
    {
        pstTftInfo->bitOpPrecedence  = 1;
        pstTftInfo->ucPrecedence     = (VOS_UINT8)gastAtParaList[2].ulParaValue;
    }

    return;
}


VOS_VOID AT_SetTftProtocolIdPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if ( gastAtParaList[4].usParaLen != 0 )
    {
        pstTftInfo->bitOpProtocolId  = 1;
        pstTftInfo->ucProtocolId     = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    }

    return;
}


VOS_VOID AT_SetTftDirectionPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if ( gastAtParaList[10].usParaLen != 0 )
    {
        pstTftInfo->bitOpDirection  = 1;
        pstTftInfo->ucDirection     = (VOS_UINT8)gastAtParaList[10].ulParaValue;
    }

    return;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_VOID AT_SetTftQriPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if ( gastAtParaList[12].usParaLen != 0 )
    {
        pstTftInfo->bitOpQri = 1;
        pstTftInfo->ucQri    = (VOS_UINT8)gastAtParaList[12].ulParaValue;
    }

    return;
}
#endif


VOS_VOID AT_SetTftFlowLablePara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if(gastAtParaList[9].usParaLen != 0)
    {
        pstTftInfo->bitOpFlowLable = 1;
        pstTftInfo->ulFlowLable    = gastAtParaList[9].ulParaValue;
    }

    return;
}


TAF_UINT32 AT_SetTftSecuPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    if(gastAtParaList[7].usParaLen != 0)
    {
        pstTftInfo->bitOpSpi = 1;
        /* 需要增加判断大小 */
        if(gastAtParaList[7].usParaLen > 8) /*大于FFFFFFFF */
        {
            return AT_FAILURE;
        }

        if(At_String2Hex(gastAtParaList[7].aucPara,gastAtParaList[7].usParaLen,&gastAtParaList[7].ulParaValue) == AT_FAILURE)
        {
            return AT_FAILURE;
        }
        pstTftInfo->ulSecuParaIndex = gastAtParaList[7].ulParaValue;
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetTftTosPara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulLow      = 0;
    VOS_UINT32                          ulHigh     = 0;
    VOS_UINT32                          ulCount    = 0;

    if(gastAtParaList[8].usParaLen != 0)
    {
        ulCount = AT_CountDigit(gastAtParaList[8].aucPara,gastAtParaList[8].usParaLen,'.',1);
        if((ulCount == 0) || (gastAtParaList[8].aucPara[ulCount] == 0))
        {
            return AT_FAILURE;
        }

        pstTftInfo->bitOpTosMask = 1;

        if(atAuc2ul(gastAtParaList[8].aucPara,(VOS_UINT16)(ulCount-1),&ulLow) == AT_FAILURE)
        {
            return AT_FAILURE;
        }
        if(atAuc2ul(&gastAtParaList[8].aucPara[ulCount],(VOS_UINT16)(gastAtParaList[8].usParaLen - ulCount),&ulHigh) == AT_FAILURE)
        {
            return AT_FAILURE;
        }

        if((ulLow > 255) || (ulHigh > 255))
        {
            return AT_FAILURE;
        }
        else
        {
            pstTftInfo->ucTypeOfServiceMask = (VOS_UINT8)ulHigh;
            pstTftInfo->ucTypeOfService     = (VOS_UINT8)ulLow;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetDestPortRangePara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulLow      = 0;
    VOS_UINT32                          ulHigh     = 0;
    VOS_UINT32                          ulCount    = 0;

    if(gastAtParaList[5].usParaLen != 0)
    {
        ulCount = AT_CountDigit(gastAtParaList[5].aucPara,gastAtParaList[5].usParaLen,'.',1);
        if((ulCount == 0) || (gastAtParaList[5].aucPara[ulCount] == 0))
        {
            return AT_FAILURE;
        }

        pstTftInfo->bitOpDestPortRange= 1;

        if(atAuc2ul(gastAtParaList[5].aucPara,(VOS_UINT16)(ulCount-1),&ulLow) == AT_FAILURE)
        {
            return AT_FAILURE;
        }
        if(atAuc2ul(&gastAtParaList[5].aucPara[ulCount],(VOS_UINT16)(gastAtParaList[5].usParaLen - ulCount),&ulHigh) == AT_FAILURE)
        {
            return AT_FAILURE;
        }

        if((ulLow > 65535) || (ulHigh > 65535) || (ulLow > ulHigh))
        {
            return AT_FAILURE;
        }
        else
        {
            pstTftInfo->usHighDestPort = (VOS_UINT16)ulHigh;
            pstTftInfo->usLowDestPort = (VOS_UINT16)ulLow;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetSrcPortRangePara(
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulLow      = 0;
    VOS_UINT32                          ulHigh     = 0;
    VOS_UINT32                          ulCount    = 0;

    if(gastAtParaList[6].usParaLen != 0)
    {
        ulCount = AT_CountDigit(gastAtParaList[6].aucPara,gastAtParaList[6].usParaLen,'.',1);
        if((ulCount == 0) || (gastAtParaList[6].aucPara[ulCount] == 0))
        {
            return AT_FAILURE;
        }

        pstTftInfo->bitOpSrcPortRange = 1;

        if(atAuc2ul(gastAtParaList[6].aucPara,(VOS_UINT16)(ulCount-1),&ulLow) == AT_FAILURE)
        {
            return AT_FAILURE;
        }
        if(atAuc2ul(&gastAtParaList[6].aucPara[ulCount],(VOS_UINT16)(gastAtParaList[6].usParaLen - ulCount),&ulHigh) == AT_FAILURE)
        {
            return AT_FAILURE;
        }
        if((ulLow > 65535) || (ulHigh > 65535) || (ulLow > ulHigh))
        {
            return AT_FAILURE;
        }
        else
        {
            pstTftInfo->usHighSourcePort    = (VOS_UINT16)ulHigh;
            pstTftInfo->usLowSourcePort     = (VOS_UINT16)ulLow;
        }
    }

    return AT_SUCCESS;
}



VOS_UINT32 At_ConvUssdStrInCmd(
    TAF_SS_USSD_STRING_STRU            *pstUssdStr,
    TAF_SS_DATA_CODING_SCHEME           DatacodingScheme,
    VOS_UINT8                           ucIndex
)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    VOS_UINT32                          ulRet;
    errno_t                             lMemResult;

    lMemResult = memcpy_s(pstUssdStr->aucUssdStr, sizeof(pstUssdStr->aucUssdStr), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstUssdStr->aucUssdStr), gastAtParaList[1].usParaLen);
    pstUssdStr->usCnt = gastAtParaList[1].usParaLen;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    if (pstSsCtx->usUssdTransMode == AT_USSD_NON_TRAN_MODE)
    {
        /* 非透传模式处理下发请求 */
        ulRet = At_ProcAppReqUssdStr_Nontrans(pstUssdStr, DatacodingScheme);
    }
    else
    {
        /* 透传模式 */
        ulRet = At_AsciiNum2HexString(pstUssdStr->aucUssdStr, &(pstUssdStr->usCnt));
    }

    if (ulRet != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}

#if (FEATURE_RSTRIGGER_SMS == FEATURE_ON)

TAF_UINT32 AT_SetRstriggerPara(
    TAF_UINT8                           ucIndex
)
{
    MN_MSG_ACTIVE_MESSAGE_STRU          stActiveMessage;
    MN_MSG_ACTIVE_MESSAGE_STRU          stOrgActiveMessage;
    TAF_UINT32                          ulRet;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRslt;
    errno_t                             lMemResult;

    enModemId = MODEM_ID_0;

    /* 参数检查 ：
       个数为0返回AT_CME_INCORRECT_PARAMETERS
       个数为2返回AT_TOO_MANY_PARA
    */
    if (gucAtParaIndex > 2)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRslt = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRslt != VOS_OK)
    {
        AT_ERR_LOG("AT_SetRstriggerPara: Get modem id fail.");
        return AT_ERROR;
    }

    ulRet = AT_ReadActiveMessage(enModemId, &stOrgActiveMessage);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        AT_LOG1("AT_SetRstriggerPara: fail to get active message information , cause is %d",
                ulRet);
        return AT_ERROR;
    }

    /*URL:用户没有设置URL,则保持NVIM中的URL不变;否则，用户设置的URL覆盖NVIM的数据*/
    if (gucAtParaIndex == 2)
    {
        if (gastAtParaList[1].usParaLen > MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN)
        {
            stActiveMessage.stUrl.ulLen = MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN;
        }
        else
        {
            stActiveMessage.stUrl.ulLen = gastAtParaList[1].usParaLen;
        }
        lMemResult = memcpy_s(stActiveMessage.stUrl.aucUrl,
                              sizeof(stActiveMessage.stUrl.aucUrl),
                              gastAtParaList[1].aucPara,
                              (VOS_UINT16)stActiveMessage.stUrl.ulLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stActiveMessage.stUrl.aucUrl), (VOS_UINT16)stActiveMessage.stUrl.ulLen);

        stActiveMessage.enMsgCoding    = MN_MSG_MSG_CODING_8_BIT;
    }
    else
    {
        lMemResult = memcpy_s(&stActiveMessage.stUrl, sizeof(stActiveMessage.stUrl), &stOrgActiveMessage.stUrl, sizeof(stActiveMessage.stUrl));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stActiveMessage.stUrl), sizeof(stActiveMessage.stUrl));
        stActiveMessage.enMsgCoding    = stOrgActiveMessage.enMsgCoding;
    }

    /*ACTIVE STATUS:*/
    stActiveMessage.enActiveStatus = (MN_MSG_ACTIVE_MESSAGE_STATUS_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    /*调用AT_WriteActiveMessage写激活短信的激活状态和URL信息到NVIM；*/
    ulRet = AT_WriteActiveMessage(enModemId, &stOrgActiveMessage, &stActiveMessage);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    return AT_OK;

}
#endif


TAF_UINT32 At_SetCsmsPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查: 此处相对于旧代码有修改，待确认 */
    if ((gucAtParaIndex != 1)
     || (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gastAtClientTab[ucIndex].opId = At_GetOpId();
    ulRet = At_UpdateMsgRcvAct(ucIndex,
                                (AT_CSMS_MSG_VERSION_ENUM_U8)gastAtParaList[0].ulParaValue,
                                pstSmsCtx->stCnmiType.CnmiMtType,
                                pstSmsCtx->stCnmiType.CnmiDsType);

    if (ulRet != AT_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSMS_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */

}

TAF_UINT32 At_SetCgsmsPara(TAF_UINT8 ucIndex)
{

    MN_MSG_SET_SMS_SEND_DOMAIN_STRU     stSendDomain;
    TAF_UINT32                          ulRet;
    MN_OPERATION_ID_T                   opId;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        gastAtParaList[0].ulParaValue = MN_MSG_SEND_DOMAIN_CS;
    }

    opId = At_GetOpId();
    memset_s(&stSendDomain, sizeof(MN_MSG_SET_SMS_SEND_DOMAIN_STRU), 0x00, sizeof(MN_MSG_SET_SMS_SEND_DOMAIN_STRU));
    stSendDomain.enSmsSendDomain = (MN_MSG_SEND_DOMAIN_ENUM_U8)gastAtParaList[0].ulParaValue;

    ulRet = MN_MSG_SetSmsSendDomain(gastAtClientTab[ucIndex].usClientId, opId, &stSendDomain);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].opId          = opId;
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGSMS_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_GetSmsStorage(
    VOS_UINT8                           ucIndex,
    MN_MSG_MEM_STORE_ENUM_U8            enMemReadorDelete,
    MN_MSG_MEM_STORE_ENUM_U8            enMemSendorWrite,
    MN_MSG_MEM_STORE_ENUM_U8            enMemRcv
)
{
    MN_MSG_GET_STORAGE_STATUS_PARM_STRU stMemParm;

    memset_s(&stMemParm, sizeof(MN_MSG_GET_STORAGE_STATUS_PARM_STRU), 0x00, sizeof(MN_MSG_GET_STORAGE_STATUS_PARM_STRU));

    if ((enMemReadorDelete == MN_MSG_MEM_STORE_SIM)
     || (enMemSendorWrite == MN_MSG_MEM_STORE_SIM)
     || (enMemRcv == MN_MSG_MEM_STORE_SIM))
    {
        stMemParm.enMem1Store = MN_MSG_MEM_STORE_SIM;
        gastAtClientTab[ucIndex].AtSmsData.bWaitForUsimStorageStatus = VOS_TRUE;
    }
    else
    {
        stMemParm.enMem1Store = MN_MSG_MEM_STORE_NONE;
        gastAtClientTab[ucIndex].AtSmsData.bWaitForUsimStorageStatus = VOS_FALSE;
    }
#if (NAS_FEATURE_SMS_FLASH_SMSEXIST == FEATURE_ON)
    if ((enMemReadorDelete == MN_MSG_MEM_STORE_ME)
     || (enMemSendorWrite == MN_MSG_MEM_STORE_ME)
     || (enMemRcv == MN_MSG_MEM_STORE_ME))
    {
        stMemParm.enMem2Store = MN_MSG_MEM_STORE_ME;
        gastAtClientTab[ucIndex].AtSmsData.bWaitForNvStorageStatus = VOS_TRUE;
    }
    else
    {
        stMemParm.enMem2Store = MN_MSG_MEM_STORE_NONE;
        gastAtClientTab[ucIndex].AtSmsData.bWaitForNvStorageStatus = VOS_FALSE;
    }
#else
    stMemParm.enMem2Store = MN_MSG_MEM_STORE_NONE;
    gastAtClientTab[ucIndex].AtSmsData.bWaitForNvStorageStatus = VOS_FALSE;
#endif

    if (MN_MSG_GetStorageStatus(gastAtClientTab[ucIndex].usClientId,
                                gastAtClientTab[ucIndex].opId,
                                &stMemParm) != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetCpmsPara(TAF_UINT8 ucIndex)
{
    MN_MSG_SET_RCVMSG_PATH_PARM_STRU    stRcvPath;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;
    errno_t                             lMemResult;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(&stRcvPath, sizeof(stRcvPath), 0x00, sizeof(MN_MSG_SET_RCVMSG_PATH_PARM_STRU));
    /* 参数检查 */
    if ((gucAtParaIndex > 3)
     || (gucAtParaIndex == 0)
     || (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    pstSmsCtx->stCpmsInfo.enTmpMemReadorDelete = (MN_MSG_MEM_STORE_ENUM_U8)(gastAtParaList[0].ulParaValue + 1);

    if (gastAtParaList[1].usParaLen != 0)
    {
        pstSmsCtx->stCpmsInfo.enTmpMemSendorWrite = (MN_MSG_MEM_STORE_ENUM_U8)(gastAtParaList[1].ulParaValue + 1);
    }
    else
    {
        pstSmsCtx->stCpmsInfo.enTmpMemSendorWrite = pstSmsCtx->stCpmsInfo.enMemSendorWrite;
    }

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    lMemResult = memcpy_s(&stRcvPath, sizeof(stRcvPath), &(pstSmsCtx->stCpmsInfo.stRcvPath), sizeof(stRcvPath));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stRcvPath), sizeof(stRcvPath));


    /* 将CNMI设置的MT type类型传输给TAF,在<MT>=3，收到CLASS3短信时候，按照CMT方式上报 */
    stRcvPath.enCnmiMtType = pstSmsCtx->stCnmiType.CnmiMtType;

    if (gastAtParaList[2].usParaLen != 0)
    {
        stRcvPath.enStaRptMemStore = (MN_MSG_MEM_STORE_ENUM_U8)(gastAtParaList[2].ulParaValue + 1);
        stRcvPath.enSmMemStore = (MN_MSG_MEM_STORE_ENUM_U8)(gastAtParaList[2].ulParaValue + 1);
    }

    if ((pstSmsCtx->stCpmsInfo.enTmpMemReadorDelete == MN_MSG_MEM_STORE_ME)
     || (pstSmsCtx->stCpmsInfo.enTmpMemSendorWrite == MN_MSG_MEM_STORE_ME)
     || (stRcvPath.enSmMemStore == MN_MSG_MEM_STORE_ME))
    {
#if (NAS_FEATURE_SMS_FLASH_SMSEXIST != FEATURE_ON)
        return AT_ERROR;
#else
        if (pstSmsCtx->enMsgMeStorageStatus != MN_MSG_ME_STORAGE_ENABLE)
        {
            return AT_ERROR;
        }
#endif
    }

    if (MN_MSG_SetRcvMsgPath(gastAtClientTab[ucIndex].usClientId,
                             gastAtClientTab[ucIndex].opId,
                             &stRcvPath) != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].AtSmsData.bWaitForCpmsSetRsp = TAF_TRUE;

    if (At_GetSmsStorage(ucIndex,
                         pstSmsCtx->stCpmsInfo.enTmpMemReadorDelete,
                         pstSmsCtx->stCpmsInfo.enTmpMemSendorWrite,
                         stRcvPath.enSmMemStore) != AT_OK)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPMS_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */

}


TAF_UINT32 At_SetCmgfPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if (((g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD) &&
         (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)) ||
         (gucAtParaIndex > 1))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        gastAtParaList[0].ulParaValue = AT_CMGF_MSG_FORMAT_PDU;
    }

    pstSmsCtx->enCmgfMsgFormat = (AT_CMGF_MSG_FORMAT_ENUM_U8)gastAtParaList[0].ulParaValue;
    return AT_OK;
}


TAF_UINT32 At_SetCscaPara(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    TAF_UINT8                           aucAsciiNum[MN_MAX_ASCII_ADDRESS_NUM + 2];   /*array  of ASCII Num*/
    TAF_UINT8                           ucScaType;
    TAF_UINT32                          ulRet;
    MN_MSG_WRITE_SRV_PARAM_STRU         stServParm;
    TAF_UINT8                          *pucNum = VOS_NULL_PTR;                                /*指向实际号码（不包括+号）的指针*/
    MN_MSG_SRV_PARAM_STRU               stParmInUsim;
    MN_OPERATION_ID_T                   opId                = At_GetOpId();
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(&stServParm,   sizeof(stServParm), 0x00, sizeof(MN_MSG_WRITE_SRV_PARAM_STRU));
    memset_s(&stParmInUsim, sizeof(stParmInUsim), 0x00, sizeof(MN_MSG_SRV_PARAM_STRU));

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gucAtParaIndex > 2))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 如果<sca>号码过长，直接返回错误 */
    if (At_CheckNumLen((MN_MAX_ASCII_ADDRESS_NUM + 1), gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    /* 初始化 */
    memset_s(aucAsciiNum, sizeof(aucAsciiNum), 0x00, sizeof(aucAsciiNum));
    /* 设置<sca> , 将UCS2码转换成ASCII码*/
    ulRet = At_SetNumTypePara(aucAsciiNum, sizeof(aucAsciiNum), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    if (ulRet != AT_SUCCESS)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    ucScaType = (TAF_UINT8)At_GetCodeType(aucAsciiNum[0]);
    if (ucScaType == AT_MSG_INTERNAL_ISDN_ADDR_TYPE)
    {
        pucNum = &aucAsciiNum[1];
    }
    else
    {
        pucNum = aucAsciiNum;
    }

    /* 设置<tosca> */
    if (gastAtParaList[1].usParaLen != 0)
    {
        if (ucScaType == AT_MSG_INTERNAL_ISDN_ADDR_TYPE)
        {
            if (ucScaType != ((TAF_UINT8)gastAtParaList[1].ulParaValue))
            {
                return AT_CMS_OPERATION_NOT_ALLOWED;
            }
        }
        else
        {
            ucScaType = (TAF_UINT8)gastAtParaList[1].ulParaValue;
        }
    }

    /* 执行命令操作 */
    lMemResult = memcpy_s(&stParmInUsim, sizeof(stParmInUsim), &(pstSmsCtx->stCscaCsmpInfo.stParmInUsim), sizeof(stParmInUsim));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stParmInUsim), sizeof(stParmInUsim));

    stParmInUsim.ucParmInd &= ~MN_MSG_SRV_PARM_MASK_SC_ADDR;
    stParmInUsim.stScAddr.addrType = ucScaType;
    ulRet = AT_AsciiNumberToBcd((TAF_CHAR *)pucNum,
                                stParmInUsim.stScAddr.aucBcdNum,
                                &stParmInUsim.stScAddr.ucBcdLen);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }
    stServParm.enMemStore = MN_MSG_MEM_STORE_SIM;
    stServParm.enWriteMode = MN_MSG_WRITE_MODE_REPLACE;

    stServParm.ulIndex = (VOS_UINT32)pstSmsCtx->stCscaCsmpInfo.ucDefaultSmspIndex;

    lMemResult = memcpy_s(&stServParm.stSrvParm, sizeof(stServParm.stSrvParm), &stParmInUsim, sizeof(stServParm.stSrvParm));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stServParm.stSrvParm), sizeof(stServParm.stSrvParm));
    gastAtClientTab[ucIndex].opId = opId;
    if (MN_MSG_WriteSrvParam(gastAtClientTab[ucIndex].usClientId, opId, &stServParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSCA_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCsmpPara(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    MN_MSG_WRITE_SRV_PARAM_STRU         stServParm;
    MN_MSG_SRV_PARAM_STRU               stParmInUsim;
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(&stServParm,   sizeof(stServParm), 0x00, sizeof(MN_MSG_WRITE_SRV_PARAM_STRU));
    memset_s(&stParmInUsim, sizeof(stParmInUsim), 0x00, sizeof(MN_MSG_SRV_PARAM_STRU));

    /* 参数检查 */
    if ((g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
     || (gucAtParaIndex > 4))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<fo> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        ulRet = At_ParseCsmpFo(&(pstSmsCtx->stCscaCsmpInfo.ucTmpFo));
        if (ulRet != AT_SUCCESS)
        {
            return ulRet;
        }
    }
    else
    {
        pstSmsCtx->stCscaCsmpInfo.ucTmpFo = pstSmsCtx->stCscaCsmpInfo.ucFo;
    }

    lMemResult = memcpy_s(&stParmInUsim, sizeof(stParmInUsim), &(pstSmsCtx->stCscaCsmpInfo.stParmInUsim), sizeof(stParmInUsim));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stParmInUsim), sizeof(stParmInUsim));

    /* 设置<vp> */
    ulRet =  At_ParseCsmpVp(ucIndex, &(pstSmsCtx->stCscaCsmpInfo.stTmpVp));
    if (ulRet != AT_SUCCESS)
    {
        return ulRet;
    }

    /* 设置<pid> */
    if(gastAtParaList[2].usParaLen != 0)
    {
        /* 注意: gastAtParaList[2].ulParaValue此时尚未未转换，检查其它命令的这种情况 */
        if(At_Auc2ul(gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen,&gastAtParaList[2].ulParaValue) == AT_FAILURE)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if(gastAtParaList[2].ulParaValue <= 255)
        {
            stParmInUsim.ucParmInd &= ~MN_MSG_SRV_PARM_MASK_PID;
            stParmInUsim.ucPid = (TAF_UINT8)gastAtParaList[2].ulParaValue;
        }
        else
        {
            AT_NORM_LOG("At_SetCsmpPara: unsupport VP type.");
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 设置<dcs> */
    if(gastAtParaList[3].usParaLen != 0)
    {
        /* 注意: gastAtParaList[3].ulParaValue此时尚未未转换，检查其它命令的这种情况 */
        if(At_Auc2ul(gastAtParaList[3].aucPara,gastAtParaList[3].usParaLen,&gastAtParaList[3].ulParaValue) == AT_FAILURE)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if(gastAtParaList[3].ulParaValue <= 255)
        {
            stParmInUsim.ucParmInd &= ~MN_MSG_SRV_PARM_MASK_DCS;
            stParmInUsim.ucDcs = (TAF_UINT8)gastAtParaList[3].ulParaValue;
        }
        else
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    stServParm.enMemStore = MN_MSG_MEM_STORE_SIM;
    stServParm.enWriteMode = MN_MSG_WRITE_MODE_REPLACE;

    stServParm.ulIndex = (VOS_UINT32)pstSmsCtx->stCscaCsmpInfo.ucDefaultSmspIndex;

    lMemResult = memcpy_s(&stServParm.stSrvParm, sizeof(stServParm.stSrvParm), &stParmInUsim, sizeof(stServParm.stSrvParm));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stServParm.stSrvParm), sizeof(stServParm.stSrvParm));
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_WriteSrvParam(gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId, &stServParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSMP_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCsdhPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSmsCtx->ucCsdhType = (AT_CSDH_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSmsCtx->ucCsdhType = AT_CSDH_NOT_SHOW_TYPE;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCnmiPara(TAF_UINT8 ucIndex)
{
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查和缺省参数配置 */
    /* 不带参数的设置命令，清空所有参数值为默认值 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        pstSmsCtx->stCnmiType.CnmiTmpModeType = AT_CNMI_MODE_BUFFER_TYPE;
        pstSmsCtx->stCnmiType.CnmiTmpMtType   = AT_CNMI_MT_NO_SEND_TYPE;
        pstSmsCtx->stCnmiType.CnmiTmpBmType   = AT_CNMI_BM_NO_SEND_TYPE;
        pstSmsCtx->stCnmiType.CnmiTmpDsType   = AT_CNMI_DS_NO_SEND_TYPE;
        pstSmsCtx->stCnmiType.CnmiTmpBfrType  = AT_CNMI_BFR_SEND_TYPE;
    }

    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD)
    {
        /* 带参数的设置命令，参数个数不能为0且不能超过最大参数个数 */
        if ((gucAtParaIndex == 0)
         || (gucAtParaIndex > 5))
        {
            return AT_CMS_OPERATION_NOT_SUPPORTED;
        }

        /* 带参数的设置命令，用户未配置的参数不做修改 */
        pstSmsCtx->stCnmiType.CnmiTmpModeType = pstSmsCtx->stCnmiType.CnmiModeType;
        pstSmsCtx->stCnmiType.CnmiTmpMtType   = pstSmsCtx->stCnmiType.CnmiMtType;
        pstSmsCtx->stCnmiType.CnmiTmpBmType   = pstSmsCtx->stCnmiType.CnmiBmType;
        pstSmsCtx->stCnmiType.CnmiTmpDsType   = pstSmsCtx->stCnmiType.CnmiDsType;
        pstSmsCtx->stCnmiType.CnmiTmpBfrType  = pstSmsCtx->stCnmiType.CnmiBfrType;

        if (gastAtParaList[0].usParaLen != 0)
        {
            pstSmsCtx->stCnmiType.CnmiTmpModeType = (AT_CNMI_MODE_TYPE)gastAtParaList[0].ulParaValue;
        }

        if (gastAtParaList[1].usParaLen != 0)
        {
            pstSmsCtx->stCnmiType.CnmiTmpMtType = (AT_CNMI_MT_TYPE)gastAtParaList[1].ulParaValue;
        }

        if (gastAtParaList[2].usParaLen != 0)
        {
            pstSmsCtx->stCnmiType.CnmiTmpBmType = (AT_CNMI_BM_TYPE)gastAtParaList[2].ulParaValue;
            if ( ( pstSmsCtx->stCnmiType.CnmiTmpBmType != AT_CNMI_BM_CBM_TYPE )
               && (pstSmsCtx->stCnmiType.CnmiTmpBmType != AT_CNMI_BM_NO_SEND_TYPE ))
            {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }
        }

        if (gastAtParaList[3].usParaLen != 0)
        {
            pstSmsCtx->stCnmiType.CnmiTmpDsType = (AT_CNMI_DS_TYPE)gastAtParaList[3].ulParaValue;
        }

        if (gastAtParaList[4].usParaLen != 0)
        {
            pstSmsCtx->stCnmiType.CnmiTmpBfrType = (AT_CNMI_BFR_TYPE)gastAtParaList[4].ulParaValue;
        }

        if ((pstSmsCtx->stCnmiType.CnmiTmpModeType == AT_CNMI_MODE_BUFFER_TYPE)
         || (pstSmsCtx->stCnmiType.CnmiTmpModeType == AT_CNMI_MODE_SEND_OR_BUFFER_TYPE))
        {
            if ((pstSmsCtx->stCnmiType.CnmiTmpMtType == AT_CNMI_MT_CMT_TYPE)
             || (pstSmsCtx->stCnmiType.CnmiTmpMtType == AT_CNMI_MT_CLASS3_TYPE))
            {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }

            if (pstSmsCtx->stCnmiType.CnmiTmpDsType == AT_CNMI_DS_CDS_TYPE)
            {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }

        }
    }

    gastAtClientTab[ucIndex].opId = At_GetOpId();
    ulRet = At_UpdateMsgRcvAct(ucIndex,
                               pstSmsCtx->enCsmsMsgVersion,
                               pstSmsCtx->stCnmiType.CnmiTmpMtType,
                               pstSmsCtx->stCnmiType.CnmiTmpDsType);
    if (ulRet != AT_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CNMI_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}

TAF_UINT32 At_SetCmglPara(TAF_UINT8 ucIndex)
{
    MN_MSG_LIST_PARM_STRU               stListParm;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if ((g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* at命令只支持1个参数，增加检查 */
    if(gucAtParaIndex > 1)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&stListParm, sizeof(stListParm), 0x00, sizeof(stListParm));

    stListParm.ucIsFirstTimeReq = VOS_TRUE;

    /* 设置<stat> */
    if (gastAtParaList[0].usParaLen != 0)
    {
        stListParm.enStatus = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        stListParm.enStatus = (TAF_UINT8)MN_MSG_STATUS_MT_NOT_READ;
    }

    /* 设置读取存储器 */
    stListParm.enMemStore = pstSmsCtx->stCpmsInfo.enMemReadorDelete;

    if(pstSmsCtx->ucParaCmsr == 0)
    {
        stListParm.bChangeFlag = TAF_TRUE;
    }
    else
    {
        stListParm.bChangeFlag = TAF_FALSE;
        if(gucAtParaIndex > 1)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_List(gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId,&stListParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCmgrPara(TAF_UINT8 ucIndex)
{
    MN_MSG_READ_PARM_STRU               stReadParm;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&stReadParm, sizeof(stReadParm), 0x00, sizeof(stReadParm));

    /* 参数设置 */
    stReadParm.ulIndex = gastAtParaList[0].ulParaValue;

    /* 设置读取存储器 */
    stReadParm.enMemStore = pstSmsCtx->stCpmsInfo.enMemReadorDelete;

    if(pstSmsCtx->ucParaCmsr == 0)
    {
        stReadParm.bChangeFlag = TAF_TRUE;
    }
    else
    {
        stReadParm.bChangeFlag = TAF_FALSE;
        if(gucAtParaIndex > 1)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if(MN_MSG_Read(gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId, &stReadParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGR_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCnmaPara(TAF_UINT8 ucIndex)
{
    TAF_UINT32                          ulRet;
    TAF_BOOL                            bRpAck     = TAF_TRUE;
    MN_MSG_SEND_ACK_PARM_STRU          *pstAckParm = VOS_NULL_PTR;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    if (gucAtParaIndex > 2)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&gastAtClientTab[ucIndex].AtSmsData, sizeof(gastAtClientTab[ucIndex].AtSmsData), 0x00, sizeof(gastAtClientTab[ucIndex].AtSmsData));
    if (pstSmsCtx->enCmgfMsgFormat == AT_CMGF_MSG_FORMAT_TEXT)    /* TEXT方式 */
    {
        if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }
    else    /* PDU方式 */
    {
        if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
        {
            if(gastAtParaList[0].usParaLen == 0)
            {
                return AT_CMS_OPERATION_NOT_ALLOWED;
            }
            else
            {
                /* 设置<n> */
                gastAtClientTab[ucIndex].AtSmsData.ucCnmaType = (TAF_UINT8)gastAtParaList[0].ulParaValue;
            }

            /*只有参数<n>,决定是否发送RP-ACK或RP-ERROR*/
            if ((gastAtParaList[1].usParaLen != 0)
             && (gastAtParaList[1].ulParaValue != 0))
            {
                if (gastAtClientTab[ucIndex].AtSmsData.ucCnmaType == 0)
                {
                    return AT_ERROR;
                }

                /* 设置<length> */
                if (gastAtParaList[1].ulParaValue > AT_MSG_MAX_TPDU_LEN)
                {
                    AT_NORM_LOG("At_SetCnmaPara: the length of PDU is not support.");
                    return AT_CMS_OPERATION_NOT_ALLOWED;    /* 输入字串太长 */
                }

                gastAtClientTab[ucIndex].AtSmsData.ucPduLen = (TAF_UINT8)gastAtParaList[1].ulParaValue;
                At_SetMode(ucIndex,AT_CMD_MODE,AT_SMS_MODE);         /* 切换为短信模式 */
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CNMA_PDU_SET;
                return AT_WAIT_SMS_INPUT;   /* 返回提示短信内容输入状态 */
            }
            else
            {
                if (gastAtClientTab[ucIndex].AtSmsData.ucCnmaType == 2)
                {
                    bRpAck = TAF_FALSE;
                }
            }
        }
    }

    /*CMGF设置了文本格式, 或CNMA无参数，或CNMA参数中<length>为0*/
    pstAckParm = At_GetAckMsgMem();
    memset_s(pstAckParm, sizeof(MN_MSG_SEND_ACK_PARM_STRU), 0x00, sizeof(MN_MSG_SEND_ACK_PARM_STRU));

    if (bRpAck == TAF_TRUE)
    {
        pstAckParm->bRpAck = TAF_TRUE;
        pstAckParm->stTsRawData.enTpduType = MN_MSG_TPDU_DELIVER_RPT_ACK;
    }
    else
    {
        pstAckParm->bRpAck = TAF_FALSE;
        pstAckParm->enRpCause = MN_MSG_RP_CAUSE_PROTOCOL_ERR_UNSPECIFIED;
        pstAckParm->stTsRawData.enTpduType = MN_MSG_TPDU_DELIVER_RPT_ERR;
        pstAckParm->stTsRawData.ulLen = 2;
        pstAckParm->stTsRawData.aucData[0] = 0;
        pstAckParm->stTsRawData.aucData[1] = 0xff;
    }

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_SendAck(gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId, pstAckParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CNMA_TEXT_SET;
        ulRet = AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        ulRet = AT_ERROR;
    }

    return ulRet;
}


TAF_UINT32 At_SetCmgsPara(TAF_UINT8 ucIndex)
{
    TAF_UINT8                           ucSmSFormat;
    TAF_UINT32                          ulRet;

    ucSmSFormat = AT_GetModemSmsCtxAddrFromClientId(ucIndex)->enCmgfMsgFormat;

    /* 参数检查，如果<da>号码或者<length>不存在，直接返回错误 */
    if (gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&gastAtClientTab[ucIndex].AtSmsData, sizeof(gastAtClientTab[ucIndex].AtSmsData), 0x00, sizeof(gastAtClientTab[ucIndex].AtSmsData));

    if (ucSmSFormat == AT_CMGF_MSG_FORMAT_TEXT)    /* TEXT方式参数检查 */
    {
        if (gucAtParaIndex > 2)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 参数设置 */
        /* 设置<da> <toda>*/
        ulRet = At_GetAsciiOrBcdAddr(gastAtParaList[0].aucPara,
                                     gastAtParaList[0].usParaLen,
                                     (TAF_UINT8)gastAtParaList[1].ulParaValue,
                                     gastAtParaList[1].usParaLen,
                                     &gastAtClientTab[ucIndex].AtSmsData.stAsciiAddr,
                                     TAF_NULL_PTR);
        if ((ulRet != AT_OK)
         || (gastAtClientTab[ucIndex].AtSmsData.stAsciiAddr.ulLen == 0))
        {
            AT_NORM_LOG("At_SetCmgsPara: no da.");
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }


    }
    else    /* PDU方式参数检查 */
    {
        if (gucAtParaIndex > 1)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gastAtParaList[0].ulParaValue > AT_MSG_MAX_TPDU_LEN)
        {
            AT_NORM_LOG("At_SetCmgsPara: invalid tpdu data length.");
            return AT_ERROR;
        }

        /* 设置<length> */
        gastAtClientTab[ucIndex].AtSmsData.ucPduLen = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }

    At_SetMode(ucIndex,AT_CMD_MODE,AT_SMS_MODE);         /* 切换为短信模式 */
    /* 设置当前操作类型 */
    if (ucSmSFormat == AT_CMGF_MSG_FORMAT_TEXT)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGS_TEXT_SET;
    }
    else
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGS_PDU_SET;
    }
    return AT_WAIT_SMS_INPUT;   /* 返回提示短信内容输入状态 */
}


TAF_UINT32 At_SetCmssPara(TAF_UINT8 ucIndex)
{
    MN_MSG_SEND_FROMMEM_PARM_STRU       stSendFromMemParm;
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查，如果<index>不存在，直接返回错误 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gucAtParaIndex > 3))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<da> */
    ulRet = At_GetAsciiOrBcdAddr(gastAtParaList[1].aucPara,
                                 gastAtParaList[1].usParaLen,
                                 (TAF_UINT8)gastAtParaList[2].ulParaValue,
                                 gastAtParaList[2].usParaLen,
                                 VOS_NULL_PTR,
                                 &stSendFromMemParm.stDestAddr);
    if (ulRet != AT_OK)
    {
        return AT_ERROR;
    }

    /* 设置发送存储器 */
    stSendFromMemParm.enMemStore = pstSmsCtx->stCpmsInfo.enMemSendorWrite;
    stSendFromMemParm.ulIndex = gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_SendFromMem(gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId, &stSendFromMemParm) == MN_ERR_NO_ERROR)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMSS_SET;
        gastAtClientTab[ucIndex].AtSmsData.ucMsgSentSmNum = 1;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCmgwPara(TAF_UINT8 ucIndex)
{
    TAF_UINT8                           ucSmSFormat;
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    ucSmSFormat = pstSmsCtx->enCmgfMsgFormat;

    /* 初始化 */
    memset_s(&gastAtClientTab[ucIndex].AtSmsData, sizeof(gastAtClientTab[ucIndex].AtSmsData), 0x00, sizeof(gastAtClientTab[ucIndex].AtSmsData));
    if (ucSmSFormat == AT_CMGF_MSG_FORMAT_TEXT)    /* TEXT方式参数检查 */
    {
        /* 参数检查 */
        if ((g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD)
         && (gastAtParaList[0].usParaLen == 0))
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gucAtParaIndex > 3)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置<oa/da> */
        ulRet = At_GetAsciiOrBcdAddr(gastAtParaList[0].aucPara,
                                     gastAtParaList[0].usParaLen,
                                     (TAF_UINT8)gastAtParaList[1].ulParaValue,
                                     gastAtParaList[1].usParaLen,
                                     &gastAtClientTab[ucIndex].AtSmsData.stAsciiAddr,
                                     TAF_NULL_PTR);
        if (ulRet != AT_OK)
        {
            return ulRet;
        }

        /* 设置<stat> */
        if (gastAtParaList[2].usParaLen != 0)
        {
            gastAtClientTab[ucIndex].AtSmsData.SmState = (TAF_UINT8)gastAtParaList[2].ulParaValue;
        }
        else
        {
            gastAtClientTab[ucIndex].AtSmsData.SmState = MN_MSG_STATUS_MO_NOT_SENT;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGW_TEXT_SET;
    }
    else    /* PDU方式参数检查 */
    {
        /* 参数检查 */
        if (gastAtParaList[0].usParaLen == 0)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gucAtParaIndex > 2)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gastAtParaList[0].ulParaValue > AT_MSG_MAX_TPDU_LEN)
        {
            AT_NORM_LOG("At_SendPduMsgOrCmd: invalid tpdu data length.");
            return AT_ERROR;
        }
        gastAtClientTab[ucIndex].AtSmsData.ucPduLen = (TAF_UINT8)gastAtParaList[0].ulParaValue;

        /* 设置<stat> */
        if (gastAtParaList[1].usParaLen != 0)
        {
            gastAtClientTab[ucIndex].AtSmsData.SmState = (TAF_UINT8)gastAtParaList[1].ulParaValue;
        }
        else
        {
            gastAtClientTab[ucIndex].AtSmsData.SmState = MN_MSG_STATUS_MO_NOT_SENT;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGW_PDU_SET;
    }

    if ((gastAtClientTab[ucIndex].AtSmsData.SmState != MN_MSG_STATUS_MT_NOT_READ)
     && (gastAtClientTab[ucIndex].AtSmsData.SmState != MN_MSG_STATUS_MT_READ)
     && (gastAtClientTab[ucIndex].AtSmsData.SmState != MN_MSG_STATUS_MO_NOT_SENT)
     && (gastAtClientTab[ucIndex].AtSmsData.SmState != MN_MSG_STATUS_MO_SENT))
    {
        AT_NORM_LOG("At_SetCmgwPara: invalid sm status.");
        return AT_ERROR;
    }

    At_SetMode(ucIndex,AT_CMD_MODE,AT_SMS_MODE);         /* 切换为短信模式 */

    return AT_WAIT_SMS_INPUT;   /* 返回提示短信内容输入状态 */
}



TAF_UINT32 At_SetCmgdPara(TAF_UINT8 ucIndex)
{
    MN_MSG_DELETE_PARAM_STRU            stDelete;
    MN_OPERATION_ID_T                   opId                = At_GetOpId();
    TAF_UINT32                          ulDeleteTypeIndex   = 0;
    TAF_UINT32                          ulDeleteTypes[5]    = {AT_MSG_DELETE_SINGLE,
                                                               AT_MSG_DELETE_READ,
                                                               (AT_MSG_DELETE_READ + AT_MSG_DELETE_SENT),
                                                               (AT_MSG_DELETE_READ + AT_MSG_DELETE_SENT + AT_MSG_DELETE_UNSENT),
                                                               AT_MSG_DELETE_ALL};
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);


    memset_s(&stDelete, sizeof(stDelete), 0x00, sizeof(stDelete));


    /* 参数检查 */
    if (gucAtParaIndex > 2)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<index> */
    stDelete.ulIndex = gastAtParaList[0].ulParaValue;

    /* 设置删除存储器 */
    stDelete.enMemStore = pstSmsCtx->stCpmsInfo.enMemReadorDelete;

    /* 设置<delflag> */
    if (gastAtParaList[1].usParaLen != 0)
    {
        ulDeleteTypeIndex = gastAtParaList[1].ulParaValue;
    }
    else
    {
        ulDeleteTypeIndex = 0;
    }

    gastAtClientTab[ucIndex].AtSmsData.ucMsgDeleteTypes = (TAF_UINT8)ulDeleteTypes[ulDeleteTypeIndex];
    if (gastAtClientTab[ucIndex].AtSmsData.ucMsgDeleteTypes == AT_MSG_DELETE_SINGLE)
    {
        if(gastAtParaList[0].usParaLen == 0)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    ulRet = At_MsgDeleteCmdProc(ucIndex, opId, stDelete, gastAtClientTab[ucIndex].AtSmsData.ucMsgDeleteTypes);
    if (ulRet != AT_OK)
    {
        return ulRet;
    }

    gastAtClientTab[ucIndex].opId = opId;
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGD_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}


TAF_UINT32 At_SetCmgcPara(TAF_UINT8 ucIndex)
{
    TAF_UINT8                           ucSmSFormat;
    TAF_UINT32                          ulRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    ucSmSFormat = pstSmsCtx->enCmgfMsgFormat;

    /* 初始化 */
    memset_s(&gastAtClientTab[ucIndex].AtSmsData, sizeof(gastAtClientTab[ucIndex].AtSmsData), 0x00, sizeof(gastAtClientTab[ucIndex].AtSmsData));

    if (ucSmSFormat == AT_CMGF_MSG_FORMAT_TEXT)    /* TEXT方式*/
    {
        /* 如果<ct>或<fo>不存在，直接返回错误 */
        if ((gastAtParaList[1].usParaLen == 0)
         || (gastAtParaList[0].usParaLen == 0))
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gucAtParaIndex > 6)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置<fo>.SRR */
        gastAtClientTab[ucIndex].AtSmsData.ucFo         = (TAF_UINT8)gastAtParaList[0].ulParaValue;

        /* 设置<ct> */
        gastAtClientTab[ucIndex].AtSmsData.CommandType  = (TAF_UINT8)gastAtParaList[1].ulParaValue;

        /* 设置<pid> */
        if (gastAtParaList[2].usParaLen != 0)
        {
            gastAtClientTab[ucIndex].AtSmsData.enPid    = (TAF_UINT8)gastAtParaList[2].ulParaValue;
        }
        else
        {
            gastAtClientTab[ucIndex].AtSmsData.enPid    = 0;
        }

        /* 设置<mn> */
        if (gastAtParaList[3].usParaLen == 0)
        {
            gastAtClientTab[ucIndex].AtSmsData.ucMessageNumber  = 0;
        }
        else
        {
            gastAtClientTab[ucIndex].AtSmsData.ucMessageNumber  = (TAF_UINT8)gastAtParaList[3].ulParaValue;
        }

        /* 设置<oa/da> */
        ulRet = At_GetAsciiOrBcdAddr(gastAtParaList[4].aucPara,
                                     gastAtParaList[4].usParaLen,
                                     (TAF_UINT8)gastAtParaList[5].ulParaValue,
                                     gastAtParaList[5].usParaLen,
                                     &gastAtClientTab[ucIndex].AtSmsData.stAsciiAddr,
                                     TAF_NULL_PTR);
        if (ulRet != AT_OK)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGC_TEXT_SET;
    }
    else    /* PDU方式*/
    {
        /* 如果<length>不存在，直接返回错误 */
        if (gastAtParaList[0].usParaLen == 0)
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gucAtParaIndex > 1)  /* 参数过多 */
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (gastAtParaList[0].ulParaValue > AT_MSG_MAX_TPDU_LEN)
        {
            AT_NORM_LOG("At_SetCmgcPara: invalid tpdu data length.");
            return AT_ERROR;
        }

        gastAtClientTab[ucIndex].AtSmsData.ucPduLen = (TAF_UINT8)gastAtParaList[0].ulParaValue;
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGC_PDU_SET;
    }

    At_SetMode(ucIndex,AT_CMD_MODE,AT_SMS_MODE);         /* 切换为短信模式 */

    return AT_WAIT_SMS_INPUT;   /* 返回提示短信内容输入状态 */
}

TAF_UINT32 At_SetCmstPara(TAF_UINT8 ucIndex)
{
    MN_MSG_SEND_FROMMEM_PARM_STRU       stSendFromMemParm;
    TAF_UINT32                          ulRet;
    TAF_UINT32                          ulLoop;
    MN_OPERATION_ID_T                   opId                = At_GetOpId();
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查，如果<index>不存在，直接返回错误 */
    if((gastAtParaList[0].usParaLen == 0)
    || (gastAtParaList[3].usParaLen == 0)
    || (gucAtParaIndex > 4)
    || (gastAtParaList[3].ulParaValue < 1))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<da> */
    ulRet = At_GetAsciiOrBcdAddr(gastAtParaList[1].aucPara,
                                 gastAtParaList[1].usParaLen,
                                 (TAF_UINT8)gastAtParaList[2].ulParaValue,
                                 gastAtParaList[2].usParaLen,
                                 VOS_NULL_PTR,
                                 &stSendFromMemParm.stDestAddr);
    if (ulRet != AT_OK)
    {
        return AT_ERROR;
    }


    /* 设置发送存储器 */
    stSendFromMemParm.enMemStore = pstSmsCtx->stCpmsInfo.enMemSendorWrite;
    stSendFromMemParm.ulIndex = gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    gastAtClientTab[ucIndex].AtSmsData.ucMsgSentSmNum = (TAF_UINT8)gastAtParaList[3].ulParaValue;
    for(ulLoop = 0; ulLoop < gastAtClientTab[ucIndex].AtSmsData.ucMsgSentSmNum; ulLoop++)
    {
        if(MN_MSG_SendFromMem(gastAtClientTab[ucIndex].usClientId, opId, &stSendFromMemParm) != AT_SUCCESS)
        {
            return AT_ERROR;
        }
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMST_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}


VOS_UINT32 At_SetCmStubPara(VOS_UINT8 ucIndex)
{
    MN_MSG_STUB_MSG_STRU                stStubParam;
    VOS_UINT32                          ulRet;

    /* 输入参数检查: <stubtype>类型是否有效，参数个数不允许超过2个 */
    if ((gucAtParaIndex != 2)
     || (gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0))
    {
        AT_LOG1("At_SetCmStubPara: invalid parameter.", gucAtParaIndex);
        AT_LOG1("At_SetCmStubPara: invalid parameter.", gastAtParaList[0].ulParaValue);
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* A核能处理的桩直接处理并退出: 自动回复功能不需要通知C核 */
    if (gastAtParaList[0].ulParaValue == MN_MSG_STUB_TYPE_SMS_AUTO_REPLY)
    {
        AT_StubTriggerAutoReply(ucIndex, (VOS_UINT8)gastAtParaList[1].ulParaValue);
        return AT_OK;
    }

#if ( VOS_WIN32 == VOS_OS_VER )
    if (gastAtParaList[0].ulParaValue == MN_MSG_STUB_TYPE_CLASS0_TAILOR)
    {
        /* CLASS0类短信接收方式涉及A核和C核两部分，所以此处不能直接返回； */
        g_enClass0Tailor = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }
#endif

    /* 需要C核处理的桩: 发送消息给C核 */
    stStubParam.enStubType = (MN_MSG_STUB_TYPE_ENUM_U32)gastAtParaList[0].ulParaValue;
    stStubParam.ulValue    = gastAtParaList[1].ulParaValue;

    gastAtClientTab[ucIndex].opId = At_GetOpId();
    ulRet = MN_MSG_ReqStub(gastAtClientTab[ucIndex].usClientId,
                           gastAtClientTab[ucIndex].opId,
                           &stStubParam);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        return ulRet;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMSTUB_SET;
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetCmmsPara(
    TAF_UINT8                           ucIndex
)
{
    MN_MSG_SET_LINK_CTRL_STRU     stSetParam;
    TAF_UINT32                          ulRet;
    MN_OPERATION_ID_T                   opId                = At_GetOpId();

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex == 0)
    {
        stSetParam.enRelayLinkCtrl = MN_MSG_LINK_CTRL_ENABLE;
    }
    else
    {
        stSetParam.enRelayLinkCtrl = (MN_MSG_LINK_CTRL_U8)gastAtParaList[0].ulParaValue;
    }

    ulRet = MN_MSG_SetLinkCtrl(gastAtClientTab[ucIndex].usClientId, opId, &stSetParam);
    if (ulRet != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].opId = opId;
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMMS_SET;
    return AT_WAIT_ASYNC_RETURN;
}
#if ((FEATURE_GCBS == FEATURE_ON) || (FEATURE_WCBS == FEATURE_ON))

VOS_UINT32 AT_ParseCbParm(
    VOS_UINT8                           *pucInPara,
    TAF_CBA_CBMI_RANGE_LIST_STRU        *pstCbRange
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          iLoop;
    VOS_UINT32                          ulParm_count;
    TAF_UINT8                           aucTemp[TAF_CBA_MAX_CBMID_RANGE_NUM];
    VOS_BOOL                            bRange;
    VOS_UINT32                          ulValue;
    TAF_CBA_MSGID_SRC_FLG_ENUM_UINT8   enMidSrcFlg;

    enMidSrcFlg = TAF_CBA_MSGID_SRC_FLG_NULL;

    pstCbRange->usCbmirNum      = 0;
    iLoop                       = 0;
    bRange                      = VOS_FALSE;
    ulParm_count                = 0;
    i                           = 0;

    while ( ( pucInPara[iLoop] != '\0' )
         && ( i < TAF_CBA_MAX_CBMID_RANGE_NUM))
    {
        i = 0;
        while ( ( pucInPara[iLoop] != ',' )
             && ( pucInPara[iLoop] != '-' )
             && ( pucInPara[iLoop] != '\0' ) )
        {
            aucTemp[i++] = pucInPara[iLoop++];
            if ( i >= 6 )
            {
                return VOS_ERR;
            }
        }

        aucTemp[i++] = '\0';

        if ( VOS_StrLen((VOS_CHAR*)aucTemp) == 0 )
        {
            return VOS_ERR;
        }

        if ( bRange )
        {
            if(At_Auc2ul(aucTemp,
                         (VOS_UINT16)VOS_StrLen((VOS_CHAR*)aucTemp),
                         &ulValue) != AT_SUCCESS)
            {
                return VOS_ERR;
            }

            if ( ulValue > 0xFFFF )
            {
                return VOS_ERR;
            }

            if ( ulParm_count >= 1 )
            {
                pstCbRange->astCbmiRangeInfo[ulParm_count - 1].usMsgIdTo = (VOS_UINT16)ulValue;

                bRange = VOS_FALSE;
            }

        }
        else
        {
            if(At_Auc2ul(aucTemp,
                         (VOS_UINT16)VOS_StrLen((VOS_CHAR*)aucTemp),
                         &ulValue) != AT_SUCCESS)
            {
                return VOS_ERR;
            }

            if ( ulValue > 0xFFFF )
            {
                return VOS_ERR;
            }

            pstCbRange->astCbmiRangeInfo[ulParm_count].usMsgIdFrom = (VOS_UINT16)ulValue;
            pstCbRange->astCbmiRangeInfo[ulParm_count].usMsgIdTo = (VOS_UINT16)ulValue;
            /* 用户操作的，需要刷新到卡和NV，所以文件标记为 NV + EFCBMI+ EFCBMIR */
            enMidSrcFlg =  TAF_CBA_MSGID_SRC_FLG_NV;
            enMidSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMI;
            enMidSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMIR;

            pstCbRange->astCbmiRangeInfo[ulParm_count].ucMsgIdSrcFlg = enMidSrcFlg;
            (pstCbRange->usCbmirNum)++;
            ulParm_count++;
        }

        if ( pucInPara[iLoop] == '-')
        {
            bRange = VOS_TRUE;
        }
        else if ( pucInPara[iLoop] == '\0' )
        {
            return VOS_OK;
        }
        else
        {
            bRange = VOS_FALSE;
        }

        iLoop++;

        if ( ulParm_count >= AT_MAX_CBS_MSGID_NUM )
        {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_ProcCscbWithParm(
    TAF_UINT8                           ucIndex,
    TAF_CBA_CBMI_RANGE_LIST_STRU       *pstCbmirList
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulRet;
    TAF_CBA_CBMI_RANGE_LIST_STRU       *pstDcssInfo = VOS_NULL_PTR;
    VOS_UINT32                          ulAppRet;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(pstCbmirList, sizeof(TAF_CBA_CBMI_RANGE_LIST_STRU), 0x00, sizeof(TAF_CBA_CBMI_RANGE_LIST_STRU));

    ulRet = VOS_ERR;

    /* 表明 <mids> 有效*/
    if ( gastAtParaList[1].usParaLen > 0 )
    {
        gastAtParaList[1].aucPara[gastAtParaList[1].usParaLen] = '\0';
        ulRet = AT_ParseCbParm(gastAtParaList[1].aucPara,pstCbmirList);
    }

    /* 多个参数,MID必须存在,而且还必须合法,否则返回出错 */
    if ( ulRet != VOS_OK )
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 表明 <dcss> 有效*/
    if ( gastAtParaList[2].usParaLen > 0 )
    {
        /*lint -save -e516 */
        pstDcssInfo = (TAF_CBA_CBMI_RANGE_LIST_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT,
                            sizeof(TAF_CBA_CBMI_RANGE_LIST_STRU));
        /*lint -restore */
        if ( pstDcssInfo == VOS_NULL )
        {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        gastAtParaList[2].aucPara[gastAtParaList[2].usParaLen] = '\0';
        ulRet = AT_ParseCbParm(gastAtParaList[2].aucPara,pstDcssInfo);
        if ( ulRet == VOS_OK)
        {
            lMemResult = memcpy_s(&(pstSmsCtx->stCbsDcssInfo), sizeof(pstSmsCtx->stCbsDcssInfo), pstDcssInfo, sizeof(pstSmsCtx->stCbsDcssInfo));
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstSmsCtx->stCbsDcssInfo), sizeof(pstSmsCtx->stCbsDcssInfo));
        }
        else
        {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, pstDcssInfo);
            /*lint -restore */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstDcssInfo);
        /*lint -restore */
    }

    if( gastAtParaList[0].ulParaValue == MN_MSG_CBMODE_ACCEPT)
    {
        ulAppRet = MN_MSG_AddCbMids(gastAtClientTab[ucIndex].usClientId,
                                 gastAtClientTab[ucIndex].opId,
                                 pstCbmirList);
    }
    else
    {
        ulAppRet = MN_MSG_DelCbMids(gastAtClientTab[ucIndex].usClientId,
                                 gastAtClientTab[ucIndex].opId,
                                 pstCbmirList);
    }

    ulRet = VOS_OK;
    /*转换API调用结果*/
    if ( ulAppRet != MN_ERR_NO_ERROR )
    {
        ulRet = VOS_ERR;
    }

    if ( ulRet != VOS_OK )
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    return AT_OK;
}


TAF_UINT32 At_SetCscbPara(
    TAF_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulRet;
    TAF_CBA_CBMI_RANGE_LIST_STRU       *pstCbmirList = VOS_NULL_PTR;
    VOS_UINT32                          ulApiRet;
    TAF_CBA_MSGID_SRC_FLG_ENUM_UINT8   enMidSrcFlg;

    enMidSrcFlg = TAF_CBA_MSGID_SRC_FLG_NULL;
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 如果参数个数大于1,则第二个参数必须存在 */
    if (( gucAtParaIndex > 1 )
      && ( gastAtParaList[1].usParaLen == 0 ))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }
    /*lint -save -e516 */
    pstCbmirList = (TAF_CBA_CBMI_RANGE_LIST_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT,
                        sizeof(TAF_CBA_CBMI_RANGE_LIST_STRU));
    /*lint -restore */
    if ( pstCbmirList == VOS_NULL_PTR )
    {
        AT_WARN_LOG("At_SetCscbPara: Fail to alloc memory.");
        return AT_CMS_ERROR_IN_MS;
    }

    gastAtClientTab[ucIndex].opId = At_GetOpId();

    ulRet = AT_OK;
    if ( ( gucAtParaIndex == 0 )
      || (( gucAtParaIndex == 1 )
      && ( gastAtParaList[0].ulParaValue == MN_MSG_CBMODE_ACCEPT)))
    {
        /* 当前仅存在一个参数,表明是激活所有CBS消息 */
        pstCbmirList->usCbmirNum = 1;
        pstCbmirList->astCbmiRangeInfo[0].usMsgIdFrom = 0;
        pstCbmirList->astCbmiRangeInfo[0].usMsgIdTo = 0xFFFF;
        /* 用户操作的，需要刷新到卡和NV，所以文件标记为 NV + EFCBMI+ EFCBMIR */
        enMidSrcFlg =  TAF_CBA_MSGID_SRC_FLG_NV;
        enMidSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMI;
        enMidSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMIR;

        pstCbmirList->astCbmiRangeInfo[0].ucMsgIdSrcFlg = enMidSrcFlg;

        ulApiRet = MN_MSG_AddCbMids(gastAtClientTab[ucIndex].usClientId,
                                 gastAtClientTab[ucIndex].opId,
                                 pstCbmirList);

        /*转换API调用结果*/
        if ( ulApiRet != MN_ERR_NO_ERROR )
        {
            ulRet = AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }
    else if ( ( gucAtParaIndex == 1 )
      && ( gastAtParaList[0].ulParaValue == MN_MSG_CBMODE_REJECT ))
    {
        /* 当前仅存在一个参数,表明是去激活所有CBS消息 */
        ulApiRet = MN_MSG_EmptyCbMids(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId);

        /*转换API调用结果*/
        if ( ulApiRet != MN_ERR_NO_ERROR )
        {
            ulRet = AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }
    else
    {
        /* 处理带有参数等情况 */
        ulRet = AT_ProcCscbWithParm(ucIndex,pstCbmirList);
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pstCbmirList);
    /*lint -restore */
    if (ulRet != AT_OK)
    {
        return ulRet;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSCB_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}

#endif


TAF_UINT32 At_SetClipPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->ucClipType = (AT_CLIP_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->ucClipType = AT_CLIP_DISABLE_TYPE;
    }

    return AT_OK;
}


TAF_UINT32 At_SetClirPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        switch (gastAtParaList[0].ulParaValue)
        {
            case AT_CLIR_AS_SUBSCRIPT:
                pstSsCtx->ucClirType = AT_CLIR_AS_SUBSCRIPT;
                break;

            case AT_CLIR_INVOKE:
                pstSsCtx->ucClirType = AT_CLIR_INVOKE;
                break;

            case AT_CLIR_SUPPRESS:
                pstSsCtx->ucClirType = AT_CLIR_SUPPRESS;
                break;

            default:
                return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        pstSsCtx->ucClirType = AT_CLIR_AS_SUBSCRIPT;
    }
    return AT_OK;
}


VOS_UINT32 At_SetColpPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->ucColpType = (AT_COLP_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->ucColpType = AT_COLP_DISABLE_TYPE;
    }

    return AT_OK;
}
/*****************************************************************************
 Prototype      : At_SetCscsPara
 Description    : +CSCS=[<chset>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCscsPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtCscsType = (AT_CSCS_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtCscsType = AT_CSCS_IRA_CODE;
    }
    return AT_OK;
}
/*****************************************************************************
 Prototype      : At_SetCmeePara
 Description    : +CMEE=[<n>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCmeePara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtCmeeType = (AT_CMEE_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtCmeeType = AT_CMEE_ONLY_ERROR;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCeerPara(TAF_UINT8 ucIndex)
{
    VOS_UINT16                          usLength;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      "%s: %d,%d",
                                      g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                      AT_GetCsCallErrCause(ucIndex),
                                      AT_PS_GetPsCallErrCause(ucIndex));

    gstAtSendData.usBufLen = usLength;
    return AT_OK;
}

TAF_UINT32 At_SetCregPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU                  *pstNetCtx = VOS_NULL_PTR;

    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        pstNetCtx->ucCregType   = (AT_CREG_TYPE)gastAtParaList[0].ulParaValue;
        stAtCmd.u.ucCregRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

        /* 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
           都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询*/
    }
    else
    {
        pstNetCtx->ucCregType   = AT_CREG_RESULT_CODE_NOT_REPORT_TYPE;
        stAtCmd.u.ucCregRptFlg  = AT_CREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    stAtCmd.enReqType = AT_MTA_SET_CREG_RPT_TYPE;

    /* 给MTA发送+creg设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

TAF_UINT32 At_SetCgregPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU                  *pstNetCtx = VOS_NULL_PTR;

    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstNetCtx->ucCgregType  = (AT_CGREG_TYPE)gastAtParaList[0].ulParaValue;
        stAtCmd.u.ucCgregRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

        /* 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
           都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询*/
    }
    else
    {
        pstNetCtx->ucCgregType  = AT_CGREG_RESULT_CODE_NOT_REPORT_TYPE;
        stAtCmd.u.ucCgregRptFlg = AT_CGREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    stAtCmd.enReqType       = AT_MTA_SET_CGREG_RPT_TYPE;

    /* 给MTA发送+cgreg设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCsdfPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU                  *pstNetCtx = VOS_NULL_PTR;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    pstNetCtx->stCsdfCfg.ucMode     = 1;
    pstNetCtx->stCsdfCfg.ucAuxMode  = 1;

    /* 参数不为空 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        pstNetCtx->stCsdfCfg.ucMode  = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    if (gastAtParaList[1].usParaLen != 0)
    {
        pstNetCtx->stCsdfCfg.ucAuxMode  = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }

    return AT_OK;
}

#if(FEATURE_LTE == FEATURE_ON)

VOS_UINT32 AT_SetCeregPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU                  *pstNetCtx = VOS_NULL_PTR;

    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        pstNetCtx->ucCeregType  = (AT_CEREG_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
        stAtCmd.u.ucCeregRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

        /* 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
           都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询*/
    }
    else
    {
        pstNetCtx->ucCeregType  = AT_CEREG_RESULT_CODE_NOT_REPORT_TYPE;
        stAtCmd.u.ucCeregRptFlg = AT_CEREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    stAtCmd.enReqType       = AT_MTA_SET_CEREG_RPT_TYPE;

    /* 给MTA发送+cgreg设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 AT_SetC5gregPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU                  *pstNetCtx = VOS_NULL_PTR;

    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        pstNetCtx->ucC5gregType  = (AT_C5GREG_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
        stAtCmd.u.ucC5gregRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstNetCtx->ucC5gregType  = AT_C5GREG_RESULT_CODE_NOT_REPORT_TYPE;
        stAtCmd.u.ucC5gregRptFlg = AT_C5GREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    stAtCmd.enReqType       = AT_MTA_SET_C5GREG_RPT_TYPE;

    /* 给MTA发送+c5greg设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif


VOS_UINT32 At_SetClccPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                               ulRet;
    TAF_CTRL_STRU                            stCtrl;
    TAF_CALL_QRY_CALL_INFO_REQ_PARA_STRU     stQryCallInfoPara;
    MODEM_ID_ENUM_UINT16                     enModemId;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stQryCallInfoPara, sizeof(stQryCallInfoPara), 0x00, sizeof(stQryCallInfoPara));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stQryCallInfoPara.enGetCallInfoType = TAF_CALL_GET_CALL_INFO_TYPE_CLCC;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发消息到C核获取当前所有通话信息 */
    ulRet = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stQryCallInfoPara,
                                  ID_TAF_CCM_QRY_CALL_INFO_REQ,
                                  sizeof(stQryCallInfoPara),
                                  enModemId);

    if (ulRet != VOS_OK)
    {
        AT_WARN_LOG("At_SetClccPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCC_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetCpasPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                               ulRet;
    TAF_CTRL_STRU                            stCtrl;
    TAF_CALL_QRY_CALL_INFO_REQ_PARA_STRU     stQryCallInfoPara;
    MODEM_ID_ENUM_UINT16                     enModemId;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stQryCallInfoPara, sizeof(stQryCallInfoPara), 0x00, sizeof(stQryCallInfoPara));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stQryCallInfoPara.enGetCallInfoType = TAF_CALL_GET_CALL_INFO_TYPE_CLCC;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发消息到C核获取当前所有通话信息 */
    ulRet = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stQryCallInfoPara,
                                  ID_TAF_CCM_QRY_CALL_INFO_REQ,
                                  sizeof(stQryCallInfoPara),
                                  enModemId);

    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("At_SetCpasPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPAS_SET;

    return AT_WAIT_ASYNC_RETURN;
}
/*****************************************************************************
 Prototype      : At_SetCstaPara
 Description    : +CSTA=[<type>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCstaPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    g_enAtCstaNumType = (AT_CSTA_NUM_TYPE_ENUM_U8)gastAtParaList[0].ulParaValue;

    return AT_OK;
}

TAF_UINT32 At_SetCcugPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 设置<n> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->stCcugCfg.bEnable = gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->stCcugCfg.bEnable = 0;
    }

    /* 设置<index> */
    if(gastAtParaList[1].usParaLen != 0)
    {
        if (gastAtParaList[1].ulParaValue == 10)
        {
            pstSsCtx->stCcugCfg.bIndexPresent = 0;
            pstSsCtx->stCcugCfg.ulIndex       = 10;
        }
        else
        {
            pstSsCtx->stCcugCfg.bIndexPresent = 1;
            pstSsCtx->stCcugCfg.ulIndex = (TAF_UINT8)gastAtParaList[1].ulParaValue;
        }
    }
    else
    {
        pstSsCtx->stCcugCfg.bIndexPresent = 0;
        pstSsCtx->stCcugCfg.ulIndex       = 0;
    }

    /* 设置<info> */
    if(gastAtParaList[2].usParaLen != 0)
    {
        pstSsCtx->stCcugCfg.bSuppressPrefer = (gastAtParaList[2].ulParaValue & 0x02) >> 1;
        pstSsCtx->stCcugCfg.bSuppressOA     = gastAtParaList[2].ulParaValue & 0x01;
    }
    else
    {
        pstSsCtx->stCcugCfg.bSuppressPrefer = 0;
        pstSsCtx->stCcugCfg.bSuppressOA     = 0;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCssnPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_SET_CSSN_REQ_STRU           stCssnReq;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stCssnReq, sizeof(stCssnReq), 0x00, sizeof(stCssnReq));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCssnReq.ulActNum      = MN_CALL_MAX_CSSN_MSG_NUM;
    stCssnReq.aenSetType[0] = MN_CALL_SET_CSSN_DEACT;
    stCssnReq.aenSetType[1] = MN_CALL_SET_CSSN_DEACT;

    if(gastAtParaList[0].usParaLen != 0)
    {
        stCssnReq.aenSetType[0] = (MN_CALL_SET_CSSN_TYPE_ENUM_U32)gastAtParaList[0].ulParaValue;
    }

    if(gastAtParaList[1].usParaLen != 0)
    {
        stCssnReq.aenSetType[1] = (MN_CALL_SET_CSSN_TYPE_ENUM_U32)gastAtParaList[1].ulParaValue;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送消息 */
    ulRst = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stCssnReq,
                                  ID_TAF_CCM_SET_CSSN_REQ,
                                  sizeof(stCssnReq),
                                  enModemId);

    if (ulRst == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSSN_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

TAF_BOOL At_ParseSingleChldPara(
    TAF_UINT32                          ulParaValue,
    MN_CALL_SUPS_PARAM_STRU            *pstCallSupsCmd
    )
{

    switch ( ulParaValue )
    {
    case 0:
        pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_REL_HELD_OR_UDUB;
        break;

    case 1:
        pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_REL_ACT_ACPT_OTH;
        break;

    case 2:
        pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_HOLD_ACT_ACPT_OTH;
        break;

    case 3:
        pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_BUILD_MPTY;
        break;

    case 4:
        pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_ECT;
        break;

    case 5:
       pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_ACT_CCBS;
       return AT_OK;

    case 6:
       pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_ECONF_REL_USER;
       break;

    case 7:
       pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_ECONF_MERGE_CALL;
       break;

    case 8:
       pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_ACPT_WAITING_CALL;
       break;

    default:
        return AT_ERROR;
    }
    return AT_OK;
}


TAF_BOOL At_ParseChldPara(
    TAF_UINT32                          ulParaValue,
    MN_CALL_SUPS_PARAM_STRU            *pstCallSupsCmd
    )
{
    TAF_BOOL                            bRetRst;
    TAF_UINT8                           ucTmp;

    ucTmp = (TAF_UINT8)(ulParaValue / 10);

    if (ulParaValue < 10)
    {
        bRetRst = At_ParseSingleChldPara(ulParaValue,pstCallSupsCmd);
    }
    else
    {
        switch(ucTmp)
        {
        case 1:
            pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_REL_CALL_X;
            pstCallSupsCmd->callId = (MN_CALL_ID_T)(ulParaValue % 10);
            bRetRst = AT_OK;
            break;

        case 2:
            pstCallSupsCmd->enCallSupsCmd = MN_CALL_SUPS_CMD_HOLD_ALL_EXCPT_X;
            pstCallSupsCmd->callId = (MN_CALL_ID_T)(ulParaValue % 10);
            bRetRst = AT_OK;
            break;

        default:
            bRetRst = AT_ERROR;
            break;
        }
    }
    return bRetRst;
}


TAF_UINT32 At_SetChldPara(TAF_UINT8 ucIndex)
{
    MN_CALL_SUPS_PARAM_STRU             stCallChldParam;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    VOS_UINT32                          ulRst;
    MODEM_ID_ENUM_UINT16                enModemId;

    AT_PR_LOGH("At_SetChldPara Enter : CmdType = %d", gastAtParaList[0].ulParaValue);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCallChldParam, sizeof(stCallChldParam), 0x00, sizeof(stCallChldParam));

    ulRst = At_ParseChldPara(gastAtParaList[0].ulParaValue,&stCallChldParam);
    if (ulRst == AT_ERROR)
    {
        return AT_ERROR;
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                                        &stCallChldParam,
                                        ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                                        sizeof(stCallChldParam),
                                        enModemId) == VOS_OK)
    {
        /* 停止自动接听 */
        pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);

        if (pstCcCtx->stS0TimeInfo.bTimerStart == VOS_TRUE)
        {
            AT_StopRelTimer(pstCcCtx->stS0TimeInfo.ulTimerName, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }

        AT_PR_LOGH("At_SetChldPara success");

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CHLD_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetChldExPara(VOS_UINT8 ucIndex)
{
    MN_CALL_SUPS_PARAM_STRU             stCallChldParam;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    VOS_UINT32                          ulRst;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 参数过多 */
    if (gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有增强型多方通话踢人的场景下，才有第3个参数，即chld=6,0,"135xxxxxxxx" */
    if ((gastAtParaList[2].usParaLen != 0)
     && (gastAtParaList[0].ulParaValue != 6))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCallChldParam, sizeof(stCallChldParam), 0x00, sizeof(stCallChldParam));

    stCallChldParam.enCallType = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[1].ulParaValue;

    ulRst = At_ParseChldPara(gastAtParaList[0].ulParaValue, &stCallChldParam);
    if (ulRst == AT_ERROR)
    {
        return AT_ERROR;
    }

    /* 如果是需要释放多方通话中成员，需要携带电话号码 */
    if (stCallChldParam.enCallSupsCmd == MN_CALL_SUPS_CMD_ECONF_REL_USER)
    {
        /* 没有携带号码 */
        if (gastAtParaList[2].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 检查并转换电话号码 */
        if (AT_FillCalledNumPara((VOS_UINT8 *)gastAtParaList[2].aucPara,
                                  gastAtParaList[2].usParaLen,
                                  &stCallChldParam.stRemoveNum) != VOS_OK)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    stCallChldParam.ucRttFlg = (VOS_UINT8)gastAtParaList[3].ulParaValue;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stCallChldParam,
                              ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                              sizeof(stCallChldParam),
                              enModemId) == VOS_OK)
    {
        /* 停止自动接听 */
        pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);

        if (pstCcCtx->stS0TimeInfo.bTimerStart == VOS_TRUE)
        {
            AT_StopRelTimer(pstCcCtx->stS0TimeInfo.ulTimerName, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CHLD_EX_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetChupPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_SUPS_PARAM_STRU             stSupsCmdPara;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stSupsCmdPara, sizeof(stSupsCmdPara), 0x00, sizeof(stSupsCmdPara));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stSupsCmdPara.enCallSupsCmd = MN_CALL_SUPS_CMD_REL_ALL_CALL;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stSupsCmdPara,
                              ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                              sizeof(stSupsCmdPara),
                              enModemId) == VOS_OK)
    {
        /* 停止自动接听 */
        pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);

        if (pstCcCtx->stS0TimeInfo.bTimerStart == VOS_TRUE)
        {
            AT_StopRelTimer(pstCcCtx->stS0TimeInfo.ulTimerName, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CHUP_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_CheckDtmfKey(AT_PARSE_PARA_TYPE_STRU *pstAtPara)
{
    VOS_CHAR                            cKey;

    if ( pstAtPara->usParaLen != 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_UpString(pstAtPara->aucPara, pstAtPara->usParaLen) != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    cKey = (VOS_CHAR)pstAtPara->aucPara[0];
    if (!( ((cKey >= '0') && (cKey <= '9'))
         || (cKey == '*') || (cKey == '#')
         || (cKey == 'A') || (cKey == 'B')
         || (cKey == 'C') || (cKey == 'D') ))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_SetVtsPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_DTMF_PARAM_STRU            stDtmf;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stDtmf, sizeof(stDtmf), 0x00, sizeof(stDtmf));

    /* 参数类型个数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数值有效性检查 */
    ulResult = AT_CheckDtmfKey(&gastAtParaList[0]);

    if (ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    /* 发送START DTMF请求 */
    stDtmf.cKey        = (VOS_CHAR)gastAtParaList[0].aucPara[0];
    stDtmf.usOnLength  = AT_VTS_DEFAULT_DTMF_LENGTH;

    stDtmf.usOffLength = 0;

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送消息 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &stDtmf,
                                     ID_TAF_CCM_START_DTMF_REQ,
                                     sizeof(stDtmf),
                                     enModemId);

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VTS_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_CheckDtmfPara(VOS_VOID)
{
    
    /*参数有效性检查*/
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gucAtParaIndex > 4)
     || (gastAtParaList[2].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送DTMF时,需要带参数ckey,需要检查参数ckey是否合法
       停止DTMF时,不需要带参数ckey,不需要检查参数ckey是否合法 */
    if (gastAtParaList[2].ulParaValue != AT_DTMF_STOP)
    {
        if (AT_CheckDtmfKey(&gastAtParaList[1]) != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}



VOS_UINT32 At_SetDtmfPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_DTMF_PARAM_STRU            stDtmf;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stDtmf, sizeof(stDtmf), 0x00, sizeof(stDtmf));

    /*参数有效性检查*/
    ulResult = At_CheckDtmfPara();
    if (ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    stDtmf.CallId  = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stDtmf.cKey    = (VOS_CHAR)gastAtParaList[1].aucPara[0];

    /* 如果时长为1，则使用默认DTMF音时长 */
    if (gastAtParaList[2].ulParaValue == AT_DTMF_START)
    {
        stDtmf.usOnLength = AT_DTMF_DEFAULT_DTMF_LENGTH;
    }
    else
    {
        stDtmf.usOnLength = (VOS_UINT16)gastAtParaList[2].ulParaValue;
    }

    if ((gastAtParaList[3].ulParaValue == 0)
     || (gucAtParaIndex < 4))
    {
        stDtmf.usOffLength = 0;
    }
    else
    {
        stDtmf.usOffLength   = (VOS_UINT16)gastAtParaList[3].ulParaValue;

        if (stDtmf.usOffLength < AT_DTMF_MIN_DTMF_OFF_LENGTH)
        {
            /* offlength取值为0或者10ms-60000ms，小于10ms，osa无法启动小于10ms定时器，返回参数错误 */
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    if (stDtmf.usOnLength != AT_DTMF_STOP)
    {
        ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                         &stDtmf,
                                         ID_TAF_CCM_START_DTMF_REQ,
                                         sizeof(stDtmf),
                                         enModemId);
    }
    else
    {
        ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                         &stDtmf,
                                         ID_TAF_CCM_STOP_DTMF_REQ,
                                         sizeof(stDtmf),
                                         enModemId);
    }

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DTMF_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCrcPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->ucCrcType = (AT_CRC_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->ucCrcType = AT_CRC_DISABLE_TYPE;
    }

    return AT_OK;
}

TAF_UINT32 At_SetCbstPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->stCbstDataCfg.enSpeed = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->stCbstDataCfg.enSpeed = MN_CALL_CSD_SPD_64K_MULTI;
    }
    if(gastAtParaList[1].usParaLen != 0)
    {
        pstSsCtx->stCbstDataCfg.enName = (TAF_UINT8)gastAtParaList[1].ulParaValue;
    }
    else
    {
        pstSsCtx->stCbstDataCfg.enName = MN_CALL_CSD_NAME_SYNC_UDI;
    }
    if(gastAtParaList[2].usParaLen != 0)
    {
        pstSsCtx->stCbstDataCfg.enConnElem = (TAF_UINT8)gastAtParaList[2].ulParaValue;
    }
    else
    {
        pstSsCtx->stCbstDataCfg.enConnElem = MN_CALL_CSD_CE_T;
    }

    return AT_OK;
}

TAF_UINT32 At_SetCmodPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    pstSsCtx->enCModType = (TAF_UINT8)gastAtParaList[0].ulParaValue;

    return AT_OK;

}


VOS_UINT32 AT_CmmiProcUssd(
    VOS_UINT8                           ucIndex,
    TAF_SS_PROCESS_USS_REQ_STRU        *pUssdReq
)
{
    TAF_UINT8                           aucUssdStr[TAF_SS_MAX_USSDSTRING_LEN * 2];
    VOS_UINT32                          ulProcStrLen;
    VOS_UINT32                          ulRet;

    memset_s(aucUssdStr, sizeof(aucUssdStr), 0, sizeof(aucUssdStr));

    ulProcStrLen = 0;

    /* 由于SSA的7Bit编解码上移至AT，CMMI下发前需将码流从Ascii转到Hex */
    ulRet         = TAF_STD_ConvertAsciiToDefAlpha(pUssdReq->UssdStr.aucUssdStr,
                                                   pUssdReq->UssdStr.usCnt,
                                                   aucUssdStr,
                                                   &ulProcStrLen,
                                                   TAF_SS_MAX_USSDSTRING_LEN * 2);

    pUssdReq->UssdStr.usCnt = (VOS_UINT16)ulProcStrLen;

    if (ulRet != MN_ERR_NO_ERROR)
    {
        AT_WARN_LOG("AT_CmmiProcUssd : Conv7Bit Def Err");
        return TAF_FAILURE;
    }

    /* 清除原码流残余信息 */
    memset_s(pUssdReq->UssdStr.aucUssdStr,
             sizeof(pUssdReq->UssdStr.aucUssdStr),
             0,
             sizeof(pUssdReq->UssdStr.aucUssdStr));

    ulRet = TAF_STD_Pack7Bit(aucUssdStr,
                             pUssdReq->UssdStr.usCnt, 0,
                             pUssdReq->UssdStr.aucUssdStr,
                             &ulProcStrLen);

    pUssdReq->UssdStr.usCnt = (VOS_UINT16)ulProcStrLen;

    if (ulRet != MN_ERR_NO_ERROR)
    {
        AT_WARN_LOG("AT_CmmiProcUssd : Conv7Bit pack Err");
        return TAF_FAILURE;
    }

    /* CMMI只带USSDString,默认打开主动上报 */
    pUssdReq->enCusdType = TAF_SS_CUSD_TYPE_ENABLE;

    /* 调用TAF接口发送 */
    if (TAF_ProcessUnstructuredSSReq(gastAtClientTab[ucIndex].usClientId,0, pUssdReq) != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_CmmiProcUssd: TAF_ProcessUnstructuredSSReq failed");
        return TAF_FAILURE;
    }

    return TAF_SUCCESS;
}


VOS_UINT32 At_SetCmmiPara(VOS_UINT8 ucIndex)
{
    VOS_BOOL                            inCall;
    MN_MMI_OPERATION_PARAM_STRU        *pMmiOpParam = VOS_NULL_PTR;
    VOS_CHAR                           *pcOutRestMmiStr = VOS_NULL_PTR;
    VOS_UINT32                          ulResult;
    AT_CMD_CURRENT_OPT_ENUM             enCmdCurrentOpt;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);
    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 没有呼叫存在的情况 */
    if (pstCcCtx->ulCurIsExistCallFlag == VOS_FALSE)
    {
        inCall = VOS_FALSE;
    }
    else
    {
        inCall = VOS_TRUE;
    }
    /*lint -save -e516 */
    pMmiOpParam = (MN_MMI_OPERATION_PARAM_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(MN_MMI_OPERATION_PARAM_STRU));
    /*lint -restore */
    if(pMmiOpParam == TAF_NULL_PTR)
    {
        AT_WARN_LOG("At_SetCmmiPara Mem Alloc FAILURE");
        return AT_ERROR;
    }

    f_enClirOperate = MN_CALL_CLIR_AS_SUBS;

    pcOutRestMmiStr = (VOS_CHAR *)gastAtParaList[0].aucPara;
    pcOutRestMmiStr[gastAtParaList[0].usParaLen] = '\0';
    ulResult = MN_MmiStringParse((VOS_CHAR *)(gastAtParaList[0].aucPara), inCall, pMmiOpParam, &pcOutRestMmiStr);
    pMmiOpParam->ProcessUssdReq.DatacodingScheme = TAF_SS_7bit_LANGUAGE_UNSPECIFIED;

    if(ulResult == MN_ERR_NO_ERROR)
    {
        switch(pMmiOpParam->MmiOperationType)
        {
        case TAF_MMI_SUPPRESS_CLIR:
        case TAF_MMI_INVOKE_CLIR:

            if(pMmiOpParam->MmiOperationType == TAF_MMI_SUPPRESS_CLIR)
            {
                f_enClirOperate = MN_CALL_CLIR_SUPPRESS;
            }
            else
            {
                f_enClirOperate = MN_CALL_CLIR_INVOKE;
            }

            if((VOS_UINT16)(pcOutRestMmiStr - (VOS_CHAR *)(gastAtParaList[0].aucPara)) < gastAtParaList[0].usParaLen)
            {
                ulResult = MN_MmiStringParse(pcOutRestMmiStr, inCall, pMmiOpParam, &pcOutRestMmiStr);
            }
            else
            {
                /*lint -save -e516 */
                PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
                /*lint -restore */
                return AT_CME_INCORRECT_PARAMETERS;
            }
            break;
        default :
            break;
        }
        if(ulResult != MN_ERR_NO_ERROR)
        {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
            /*lint -restore */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 保存密码 */

        /* 调用TAF提供的接口，处理SS命令 */
        enCmdCurrentOpt = At_GetMnOptType(pMmiOpParam->MmiOperationType);
        if(enCmdCurrentOpt == AT_CMD_INVALID)
        {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
            /*lint -restore */
            return AT_ERROR;
        }
        switch(enCmdCurrentOpt)
        {
            case AT_CMD_D_CS_VOICE_CALL_SET:

                /* AT向CCM发送呼叫请求 */
                if (TAF_CCM_CallCommonReq(&stCtrl,
                                          &(pMmiOpParam->MnCallOrig),
                                          ID_TAF_CCM_CALL_ORIG_REQ,
                                          sizeof(pMmiOpParam->MnCallOrig),
                                          enModemId) != VOS_OK)
                {
                    AT_WARN_LOG("At_SetCmmiPara: MN_CALL_Orig failed.");
                }
                break;
            case AT_CMD_CHLD_SET:

                /* AT向CCM发送补充业务请求 */
                if (TAF_CCM_CallCommonReq(&stCtrl,
                                          &(pMmiOpParam->MnCallSupsReq),
                                          ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                                          sizeof(pMmiOpParam->MnCallSupsReq),
                                          enModemId) != VOS_OK)
                {
                    AT_WARN_LOG("At_SetCmmiPara: MN_CALL_Sups failed.");
                }
                break;
            case AT_CMD_CPIN_UNBLOCK_SET:
                if (Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->PinReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_CPIN2_UNBLOCK_SET:
                if (Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->PinReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_CPIN_VERIFY_SET:
                if (Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->PinReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }

                break;
            case AT_CMD_CPIN2_VERIFY_SET:
                if (Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->PinReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_SS_REGISTER:
                if (TAF_RegisterSSReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->RegisterSsReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_RegisterSSReq failed.");
                }
                break;
            case AT_CMD_SS_ERASE:
                if (TAF_EraseSSReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->EraseSsReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_EraseSSReq failed.");
                }
                break;
            case AT_CMD_SS_ACTIVATE:
                if (TAF_ActivateSSReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->ActivateSsReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_ActivateSSReq failed.");
                }
                break;
            case AT_CMD_SS_DEACTIVATE:
                if (TAF_DeactivateSSReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->DeactivateSsReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_DeactivateSSReq failed.");
                }
                break;

             case AT_CMD_SS_DEACTIVE_CCBS:
                if (TAF_EraseCCEntryReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->stCcbsEraseReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_EraseCCEntryReq failed.");
                }
                break;

            case AT_CMD_SS_INTERROGATE:
            case AT_CMD_SS_INTERROGATE_CCBS:
                if (TAF_InterrogateSSReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->InterrogateSsReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_DeactivateSSReq failed.");
                }
                break;
            case AT_CMD_SS_REGISTER_PSWD:
                if (TAF_RegisterPasswordReq(gastAtClientTab[ucIndex].usClientId,0, &pMmiOpParam->RegPwdReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_InterrogateSSReq failed.");
                }
                break;
            /* 删除AT_CMD_SS_GET_PSWD 分支 */
            case AT_CMD_CUSD_REQ:
                if (AT_CmmiProcUssd(ucIndex, &pMmiOpParam->ProcessUssdReq) != TAF_SUCCESS)
                {
                    AT_WARN_LOG("At_SetCmmiPara: AT_CmmiProcUssd failed.");
                }
                break;
            case AT_CMD_CLIP_READ:
                pstSsCtx->ucClipType = (AT_CLIP_TYPE)gastAtParaList[0].ulParaValue;
                /*lint -save -e516 */
                PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
                /*lint -restore */
                return AT_OK;
            default:
                break;
        }
        gastAtClientTab[ucIndex].CmdCurrentOpt = enCmdCurrentOpt;
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
        /*lint -restore */
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pMmiOpParam);
        /*lint -restore */
        return AT_CME_INCORRECT_PARAMETERS;
    }
}


VOS_UINT32 AT_CheckApnCustomChar(
    VOS_UINT8                           ucApnCharacter,
    VOS_UINT16                          usClientId
)
{
    AT_COMM_PS_CTX_STRU                *pstCommPsCtx = VOS_NULL_PTR;
    VOS_UINT32                          i;
    MODEM_ID_ENUM_UINT16                enModemId;

    enModemId       = MODEM_ID_0;
    pstCommPsCtx    = AT_GetCommPsCtxAddr();

    /* 获取modem id */
    if (AT_GetModemIdFromClient(usClientId, &enModemId) != VOS_OK)
    {
        AT_WARN_LOG("AT_CheckApnCustomChar: Get ModemId Failed.");
        return VOS_ERR;
    }

    /* 匹配定制字符 */
    for (i = 0; i < pstCommPsCtx->astApnCustomFormatCfg[enModemId].ucCustomCharNum; i++)
    {
        if (ucApnCharacter == pstCommPsCtx->astApnCustomFormatCfg[enModemId].aucCustomChar[i])
        {
            return VOS_OK;
        }
    }

    return VOS_ERR;
}


VOS_UINT32 AT_CheckApnFirstAndLastChar(
    VOS_UINT8                           ucApnCharacter,
    VOS_UINT16                          usClientId
)
{
    if ( ! ( ((ucApnCharacter >= 'A') && (ucApnCharacter <= 'Z'))
          || ((ucApnCharacter >= '0') && (ucApnCharacter <= '9'))
          || (AT_CheckApnCustomChar(ucApnCharacter, usClientId) == VOS_OK)) )
    {
        AT_WARN_LOG("AT_CheckApnFirstAndLastChar: WARNING: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckApnFirstAndLastString(
    VOS_UINT8                          *pucApn,
    VOS_UINT16                          usApnLen,
    VOS_UINT16                          usClientId
)
{
    AT_COMM_PS_CTX_STRU                *pstCommPsCtx = VOS_NULL_PTR;
    VOS_UINT8                           aucApn[TAF_MAX_APN_LEN + 1];
    errno_t                             lMemResult;
    MODEM_ID_ENUM_UINT16                enModemId;

    enModemId = MODEM_ID_0;
    pstCommPsCtx = AT_GetCommPsCtxAddr();
    memset_s(aucApn, sizeof(aucApn), 0x00, sizeof(aucApn));

    /* 获取modem id */
    if (AT_GetModemIdFromClient(usClientId, &enModemId) != VOS_OK)
    {
        AT_WARN_LOG("AT_CheckApnFirstAndLastString: Get ModemId Failed.");
        return VOS_OK;
    }

    /* 不需要检查直接返回OK */
    if (pstCommPsCtx->astApnCustomFormatCfg[enModemId].ucProtocolStringCheckFlag == VOS_FALSE)
    {
        return VOS_OK;
    }

    /* TS 23.003 9.1.1
     * The APN Network Identifier shall contain at least one label and shall have,
     * after encoding as defined in subclause 9.1 above, a maximum length of 63 octets.
     * An APN Network Identifier shall not start with any of the strings "rac", "lac",
     * "sgsn" or "rnc", and it shall not end in ".gprs", i.e. the last label of the
     * APN Network Identifier shall not be "gprs". Further, it shall not take the value "*".
     */

    lMemResult = memcpy_s(aucApn, sizeof(aucApn), pucApn, usApnLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucApn), usApnLen);

    (VOS_VOID)At_UpString(aucApn, usApnLen);

    /* 判断头部字符串 */
    if (! (TAF_MEM_CMP(aucApn, "RAC", AT_PS_RAC_STRING_LENGTH)
        && TAF_MEM_CMP(aucApn, "LAC", AT_PS_LAC_STRING_LENGTH)
        && TAF_MEM_CMP(aucApn, "SGSN", AT_PS_SGSN_STRING_LENGTH)
        && TAF_MEM_CMP(aucApn, "RNC", AT_PS_RNC_STRING_LENGTH)))
    {
        return VOS_ERR;
    }

    /* 判断尾部字符串 */
    if (usApnLen >= sizeof("GRPS"))
    {
        if (!TAF_MEM_CMP(aucApn + usApnLen - AT_PS_GRPS_STRING_LENGTH, "GPRS", AT_PS_GRPS_STRING_LENGTH))
        {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckApnFormat(
    VOS_UINT8                          *pucApn,
    VOS_UINT16                          usApnLen,
    VOS_UINT16                          usClientId
)
{
    VOS_UINT32                          i;
    VOS_UINT8                           ucApnCharacter;

    for ( i = 0 ; i < usApnLen; i++ )
    {
        /* 转换APN字符为大写 */
        ucApnCharacter = AT_UPCASE(pucApn[i]);

        /* 检查APN字符有效性 */
        if ( ! ( ((ucApnCharacter >= 'A') && (ucApnCharacter <= 'Z'))
              || ((ucApnCharacter >= '0') && (ucApnCharacter <= '9'))
              || (ucApnCharacter == '-')
              || (ucApnCharacter == '.')
              || (AT_CheckApnCustomChar(ucApnCharacter, usClientId) == VOS_OK) ) )
        {
            AT_WARN_LOG("AT_CheckApnFormat: Invalid character in APN.");
            return VOS_ERR;
        }
    }

    /* 检查APN开始字符有效性 */
    ucApnCharacter = AT_UPCASE(pucApn[0]);
    if ( AT_CheckApnFirstAndLastChar(ucApnCharacter, usClientId) != VOS_OK )
    {
        AT_WARN_LOG("AT_CheckApnFormat: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    /* 检查APN末尾字符有效性 */
    ucApnCharacter = AT_UPCASE(pucApn[usApnLen - 1]);
    if ( AT_CheckApnFirstAndLastChar(ucApnCharacter, usClientId) != VOS_OK )
    {
        AT_WARN_LOG("AT_CheckApnFormat: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    /* 检查APN开头末尾是否包含不期望的字符串 */
    if (AT_CheckApnFirstAndLastString(pucApn, usApnLen, usClientId) != VOS_OK)
    {
        AT_WARN_LOG("AT_CheckApnFormat: UnexpectString in APN.");
        return VOS_ERR;
    }

    return VOS_OK;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

LOCAL VOS_UINT32 AT_CheckSNssaiFormat(
    VOS_UINT8                          *pucSNssai,
    VOS_UINT16                          usSNssaiLen
)
{
    VOS_UINT32                          i;
    VOS_UINT8                           ucCharacter;

    for ( i = 0 ; i < usSNssaiLen; i++ )
    {
        ucCharacter = AT_UPCASE(pucSNssai[i]);

        /* 检查S-NSSAI字符有效性 */
        if (!(((ucCharacter >= '0') && (ucCharacter <= '9'))
             || ((ucCharacter >= 'A') && (ucCharacter <= 'F'))
             || (ucCharacter == ';')
             || (ucCharacter == '.')))
        {
            AT_WARN_LOG("AT_CheckSNssaiFormat: WARNING: Invalid character in S-NSSAI.");
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeSNssaiPara(
    VOS_UINT8                          *pucSNssai,
    VOS_UINT16                          usSNssaiLen,
    AT_S_NSSAI_PARSE_STRU              *pstSNssaiParse
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ucDigitCount;
    VOS_UINT8                           ucCharacter;

    ucDigitCount = 0;

    for (i = 0 ; i < usSNssaiLen; i++)
    {
        ucCharacter = AT_UPCASE(pucSNssai[i]);

        if ((ucCharacter >= '0') && (ucCharacter <= '9'))
        {
            /* 高位数值左移4bit */
            pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]   = (VOS_UINT32)(pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]  << AT_OCTET_MOVE_FOUR_BITS);
            pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]  += (pucSNssai[i] - '0');

            ucDigitCount ++;
            if (ucDigitCount > AT_S_NSSAI_SD_MAX_DIGIT_NUM)
            {
                /* 每个参数的位数最多不超过6 */
                return VOS_ERR;
            }
        }
        else if ((ucCharacter >= 'A') && (ucCharacter <= 'F'))
        {
            /* 高位数值左移4bit */
            pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]   = (VOS_UINT32)(pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]  << AT_OCTET_MOVE_FOUR_BITS);
            pstSNssaiParse->aulDigite[pstSNssaiParse->ucDigitParaNum]  += ((ucCharacter - 'A') + 0x0A);

            ucDigitCount ++;
            if (ucDigitCount > AT_S_NSSAI_SD_MAX_DIGIT_NUM)
            {
                /* 每个参数的位数最多不超过6 */
                return VOS_ERR;
            }
        }
        else
        {
            if (ucDigitCount == 0)
            {
                /* 字符串如果以符号开头，或者字符串中出现连续的符号，则输入错误 */
                return VOS_ERR;
            }

            if ((i + 1) == usSNssaiLen)
            {
                /* 如果最后1个字符是符号，说明少1个数字，需要返回错误 */
                return VOS_ERR;
            }

            /* 数值字符计数清0 */
            ucDigitCount      = 0;

            /* 记录字符 */
            pstSNssaiParse->aucPunctuation[pstSNssaiParse->ucPunctuationNum] = pucSNssai[i];

            /* 准备记录下一个数字或者字符 */
            pstSNssaiParse->ucDigitParaNum++;
            pstSNssaiParse->ucPunctuationNum++;

            if ((pstSNssaiParse->ucDigitParaNum > AT_S_NSSAI_MAX_DIGIT_NUM)
             || (pstSNssaiParse->ucPunctuationNum > AT_S_NSSAI_MAX_PUNC_NUM))
            {
                return VOS_ERR;
            }
        }
    }

    /* 记录最后一个数字后，计数加1 */
    pstSNssaiParse->ucDigitParaNum++;

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_CheckSNssaiPunctuationPara(
    AT_S_NSSAI_PARSE_STRU              *pstSNssaiParse
)
{
    /*  sst                                     only slice/service type (SST) is present
     *  sst;mapped_sst                          SST and mapped configured SST are present
     *  sst.sd                                  SST and slice differentiator (SD) are present
     *  sst.sd;mapped_sst                       SST, SD and mapped configured SST are present
     *  sst.sd;mapped_sst.mapped_sd             SST, SD, mapped configured SST and mapped configured SD are present*/

    VOS_UINT8                           aucPuncMould[AT_S_NSSAI_MAX_PUNC_NUM + 1] = {'.', ';', '.', 0};
    VOS_UINT8                           ucNum;

    if (pstSNssaiParse->ucPunctuationNum == 0)
    {
        return VOS_OK;
    }

    ucNum = AT_MIN(pstSNssaiParse->ucPunctuationNum, AT_S_NSSAI_MAX_PUNC_NUM);

    if ((ucNum == 0x01)
     && (pstSNssaiParse->aucPunctuation[0] == ';'))
    {
        /* 此情况是合法的 */
        return VOS_OK;
    }

    if (PS_MEM_CMP(aucPuncMould, pstSNssaiParse->aucPunctuation, ucNum) != 0)
    {
        return VOS_ERR;
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_CheckSNssaiDigitPara(
    AT_S_NSSAI_PARSE_STRU              *pstSNssaiParse
)
{
    /* 本函数主要检查SST和MAP SST的取值范围，SD在解析时做了检查 */

    /* 检查第一个数值，应该为SST */
    if (pstSNssaiParse->aulDigite[0] > 0xFF)
    {
        return VOS_ERR;
    }

    if (pstSNssaiParse->ucPunctuationNum == 1)
    {
        /* 如果为SST;MAP SST的格式，检查MAP SST的参数值 */
        if (pstSNssaiParse->aucPunctuation[0] == ';' )
        {
            if (pstSNssaiParse->aulDigite[1] > 0xFF)
            {
                return VOS_ERR;
            }
        }
    }

    if ((pstSNssaiParse->ucPunctuationNum == 2) || (pstSNssaiParse->ucPunctuationNum == 3))
    {
        /* 如果为SST.SD;map_SST或者SST.map_SD;map_SST.map_SD的格式，检查MAP SST的参数值 */
        if (pstSNssaiParse->aulDigite[2] > 0xFF)
        {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeSNssai(
    VOS_UINT8                          *pucSNssai,
    VOS_UINT16                          usSNssaiLen,
    PS_S_NSSAI_STRU                    *pstSNssai
)
{
    AT_S_NSSAI_PARSE_STRU               stSNssai;

    /*  27007 rel15, 10.1.1章节
     *  sst                                     only slice/service type (SST) is present
     *  sst;mapped_sst                          SST and mapped configured SST are present
     *  sst.sd                                  SST and slice differentiator (SD) are present
     *  sst.sd;mapped_sst                       SST, SD and mapped configured SST are present
     *  sst.sd;mapped_sst.mapped_sd             SST, SD, mapped configured SST and mapped configured SD are present
    */

    memset_s(pstSNssai, sizeof(PS_S_NSSAI_STRU), 0, sizeof(PS_S_NSSAI_STRU));
    memset_s(&stSNssai, sizeof(stSNssai), 0, sizeof(AT_S_NSSAI_PARSE_STRU));

    /* 检查S-NSSAI字符串中的字符格式是否正确  */
    if (AT_CheckSNssaiFormat(pucSNssai, usSNssaiLen) == VOS_ERR)
    {
        return VOS_ERR;
    }

    /* 解析S-NSSAI字符串 */
    if (AT_DecodeSNssaiPara(pucSNssai, usSNssaiLen, &stSNssai) == VOS_ERR)
    {
        return VOS_ERR;
    }

    /* 先检查分割符是否正确 */
    if (AT_CheckSNssaiPunctuationPara(&stSNssai) == VOS_ERR)
    {
        return VOS_ERR;
    }

    /* 再检查数值是否正确 */
    if (AT_CheckSNssaiDigitPara(&stSNssai) == VOS_ERR)
    {
        return VOS_ERR;
    }

    /* 赋值 */
    if (stSNssai.ucDigitParaNum == 1)
    {
        /* SST */
        pstSNssai->ucSst    = (VOS_UINT8)stSNssai.aulDigite[0];
    }
    else if(stSNssai.ucDigitParaNum == 2)
    {
        /* SST.SD或者SST;map_SST */
        pstSNssai->ucSst    = (VOS_UINT8)stSNssai.aulDigite[0];

        /* 如果解析成功，判断后续字符是"."还是";" */
        if (stSNssai.aucPunctuation[0] == '.' )
        {
            pstSNssai->bitOpSd          = VOS_TRUE;
            pstSNssai->ulSd             = stSNssai.aulDigite[1];
        }
        else
        {
            pstSNssai->bitOpMappedSst   = VOS_TRUE;
            pstSNssai->ucMappedSst      = (VOS_UINT8)stSNssai.aulDigite[1];
        }
    }
    else if (stSNssai.ucDigitParaNum == 3)
    {
        /* SST.SD;map_SST */
        pstSNssai->ucSst                = (VOS_UINT8)stSNssai.aulDigite[0];
        pstSNssai->bitOpSd              = VOS_TRUE;
        pstSNssai->ulSd                 = stSNssai.aulDigite[1];
        pstSNssai->bitOpMappedSst       = VOS_TRUE;
        pstSNssai->ucMappedSst          = (VOS_UINT8)stSNssai.aulDigite[2];
    }
    else
    {
        /* SST.SD;map_SST.map_SD */
        pstSNssai->ucSst                = (VOS_UINT8)stSNssai.aulDigite[0];
        pstSNssai->bitOpSd              = VOS_TRUE;
        pstSNssai->ulSd                 = stSNssai.aulDigite[1];
        pstSNssai->bitOpMappedSst       = VOS_TRUE;
        pstSNssai->ucMappedSst          = (VOS_UINT8)stSNssai.aulDigite[2];
        pstSNssai->bitOpMappedSd        = VOS_TRUE;
        pstSNssai->ulMappedSd           = stSNssai.aulDigite[3];
    }

    /* SD值如果是全F，是非法的，需要将OP项设置为False */
    if (pstSNssai->ulSd == 0xffffff)
    {
        pstSNssai->bitOpSd = VOS_FALSE;
        pstSNssai->ulSd    = 0;
    }

    /* SD值如果是全F，是非法的，需要将OP项设置为False */
    if (pstSNssai->ulMappedSd == 0xffffff)
    {
        pstSNssai->bitOpMappedSd = VOS_FALSE;
        pstSNssai->ulMappedSd    = 0;
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeMultiSNssaiString(
    VOS_UINT16                          usCfgSNssaiLen,
    VOS_UINT8                          *pucSNssai,
    VOS_UINT16                          usSNssaiLen,
    PS_CONFIGURED_NSSAI_STRU           *pstSNssai
)
{
    VOS_UINT8                           temp[AT_SINGLE_S_NSSAI_MAX_STR_LEN] = {0};
    PS_S_NSSAI_STRU                     singleNssai;
    VOS_UINT32                          i;
    VOS_UINT32                          j;

    memset_s(&singleNssai, sizeof(singleNssai), 0, sizeof(PS_S_NSSAI_STRU));

    if (usCfgSNssaiLen != usSNssaiLen)
    {
        return VOS_ERR;
    }

    /* 首尾的字符串不能是切片间隔符号: */
    if ((pucSNssai[0]               == ':')
     || (pucSNssai[usSNssaiLen - 1] == ':'))
    {
        return VOS_ERR;
    }

    if (usCfgSNssaiLen > AT_EVT_MULTI_S_NSSAI_LEN)
    {
        return VOS_ERR;
    }

    if (usCfgSNssaiLen == 0)
    {
        pstSNssai->ucSNssaiNum = 0;

        return VOS_OK;
    }

    j = 0;

    for (i = 0; i < usCfgSNssaiLen; i++)
    {
        if (pucSNssai[i] != ':')
        {
            /* 选出单个切片字符串 */
            temp[j] = pucSNssai[i];

            j++;

            if (j >= AT_SINGLE_S_NSSAI_MAX_STR_LEN)
            {
                return VOS_ERR;
            }
        }
        else
        {
            if (AT_DecodeSNssai(temp, (VOS_UINT16)j, &singleNssai) != VOS_OK)
            {
                return VOS_ERR;
            }

            /* 超出最大规格 */
            if (pstSNssai->ucSNssaiNum >= PS_MAX_CFG_S_NSSAI_NUM)
            {
                return VOS_ERR;
            }

            /* 取出有效切片 */
            pstSNssai->astSNssai[pstSNssai->ucSNssaiNum] = singleNssai;

            /* 切片个数累加 */
            pstSNssai->ucSNssaiNum ++;

            /* 重新将索引设置为0 */
            j = 0;
        }
    }

    /* 对最后1个字符串切片进行转换 */
    if (AT_DecodeSNssai(temp, (VOS_UINT16)j, &singleNssai) != VOS_OK)
    {
        return VOS_ERR;
    }

    /* 超出最大规格 */
    if (pstSNssai->ucSNssaiNum >= PS_MAX_CFG_S_NSSAI_NUM)
    {
        return VOS_ERR;
    }

    /* 取出有效切片 */
    pstSNssai->astSNssai[pstSNssai->ucSNssaiNum] = singleNssai;

    /* 切片个数累加 */
    pstSNssai->ucSNssaiNum ++;

    return VOS_OK;
}

#endif



VOS_VOID AT_ParseCgdcontPara(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo
)
{
    /* 设置<d_comp> */
    if ( gastAtParaList[4].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpPdpDcomp  = VOS_TRUE;
        pstPdpCxtInfo->enPdpDcomp     = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    }

    /* 设置<h_comp> */
    if ( gastAtParaList[5].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpPdpHcomp  = VOS_TRUE;
        pstPdpCxtInfo->enPdpHcomp     = (VOS_UINT8)gastAtParaList[5].ulParaValue;
    }

    /* 设置<IPv4AddrAlloc> */
    if ( gastAtParaList[6].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpIpv4AddrAlloc = VOS_TRUE;
        pstPdpCxtInfo->enIpv4AddrAlloc    = (VOS_UINT8)gastAtParaList[6].ulParaValue;
    }

    /* 设置<Emergency Indication> */
    if ( gastAtParaList[7].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpEmergencyInd = VOS_TRUE;
        pstPdpCxtInfo->enEmergencyFlg    = (VOS_UINT8)gastAtParaList[7].ulParaValue;
    }

    /* 设置<P-CSCF_discovery> */
    if ( gastAtParaList[8].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpPcscfDiscovery = VOS_TRUE;
        pstPdpCxtInfo->enPcscfDiscovery    = (VOS_UINT8)gastAtParaList[8].ulParaValue;
    }
    /* 设置<IM_CN_Signalling_Flag_Ind> */
    if ( gastAtParaList[9].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpImCnSignalFlg = VOS_TRUE;
        pstPdpCxtInfo->enImCnSignalFlg    = (VOS_UINT8)gastAtParaList[9].ulParaValue;
    }
    /* 设置<NAS_Signalling_Prio_Ind> */
    if ( gastAtParaList[10].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpNasSigPrioInd = VOS_TRUE;
        pstPdpCxtInfo->enNasSigPrioInd    = (VOS_UINT8)gastAtParaList[10].ulParaValue;
    }
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    /* 设置<SSC_mode> */
    if ( gastAtParaList[16].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpSscMode   = VOS_TRUE;
        pstPdpCxtInfo->enSscMode      = (VOS_UINT8)gastAtParaList[16].ulParaValue;
    }

    /* 设置<Pref_access_type> */
    if ( gastAtParaList[18].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpPrefAccessType = VOS_TRUE;
        pstPdpCxtInfo->enPrefAccessType    = (VOS_UINT8)gastAtParaList[18].ulParaValue;
    }

    /* 设置<RQos_ind> */
    if ( gastAtParaList[19].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpRQosInd       = VOS_TRUE;
        pstPdpCxtInfo->enRQosInd          = (VOS_UINT8)gastAtParaList[19].ulParaValue;
    }

    /* 设置<always on ind> */
    if ( gastAtParaList[21].usParaLen != 0 )
    {
        pstPdpCxtInfo->bitOpAlwaysOnInd    = VOS_TRUE;
        pstPdpCxtInfo->enAlwaysOnInd       = (VOS_UINT8)gastAtParaList[21].ulParaValue;
    }
#endif
}


LOCAL AT_RRETURN_CODE_ENUM_UINT32 AT_ParseCgdcontIpType(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo
)
{
    /* 对比终端的结果，在<PDP_type>参数为""(两个引号)时,则保留原先的值，
       若g_TafCidTab[ucCid].ucUsed指示上下文被删除，则使用之前保留下来的值 */

    if ( gastAtParaList[1].usParaLen != 0 )
    {
        if ( gastAtParaList[1].ulParaValue < TAF_PDP_PPP )
        {
            pstPdpCxtInfo->bitOpPdpType   = VOS_TRUE;

            /* IP:1, IPV6:2, IPV4V6:3, PPP:4 */
            pstPdpCxtInfo->enPdpType  = (VOS_UINT8)(gastAtParaList[1].ulParaValue + 1);

            if ( (pstPdpCxtInfo->enPdpType == TAF_PDP_IPV6)
              || (pstPdpCxtInfo->enPdpType == TAF_PDP_IPV4V6) )
            {
                if (AT_GetIpv6Capability() == AT_IPV6_CAPABILITY_IPV4_ONLY)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
            }
        }
    }
    return AT_SUCCESS;
}


LOCAL AT_RRETURN_CODE_ENUM_UINT32 AT_ParseCgdcontApn(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo,
    VOS_UINT16                          usClientId
)
{
    errno_t                             lMemResult;
    if ( gastAtParaList[2].usParaLen > TAF_MAX_APN_LEN )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gastAtParaList[2].usParaLen != 0 )
    {
        /* 检查APN */
        if ( AT_CheckApnFormat(gastAtParaList[2].aucPara,
                               gastAtParaList[2].usParaLen,
                               usClientId) != VOS_OK )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pstPdpCxtInfo->bitOpApn       = VOS_TRUE;
        lMemResult = memcpy_s((VOS_CHAR*)pstPdpCxtInfo->aucApn,
                              sizeof(pstPdpCxtInfo->aucApn),
                              (VOS_CHAR*)gastAtParaList[2].aucPara,
                              gastAtParaList[2].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstPdpCxtInfo->aucApn), gastAtParaList[2].usParaLen);
        pstPdpCxtInfo->aucApn[gastAtParaList[2].usParaLen] = 0;
    }

    return AT_SUCCESS;
}


LOCAL AT_RRETURN_CODE_ENUM_UINT32 AT_ParseCgdcontIpAddr(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo
)
{
    if ( gastAtParaList[3].usParaLen != 0 )
    {
        if ( ((gastAtParaList[1].ulParaValue + 1) != TAF_PDP_IPV4)
          || (gastAtParaList[3].usParaLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1)) )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pstPdpCxtInfo->bitOpPdpAddr        = VOS_TRUE;
        pstPdpCxtInfo->stPdpAddr.enPdpType = TAF_PDP_IPV4;

        /* 把IP地址字符串转换成数字 */
        if (AT_Ipv4AddrAtoi((VOS_CHAR*)gastAtParaList[3].aucPara,
                            (VOS_UINT8*)pstPdpCxtInfo->stPdpAddr.aucIpv4Addr,
                            TAF_IPV4_ADDR_LEN) != VOS_OK)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

LOCAL AT_RRETURN_CODE_ENUM_UINT32 AT_ParseCgdcontSNssai(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo
)
{
    /* 解析S-NSSAI参数 */
    if (gastAtParaList[17].usParaLen != 0)
    {
        if (AT_DecodeSNssai(gastAtParaList[17].aucPara,
                            gastAtParaList[17].usParaLen,
                            &pstPdpCxtInfo->stSNssai) != VOS_OK)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pstPdpCxtInfo->bitOpSNssai    = VOS_TRUE;
    }

    return AT_SUCCESS;
}


LOCAL AT_RRETURN_CODE_ENUM_UINT32 AT_ParseCgdcontMhpv6(
    TAF_PDP_PRIM_CONTEXT_EXT_STRU      *pstPdpCxtInfo
)
{
    /* 设置<MH6-PDU> */
    if (gastAtParaList[20].usParaLen != 0)
    {
        pstPdpCxtInfo->bitOpMh6Pdu      = VOS_TRUE;
        pstPdpCxtInfo->enMh6Pdu         = (VOS_UINT8)gastAtParaList[20].ulParaValue;
    }

    /* 参考24501 6.2.11章节，只有在IPV6或者IPV4V6类型时，才需要支持MHPV6 */
    if (pstPdpCxtInfo->enMh6Pdu == TAF_PS_IPV6_MULTI_HOMING_IND_SUPPORT)
    {
        if ((pstPdpCxtInfo->stPdpAddr.enPdpType != TAF_PDP_IPV6)
         && (pstPdpCxtInfo->stPdpAddr.enPdpType != TAF_PDP_IPV4V6))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}


#endif




VOS_UINT32 AT_SetCgdcontPara(VOS_UINT8 ucIndex)
{
    TAF_PDP_PRIM_CONTEXT_EXT_STRU       stPdpCxtInfo;

    AT_RRETURN_CODE_ENUM_UINT32         enErrCode;

    /* 初始化 */
    enErrCode   = AT_SUCCESS;
    memset_s(&stPdpCxtInfo, sizeof(stPdpCxtInfo), 0x00, sizeof(TAF_PDP_PRIM_CONTEXT_EXT_STRU));

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > AT_SET_CGDCONT_PARA_MAX_NUMBER )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<CID> */
    stPdpCxtInfo.ucCid                  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stPdpCxtInfo.ucDefined          = VOS_FALSE;
    }
    else
    {
        stPdpCxtInfo.ucDefined          = VOS_TRUE;

        /* 设置<PDP_type> */
        enErrCode |= AT_ParseCgdcontIpType(&stPdpCxtInfo);

        /* 设置<APN> */
        enErrCode |= AT_ParseCgdcontApn(&stPdpCxtInfo, gastAtClientTab[ucIndex].usClientId);

        /* 设置<PDP_addr> */
        /* 只处理IPV4的IP ADDR，IPV6不使用此AT命令设置的IP ADDR */
        enErrCode |= AT_ParseCgdcontIpAddr(&stPdpCxtInfo);

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        /* 设置<S-NSSAI> */
        enErrCode |= AT_ParseCgdcontSNssai(&stPdpCxtInfo);

        enErrCode |= AT_ParseCgdcontMhpv6(&stPdpCxtInfo);

#endif
        /* 检查<IP TYEP><APN><PDP_addr><S-NSSAI>参数的正确性 */
        if (enErrCode != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        AT_ParseCgdcontPara(&stPdpCxtInfo);
    }

    /* 执行命令操作 */
    if ( TAF_PS_SetPrimPdpContextInfo(WUEPS_PID_AT,
                                      AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                      0,
                                      &stPdpCxtInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGDCONT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCgdscontPara(VOS_UINT8 ucIndex)
{
    TAF_PDP_SEC_CONTEXT_EXT_STRU        stPdpCxtInfo;

    /* 初始化 */
    memset_s(&stPdpCxtInfo, sizeof(stPdpCxtInfo), 0x00, sizeof(TAF_PDP_SEC_CONTEXT_EXT_STRU));

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 5 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<s_cid> */
    stPdpCxtInfo.ucCid         = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stPdpCxtInfo.ucDefined          = VOS_FALSE;
    }
    else
    {
        stPdpCxtInfo.ucDefined          = VOS_TRUE;

        /* 设置<p_cid> */
        if ( gastAtParaList[1].usParaLen != 0 )
        {
            stPdpCxtInfo.bitOpLinkdCid = VOS_TRUE;
            stPdpCxtInfo.ucLinkdCid    = (VOS_UINT8)gastAtParaList[1].ulParaValue;

            if (stPdpCxtInfo.ucCid == stPdpCxtInfo.ucLinkdCid)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
        else
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<d_comp> */
        if ( gastAtParaList[2].usParaLen != 0 )
        {
            stPdpCxtInfo.bitOpPdpDcomp  = VOS_TRUE;
            stPdpCxtInfo.enPdpDcomp     = (VOS_UINT8)gastAtParaList[2].ulParaValue;
        }

        /* 设置<h_comp> */
        if ( gastAtParaList[3].usParaLen != 0 )
        {
            stPdpCxtInfo.bitOpPdpHcomp  = VOS_TRUE;
            stPdpCxtInfo.enPdpHcomp     = (VOS_UINT8)gastAtParaList[3].ulParaValue;
        }
        /* 设置<IM_CN_Signalling_Flag_Ind> */
        if ( gastAtParaList[4].usParaLen != 0 )
        {
            stPdpCxtInfo.bitOpImCnSignalFlg = VOS_TRUE;
            stPdpCxtInfo.enImCnSignalFlg    = (VOS_UINT8)gastAtParaList[4].ulParaValue;
        }
    }

    /* 执行命令操作 */
    if ( TAF_PS_SetSecPdpContextInfo(WUEPS_PID_AT,
                                     AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                     0,
                                     &stPdpCxtInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGDSCONT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqreqPara(TAF_UINT8 ucIndex)
{
    TAF_UMTS_QOS_EXT_STRU               stUmtsQosInfo;

    /* 初始化 */
    memset_s(&stUmtsQosInfo, sizeof(stUmtsQosInfo), 0x00, sizeof(TAF_UMTS_QOS_EXT_STRU));

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 15 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    stUmtsQosInfo.ucCid                     = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stUmtsQosInfo.ucDefined             = VOS_FALSE;
    }
    else
    {
        stUmtsQosInfo.ucDefined             = VOS_TRUE;

        /* 设置<Traffic class> */
        if ( gastAtParaList[1].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpTrafficClass = VOS_TRUE;
            stUmtsQosInfo.ucTrafficClass    = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        }

        /* 设置<Maximum bitrate UL> */
        if ( gastAtParaList[2].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpMaxBitUl     = VOS_TRUE;
            stUmtsQosInfo.ulMaxBitUl        = gastAtParaList[2].ulParaValue;
        }

        /* 设置<Maximum bitrate DL> */
        if ( gastAtParaList[3].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpMaxBitDl     = VOS_TRUE;
            stUmtsQosInfo.ulMaxBitDl        = gastAtParaList[3].ulParaValue;
        }

        /* 设置<Guaranteed bitrate UL> */
        if ( gastAtParaList[4].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpGtdBitUl     = VOS_TRUE;
            stUmtsQosInfo.ulGtdBitUl        = gastAtParaList[4].ulParaValue;
        }

        /* 设置<Guaranteed bitrate DL> */
        if ( gastAtParaList[5].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpGtdBitDl     = VOS_TRUE;
            stUmtsQosInfo.ulGtdBitDl        = gastAtParaList[5].ulParaValue;
        }

        /* 设置<Delivery order> */
        if ( gastAtParaList[6].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpDeliverOrder = VOS_TRUE;
            stUmtsQosInfo.ucDeliverOrder    = (VOS_UINT8)gastAtParaList[6].ulParaValue;
        }

        /* 设置<Maximum SDU size> */
        if ( gastAtParaList[7].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpMaxSduSize   = VOS_TRUE;
            stUmtsQosInfo.usMaxSduSize      = (VOS_UINT16)gastAtParaList[7].ulParaValue;
        }

        /* 设置<SDU error ratio> */
        if ( gastAtParaList[8].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpSduErrRatio  = VOS_TRUE;
            stUmtsQosInfo.ucSduErrRatio     = (VOS_UINT8)gastAtParaList[8].ulParaValue;
        }

        /* 设置<Residual bit error ratio> */
        if ( gastAtParaList[9].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpResidualBer  = VOS_TRUE;
            stUmtsQosInfo.ucResidualBer     = (VOS_UINT8)gastAtParaList[9].ulParaValue;
        }

        /* 设置<Delivery of erroneous SDUs> */
        if ( gastAtParaList[10].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpDeliverErrSdu = VOS_TRUE;
            stUmtsQosInfo.ucDeliverErrSdu    = (VOS_UINT8)gastAtParaList[10].ulParaValue;
        }

        /* 设置<Transfer delay> */
        if ( gastAtParaList[11].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpTransDelay   = VOS_TRUE;
            stUmtsQosInfo.usTransDelay      = (VOS_UINT16)gastAtParaList[11].ulParaValue;
        }

        /* 设置<Traffic handling priority> */
        if ( gastAtParaList[12].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpTraffHandlePrior = VOS_TRUE;
            stUmtsQosInfo.ucTraffHandlePrior    = (VOS_UINT8)gastAtParaList[12].ulParaValue;
        }

        /* 设置<Source Statistics Descriptor> */
        if ( gastAtParaList[13].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpSrcStatisticsDes = VOS_TRUE;
            stUmtsQosInfo.ucSrcStatisticsDes    = (VOS_UINT8)gastAtParaList[13].ulParaValue;
        }

        /* 设置<Signalling Indication> */
        if ( gastAtParaList[14].usParaLen != 0 )
        {
            stUmtsQosInfo.bitOpSignalIndication = VOS_TRUE;
            stUmtsQosInfo.ucSignalIndication    = (VOS_UINT8)gastAtParaList[14].ulParaValue;
        }
    }

    /* 执行命令操作 */
    if(g_stParseContext[ucIndex].pstCmdElement->ulCmdIndex == AT_CMD_CGEQREQ)
    {
        if ( TAF_PS_SetUmtsQosInfo(WUEPS_PID_AT,
                                   AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                   0, &stUmtsQosInfo) != VOS_OK )
        {
            return AT_ERROR;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_CGEQREQ_SET;
    }
    else
    {
        if ( TAF_PS_SetUmtsQosMinInfo(WUEPS_PID_AT,
                                      AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                      0, &stUmtsQosInfo) != VOS_OK )
        {
            return AT_ERROR;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_CGEQMIN_SET;

    }

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqminPara(TAF_UINT8 ucIndex)
{
    return AT_SetCgeqreqPara(ucIndex);
}


TAF_UINT32 AT_SetCgpaddrPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCidIndex;
    TAF_CID_LIST_STRU                   stCidListInfo;
    VOS_UINT32                          ulIndex;

    /* 初始化 */
    ulCidIndex  = 0;
    memset_s(&stCidListInfo, sizeof(stCidListInfo), 0x00, sizeof(TAF_CID_LIST_STRU));

    /* 参数过多 */
    if ( gucAtParaIndex > TAF_MAX_CID )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)
    ulIndex = AT_MAX_PARA_NUMBER;
#else
    ulIndex = TAF_MAX_CID;
#endif

    /* 参数设置 */
    if ( gucAtParaIndex != 0 )
    {
        for ( i = 0; i < ulIndex; i++ )
        {
            if ( gastAtParaList[i].usParaLen == 0 )
            {
                break;
            }
            else
            {
                ulCidIndex = gastAtParaList[i].ulParaValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            stCidListInfo.aucCid[ulCidIndex] = 1;
        }
    }
    else
    {
        for ( i = 1; i <= TAF_MAX_CID; i++ )
        {
            stCidListInfo.aucCid[i] = 1;
        }
    }

    /* 执行命令操作 */
    if ( TAF_PS_GetPdpIpAddrInfo(WUEPS_PID_AT,
                                 AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                 0, &stCidListInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGPADDR_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqnegPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCidIndex;
    TAF_CID_LIST_STRU                   stCidListInfo;
    VOS_UINT32                          ulIndex;

    /* 初始化 */
    ulCidIndex  = 0;
    memset_s(&stCidListInfo, sizeof(stCidListInfo), 0x00, sizeof(TAF_CID_LIST_STRU));

    /* 参数过多 */
    if ( gucAtParaIndex > TAF_MAX_CID )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)
    ulIndex = AT_MAX_PARA_NUMBER;
#else
    ulIndex = TAF_MAX_CID;
#endif

    /* 参数设置 */
    /* +CGEQNEG[=<cid>[,<cid>[,...]]] */
    if ( gucAtParaIndex != 0 )
    {
        for ( i = 0; i < ulIndex; i++ )
        {
            if ( gastAtParaList[i].usParaLen == 0 )
            {
                break;
            }
            else
            {
                ulCidIndex = gastAtParaList[i].ulParaValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            stCidListInfo.aucCid[ulCidIndex] = 1;
        }
    }
    else
    {
        for ( i = 1; i <= TAF_MAX_CID; i++ )
        {
            stCidListInfo.aucCid[i] = 1;
        }
    }

    /* 执行命令操作 */
    if ( TAF_PS_GetDynamicUmtsQosInfo(WUEPS_PID_AT,
                                      AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                      0,
                                      &stCidListInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGEQNEG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgcmodPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCidIndex;
    TAF_CID_LIST_STRU                   stCidListInfo;

    /* 初始化 */
    ulCidIndex  = 0;
    memset_s(&stCidListInfo, sizeof(stCidListInfo), 0x00, sizeof(TAF_CID_LIST_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    if ( gucAtParaIndex != 0 )
    {
        for ( i = 0; i < AT_MAX_PARA_NUMBER; i++ )
        {
            if ( gastAtParaList[i].usParaLen == 0 )
            {
                break;
            }
            else
            {
                ulCidIndex = gastAtParaList[i].ulParaValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            stCidListInfo.aucCid[ulCidIndex] = VOS_TRUE;
        }
    }

    /* 执行命令操作 */
    if ( TAF_PS_CallModify(WUEPS_PID_AT,
                           AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                           0,
                           &stCidListInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCMOD_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgactPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCidIndex;
    TAF_CID_LIST_STATE_STRU             stCidListStateInfo;

    /* 初始化 */
    ulCidIndex  = 0;
    memset_s(&stCidListStateInfo, sizeof(stCidListStateInfo), 0x00, sizeof(TAF_CID_LIST_STATE_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    stCidListStateInfo.ucState  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    for ( i = 0; i < (AT_MAX_PARA_NUMBER - 1); i++ )
    {
        if ( gastAtParaList[i + 1UL].usParaLen == 0 )
        {
            break;
        }
        else
        {
            ulCidIndex = gastAtParaList[i + 1UL].ulParaValue;
        }

        /* 以CID作为下标, 标记对应的CID */
        stCidListStateInfo.aucCid[ulCidIndex] = 1;
    }

    /* 执行命令操作 */
    if ( TAF_PS_SetPdpContextState(WUEPS_PID_AT,
                                   AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                   0,
                                   &stCidListStateInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    if ( stCidListStateInfo.ucState == 1 )
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGACT_ORG_SET;
    }
    else
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGACT_END_SET;
    }

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgansPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           ucRspType;
    TAF_PS_ANSWER_STRU                  stAnsInfo;

    /* 初始化 */
    memset_s(&stAnsInfo, sizeof(stAnsInfo), 0x00, sizeof(TAF_PS_ANSWER_STRU));

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 3 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    ucRspType           = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 设置<CID> */
    if ( gastAtParaList[2].usParaLen != 0 )
    {
        stAnsInfo.ucCid = (VOS_UINT8)gastAtParaList[2].ulParaValue;
    }

    /* 填充ans扩展标志 */
    if (g_stParseContext[ucIndex].pstCmdElement->ulCmdIndex == AT_CMD_CGANS_EXT)
    {
        stAnsInfo.ucAnsExtFlg = VOS_TRUE;
    }
    else
    {
        stAnsInfo.ucAnsExtFlg = VOS_FALSE;
    }

    /* 执行命令操作 */
    if ( ucRspType == 1 )
    {
        if ( TAF_PS_CallAnswer(WUEPS_PID_AT,
                               AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                               0,
                               &stAnsInfo) == VOS_OK )
        {
            /* 设置当前操作类型 */
            if (g_stParseContext[ucIndex].pstCmdElement->ulCmdIndex == AT_CMD_CGANS_EXT)
            {
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGANS_ANS_EXT_SET;
            }
            else
            {
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGANS_ANS_SET;
            }

            /* 返回命令处理挂起状态 */
            return AT_WAIT_ASYNC_RETURN;
        }
        else
        {
            return AT_ERROR;
        }
    }
    else
    {
        /* 0 --  拒绝网络发起的激活指示 */
        if ( TAF_PS_CallHangup(WUEPS_PID_AT,
                               AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                               0) == VOS_OK )
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGANS_ANS_SET;

            /* 返回命令处理挂起状态 */
            return AT_WAIT_ASYNC_RETURN;
        }
        else
        {
            return AT_ERROR;
        }
    }
}


VOS_UINT32 AT_CountSpecCharInString(
    VOS_UINT8                          *pucData,
    VOS_UINT16                          usLen,
    VOS_UINT8                           ucChar
)
{
    VOS_UINT8                          *pucRead = VOS_NULL_PTR;
    VOS_UINT32                          ulChkLen;
    VOS_UINT32                          ulCount;

    if(pucData == VOS_NULL_PTR)
    {
        return 0;
    }

    pucRead                             = pucData;
    ulChkLen                            = 0;
    ulCount                             = 0;

    /* 检查 */
    while( ulChkLen++ < usLen )
    {
        if(ucChar == *pucRead)
        {
            ulCount++;
        }
        pucRead++;
    }

    return ulCount;

}


VOS_UINT32 AT_FillTftIpv4Addr(
    VOS_UINT8                          *pucData,
    VOS_UINT16                          usLen,
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulCount;
    VOS_UINT32                          ulRet;
    VOS_CHAR                           *ptrTmp = VOS_NULL_PTR;

    ulCount = 0;
    ptrTmp  = VOS_NULL_PTR;

    ulCount = AT_CountDigit(pucData, usLen, '.', 7);
    if ((ulCount == 0) || (pucData[ulCount] == 0))
    {
        return AT_FAILURE;
    }

    ulCount = AT_CountDigit(pucData, usLen, '.', 4);

    pstTftInfo->bitOpSrcIp = VOS_TRUE;
    pstTftInfo->stSourceIpaddr.enPdpType = TAF_PDP_IPV4;
    pstTftInfo->stSourceIpMask.enPdpType = TAF_PDP_IPV4;

    if ((usLen - ulCount) > TAF_MAX_IPV4_ADDR_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(pucData[ulCount]);

    ulRet = AT_Ipv4AddrAtoi(ptrTmp, pstTftInfo->stSourceIpMask.aucIpv4Addr, TAF_IPV4_ADDR_LEN);
    if(ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    if ((ulCount - 1) > TAF_MAX_IPV4_ADDR_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)(pucData);
    ptrTmp[ulCount - 1] = '\0';

    ulRet = AT_Ipv4AddrAtoi(ptrTmp, pstTftInfo->stSourceIpaddr.aucIpv4Addr, TAF_IPV4_ADDR_LEN);
    if (ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    return AT_SUCCESS;

}


VOS_UINT32 AT_FillTftLocalIpv4Addr(
    VOS_UINT8                          *pucData,
    VOS_UINT16                          usLen,
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulCount;
    VOS_UINT32                          ulRet;
    VOS_CHAR                           *ptrTmp = VOS_NULL_PTR;

    ulCount = 0;
    ptrTmp  = VOS_NULL_PTR;

    ulCount = AT_CountDigit(pucData, usLen, '.', 7);
    if ((ulCount == 0) || (pucData[ulCount] == 0))
    {
        return AT_FAILURE;
    }

    ulCount = AT_CountDigit(pucData, usLen, '.', 4);

    pstTftInfo->bitOpLocalIpv4AddrAndMask= VOS_TRUE;

    if ((usLen - ulCount) > TAF_MAX_IPV4_ADDR_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(pucData[ulCount]);

    ulRet = AT_Ipv4AddrAtoi(ptrTmp, pstTftInfo->aucLocalIpv4Mask, TAF_IPV4_ADDR_LEN);
    if(ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    if ((ulCount - 1) > TAF_MAX_IPV4_ADDR_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)(pucData);
    ptrTmp[ulCount - 1] = '\0';

    ulRet = AT_Ipv4AddrAtoi(ptrTmp, pstTftInfo->aucLocalIpv4Addr, TAF_IPV4_ADDR_LEN);
    if (ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    return AT_SUCCESS;

}


VOS_UINT32 AT_FillTftIpv6Addr(
    VOS_UINT8                          *pucData,
    VOS_UINT16                          usLen,
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulCount;
    VOS_UINT32                          ulRet;
    VOS_CHAR                           *ptrTmp = VOS_NULL_PTR;

    ulCount = 0;
    ptrTmp  = VOS_NULL_PTR;

    ulCount = AT_CountDigit(pucData, usLen, '.', 31);
    if ((ulCount == 0) || (pucData[ulCount] == 0))
    {
        return AT_FAILURE;
    }

    ulCount = AT_CountDigit(pucData, usLen, '.', 16);

    pstTftInfo->bitOpSrcIp = VOS_TRUE;
    pstTftInfo->stSourceIpaddr.enPdpType = TAF_PDP_IPV6;
    pstTftInfo->stSourceIpMask.enPdpType = TAF_PDP_IPV6;

    if ((usLen - ulCount) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(pucData[ulCount]);

    ulRet = AT_Ipv6AddrAtoi(ptrTmp, pstTftInfo->stSourceIpMask.aucIpv6Addr, TAF_IPV6_ADDR_LEN);
    if(ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    if ((ulCount - 1) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)(pucData);
    ptrTmp[ulCount - 1] = '\0';

    ulRet = AT_Ipv6AddrAtoi(ptrTmp, pstTftInfo->stSourceIpaddr.aucIpv6Addr, TAF_IPV6_ADDR_LEN);
    if (ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftLocalIpv6Addr(
    VOS_UINT8                          *pucData,
    VOS_UINT16                          usLen,
    TAF_TFT_EXT_STRU                   *pstTftInfo
)
{
    VOS_UINT32                          ulCount;
    VOS_UINT32                          ulRet;
    VOS_CHAR                           *ptrTmp = VOS_NULL_PTR;
    VOS_UINT8                           aucLocalIpv6Mask[APP_MAX_IPV6_ADDR_LEN];

    ulCount = 0;
    ptrTmp  = VOS_NULL_PTR;
    memset_s(aucLocalIpv6Mask, sizeof(aucLocalIpv6Mask), 0x00, sizeof(aucLocalIpv6Mask));

    ulCount = AT_CountDigit(pucData, usLen, '.', 31);
    if ((ulCount == 0) || (pucData[ulCount] == 0))
    {
        return AT_FAILURE;
    }

    ulCount = AT_CountDigit(pucData, usLen, '.', 16);

    pstTftInfo->bitOpLocalIpv6AddrAndMask = VOS_TRUE;

    if ((usLen - ulCount) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(pucData[ulCount]);

    ulRet = AT_Ipv6AddrAtoi(ptrTmp, aucLocalIpv6Mask, sizeof(aucLocalIpv6Mask));

    if(ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    pstTftInfo->ucLocalIpv6Prefix = AT_CalcIpv6PrefixLength(aucLocalIpv6Mask, sizeof(aucLocalIpv6Mask));

    if ((ulCount - 1) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN)
    {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)(pucData);
    ptrTmp[ulCount - 1] = '\0';

    ulRet = AT_Ipv6AddrAtoi(ptrTmp, pstTftInfo->aucLocalIpv6Addr, TAF_IPV6_ADDR_LEN);
    if (ulRet != VOS_OK)
    {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftIpAddr(
    VOS_UINT8                          *pData,
    VOS_UINT16                          usLen,
    TAF_TFT_EXT_STRU                   *pstTftInfo,
    VOS_UINT8                           ucIpAddrType
)
{
    VOS_UINT32                          ulCount;

    /* 获取输入的IP地址中包含的'.'的个数 */
    ulCount = AT_CountSpecCharInString(pData, usLen, '.');

    /* 如果输入为IPV4地址，地址加掩码会有7个'.' */
    /* 例如"10.140.23.144.255.255.255.0"，前4个是IPV4地址，后4个为掩码 */
    if ((TAF_IPV4_ADDR_LEN * 2 - 1) == ulCount)
    {
        if (ucIpAddrType == AT_IP_ADDR_TYPE_SOURCE)
        {
            return (AT_FillTftIpv4Addr(pData, usLen, pstTftInfo));
        }

        if (ucIpAddrType == AT_IP_ADDR_TYPE_LOCAL)
        {
            return (AT_FillTftLocalIpv4Addr(pData, usLen, pstTftInfo));
        }
    }
    /* 如果输入为IPV6地址，地址加掩码会有31个'.' */
    /* 例如"32.8.0.2.0.2.0.1.0.2.0.1.0.3.21.111.255.255.255.255.255.255.255.255.255.255.255.255.255.255.255.255" */
    /* 前16个为IPV6地址，后16个为掩码 */
    else if ((AT_GetIpv6Capability() != AT_IPV6_CAPABILITY_IPV4_ONLY)
           && ((TAF_IPV6_ADDR_LEN * 2 - 1) == ulCount))
    {
        if (ucIpAddrType == AT_IP_ADDR_TYPE_SOURCE)
        {
            return (AT_FillTftIpv6Addr(pData, usLen, pstTftInfo));
        }

        if (ucIpAddrType == AT_IP_ADDR_TYPE_LOCAL)
        {
            return (AT_FillTftLocalIpv6Addr(pData, usLen, pstTftInfo));
        }
    }
    else
    {
        return AT_FAILURE;
    }

    return AT_FAILURE;
}


TAF_UINT32 AT_SetCgtftPara(TAF_UINT8 ucIndex)
{
    TAF_TFT_EXT_STRU                    stTftInfo;
    VOS_UINT32                          ulRet;

    /* 初始化 */
    memset_s(&stTftInfo, sizeof(stTftInfo), 0x00, sizeof(TAF_TFT_EXT_STRU));

    /* 如果没有cid，则返回失败 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多,<flow label (ipv6)>不支持，<direction>也不再检查 */
    ulRet = AT_CheckCgtftParaNum(gucAtParaIndex);
    if (ulRet == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    stTftInfo.ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stTftInfo.ucDefined             = VOS_FALSE;
    }
    else
    {
        stTftInfo.ucDefined             = VOS_TRUE;

        /* 设置<packet filter identifier> */
        AT_SetTftPfIdPara(&stTftInfo);

        /* 设置<evaluation precedence index> */
        AT_SetTftPrecedencePara(&stTftInfo);

        /* 设置<source address and subnet mask> */
        if ( gastAtParaList[3].usParaLen != 0 )
        {
            ulRet = AT_FillTftIpAddr(gastAtParaList[3].aucPara,
                                     gastAtParaList[3].usParaLen,
                                     &stTftInfo, AT_IP_ADDR_TYPE_SOURCE);
            if (ulRet == AT_FAILURE)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        /* 设置<protocol number (ipv4) / next header (ipv6)> */
        AT_SetTftProtocolIdPara(&stTftInfo);

        /* 设置<destination port range> */
        ulRet = AT_SetDestPortRangePara(&stTftInfo);
        if (ulRet == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<source port range> */
        ulRet = AT_SetSrcPortRangePara(&stTftInfo);
        if (ulRet == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<ipsec security parameter index (spi)> */
        ulRet = AT_SetTftSecuPara(&stTftInfo);
        if (ulRet == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<type of service (tos) (ipv4) and mask / traffic class (ipv6) and mask> */
        ulRet = AT_SetTftTosPara(&stTftInfo);
        if (ulRet == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* <flow label (ipv6)> */
        AT_SetTftFlowLablePara(&stTftInfo);

        /* <direction> */
        AT_SetTftDirectionPara(&stTftInfo);

        if (AT_IsSupportReleaseRst(AT_ACCESS_STRATUM_REL11))
        {
            /* 设置<local address and subnet mask> */
            if ( gastAtParaList[11].usParaLen != 0 )
            {
                ulRet = AT_FillTftIpAddr(gastAtParaList[11].aucPara,
                                         gastAtParaList[11].usParaLen,
                                         &stTftInfo, AT_IP_ADDR_TYPE_LOCAL);
                if (ulRet == AT_FAILURE)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
            }

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
            /* <qri> */
            AT_SetTftQriPara(&stTftInfo);
#endif

        }

    }

    if ( TAF_PS_SetTftInfo(WUEPS_PID_AT,
                           AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                           0,
                           &stTftInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGTFT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgdnsPara(TAF_UINT8 ucIndex)
{
    TAF_PDP_DNS_EXT_STRU                stPdpDnsInfo;

    VOS_UINT8                           aucTempIpv4Addr[TAF_IPV4_ADDR_LEN];
    VOS_UINT32                          ulRslt;
    errno_t                             lMemResult;

    /* 初始化 */
    memset_s(&stPdpDnsInfo, sizeof(stPdpDnsInfo), 0x00, sizeof(TAF_PDP_DNS_EXT_STRU));

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 3 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    stPdpDnsInfo.ucCid                  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stPdpDnsInfo.ucDefined          = VOS_FALSE;
    }
    else
    {
        stPdpDnsInfo.ucDefined          = VOS_TRUE;

        /* 设置<PriDns> */
        if ( gastAtParaList[1].usParaLen != 0 )
        {
            /* 如果<PriDns>过长，直接返回错误 */
            if ( gastAtParaList[1].usParaLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1) )
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }


            ulRslt = AT_Ipv4AddrAtoi((VOS_CHAR*)gastAtParaList[1].aucPara,
                &aucTempIpv4Addr[0], TAF_IPV4_ADDR_LEN);

            if ( ulRslt != VOS_OK )
            {
               return AT_CME_INCORRECT_PARAMETERS;
            }


            stPdpDnsInfo.bitOpPrimDnsAddr = VOS_TRUE;
            lMemResult = memcpy_s(stPdpDnsInfo.aucPrimDnsAddr,
                                  sizeof(stPdpDnsInfo.aucPrimDnsAddr),
                                  aucTempIpv4Addr,
                                  TAF_IPV4_ADDR_LEN);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPdpDnsInfo.aucPrimDnsAddr), TAF_IPV4_ADDR_LEN);
        }

        /* 设置<SecDns> */
        if ( gastAtParaList[2].usParaLen != 0 )
        {
            /* 如果<SecDns>过长，直接返回错误 */
            if ( gastAtParaList[2].usParaLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1) )
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }


            /*此处存储的是字符串格式的DNS所以转换出来结果不使用*/
            ulRslt = AT_Ipv4AddrAtoi((VOS_CHAR*)gastAtParaList[2].aucPara,
                &aucTempIpv4Addr[0], TAF_IPV4_ADDR_LEN);

            if ( ulRslt != VOS_OK )
            {
               return AT_CME_INCORRECT_PARAMETERS;
            }


            stPdpDnsInfo.bitOpSecDnsAddr = VOS_TRUE;
            lMemResult = memcpy_s(stPdpDnsInfo.aucSecDnsAddr,
                                  sizeof(stPdpDnsInfo.aucSecDnsAddr),
                                  aucTempIpv4Addr,
                                  TAF_IPV4_ADDR_LEN);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPdpDnsInfo.aucSecDnsAddr), TAF_IPV4_ADDR_LEN);
        }
    }

    /* 执行命令操作 */
    if ( TAF_PS_SetPdpDnsInfo(WUEPS_PID_AT,
                              AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                              0, &stPdpDnsInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGDNS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgautoPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulAnsMode;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<n> */
    ulAnsMode = gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    if ( TAF_PS_SetAnsModeInfo(WUEPS_PID_AT,
                               AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                               0,
                               ulAnsMode) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGAUTO_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 AT_SetC5gqosPara(VOS_UINT8 ucIndex)
{
    TAF_5G_QOS_EXT_STRU                 st5QosInfo;

    memset_s(&st5QosInfo, sizeof(st5QosInfo), 0x00, sizeof(TAF_5G_QOS_EXT_STRU));

    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gucAtParaIndex > 6 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    st5QosInfo.ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        st5QosInfo.ucDefined             = VOS_FALSE;
    }
    else
    {
        st5QosInfo.ucDefined             = VOS_TRUE;
        if ( gastAtParaList[1].usParaLen != 0 )
        {
            st5QosInfo.bitOp5QI         = 1;
            st5QosInfo.uc5QI            = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        }

        if ( gastAtParaList[2].usParaLen != 0 )
        {
            st5QosInfo.bitOpDLGFBR      = 1;
            st5QosInfo.ulDLGFBR         = gastAtParaList[2].ulParaValue;
        }

        if (gastAtParaList[3].usParaLen != 0 )
        {
            st5QosInfo.bitOpULGFBR      = 1;
            st5QosInfo.ulULGFBR         = gastAtParaList[3].ulParaValue;
        }

        /* ULGFBR和DLGFBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
        if ((st5QosInfo.bitOpDLGFBR ^ st5QosInfo.bitOpULGFBR) == 1)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (gastAtParaList[4].usParaLen != 0 )
        {
            st5QosInfo.bitOpDLMFBR      = 1;
            st5QosInfo.ulDLMFBR         = gastAtParaList[4].ulParaValue;
        }

        if (gastAtParaList[5].usParaLen != 0 )
        {
            st5QosInfo.bitOpULMFBR      = 1;
            st5QosInfo.ulULMFBR         = gastAtParaList[5].ulParaValue;
        }

        /* ULMFBR和DLMFBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
        if ((st5QosInfo.bitOpDLMFBR ^ st5QosInfo.bitOpULMFBR) == 1)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if ( TAF_PS_Set5QosInfo(WUEPS_PID_AT,
                            AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                            0,
                            &st5QosInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_C5GQOS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gqosRdpPara(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT8                           ucCid;

    ucCid = 0;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucCid = 0xff;
    }

    if (TAF_PS_GetDynamic5gQosInfo(WUEPS_PID_AT,
                                   AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                   0,
                                   ucCid) != VOS_OK)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_C5GQOSRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}



VOS_UINT32 AT_SetC5gPNssaiPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_5G_NSSAI_SET_REQ_STRU        preferNssai;
    VOS_UINT32                          ulRslt;

    /* +C5GPNSSAI=[<Preferred_NSSAI_3gpp_length>,[<Preferred_NSSAI_3gpp>]],[<Preferred_NSSAI_non3gpp_length>,[<Preferred_NSSAI_non3gpp>]] */
    /* 初始化 */
    memset_s(&preferNssai, sizeof(preferNssai), 0x00, sizeof(AT_MTA_5G_NSSAI_SET_REQ_STRU));

    preferNssai.enSNssaiSetType = AT_MTA_NSSAI_SET_PREFER_NSSAI;

    if (gucAtParaIndex == 0)
    {
        /* 1个参数也没有，删除Prefer切片信息 */
        preferNssai.st5gNssai.ucSNssaiNum     = 0;
    }
    else if (gucAtParaIndex == 1)
    {
        if (gastAtParaList[0].ulParaValue != 0)
        {
            /* 如果length字段值不为0，但只有length这1个字段，无切片信息，AT格式不合法 */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        preferNssai.st5gNssai.ucSNssaiNum     = 0;
    }
    else if (gucAtParaIndex == 2)
    {
        if (VOS_OK != AT_DecodeMultiSNssaiString((VOS_UINT16)gastAtParaList[0].ulParaValue,
                                                 gastAtParaList[1].aucPara,
                                                 gastAtParaList[1].usParaLen,
                                                &preferNssai.st5gNssai))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (preferNssai.st5gNssai.ucSNssaiNum > PS_MAX_PREFER_S_NSSAI_NUM)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    ID_AT_MTA_5G_NSSAI_SET_REQ,
                                    &preferNssai,
                                    (VOS_SIZE_T)sizeof(preferNssai),
                                    I0_UEPS_PID_MTA);

    if (ulRslt != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetC5gPNssaiPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_C5GPNSSAI_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gNssaiPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_5G_NSSAI_SET_REQ_STRU        defCfgNssai;
    VOS_UINT32                          ulRslt;

    /* +C5GNSSAI=<default_configured_nssai_length>,<default_configured_nssai> */
    /* 初始化 */
    memset_s(&defCfgNssai, sizeof(defCfgNssai), 0x00, sizeof(AT_MTA_5G_NSSAI_SET_REQ_STRU));

    defCfgNssai.enSNssaiSetType = AT_MTA_NSSAI_SET_DEF_CFG_NSSAI;

    if (gucAtParaIndex == 2)
    {
        if (VOS_OK != AT_DecodeMultiSNssaiString((VOS_UINT16)gastAtParaList[0].ulParaValue,
                                                 gastAtParaList[1].aucPara,
                                                 gastAtParaList[1].usParaLen,
                                                &defCfgNssai.st5gNssai))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        /* 参数个数不对 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    ID_AT_MTA_5G_NSSAI_SET_REQ,
                                    &defCfgNssai,
                                    (VOS_SIZE_T)sizeof(defCfgNssai),
                                    I0_UEPS_PID_MTA);

    if (TAF_SUCCESS != ulRslt)
    {
        AT_WARN_LOG("AT_SetC5gNssaiPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_C5GDFTCFGNSSAI_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_ConvertPlmnStrToHex(
    VOS_UINT8                          *pPara,
    VOS_UINT16                          usLen,
    PS_NR_PLMN_ID_STRU                 *pstPlmn
)
{
    VOS_UINT32                          ulTemp;

    ulTemp = 0;

    /* check整个码流中是否有不符合字符，如果有的话直接按照解析失败处理 */
    if(AT_FAILURE == At_String2Hex(pPara, usLen, &ulTemp))
    {
        return AT_ERROR;
    }

    /* MCC digit1 */
    At_String2Hex(&pPara[0], 1, &ulTemp);

    pstPlmn->aucPlmnId[0] = (VOS_UINT8)ulTemp;

    /* MCC digit2 */
    At_String2Hex(&pPara[1], 1, &ulTemp);

    pstPlmn->aucPlmnId[0] |= ((VOS_UINT8)(ulTemp << 4));

    /* MCC digit3 */
    At_String2Hex(&pPara[2], 1, &ulTemp);

    pstPlmn->aucPlmnId[1] = (VOS_UINT8)ulTemp;

    /* MNC digit1 */
    At_String2Hex(&pPara[3], 1, &ulTemp);

    pstPlmn->aucPlmnId[2] = (VOS_UINT8)ulTemp;

    /* MNC digit2 */
    At_String2Hex(&pPara[4], 1, &ulTemp);

    pstPlmn->aucPlmnId[2] |= ((VOS_UINT8)(ulTemp << 4));

    if (usLen == 6)
    {
        /* MNC digit2 */
        At_String2Hex(&pPara[5], 1, &ulTemp);

        pstPlmn->aucPlmnId[1] |=  ((VOS_UINT8)(ulTemp << 4));
    }
    else
    {
        pstPlmn->aucPlmnId[1] |=  0xf0;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetC5gNssaiRdpPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_5G_NSSAI_QRY_REQ_STRU        st5gNssaiQryReq;
    PS_NR_PLMN_ID_STRU                  stPlmn;
    VOS_UINT32                          ulRslt;

    /* +C5GNSSAIRDP[=<nssai_type>[,<plmn_id>]] */
    /* 初始化 */
    memset_s(&st5gNssaiQryReq, sizeof(st5gNssaiQryReq), 0x00, sizeof(AT_MTA_5G_NSSAI_QRY_REQ_STRU));
    memset_s(&stPlmn, sizeof(stPlmn), 0x00, sizeof(PS_NR_PLMN_ID_STRU));

    if (gucAtParaIndex == 0)
    {
        st5gNssaiQryReq.enSNssaiQryType = AT_MTA_NSSAI_QRY_DEF_CFG_AND_REJ_AND_CFG_AND_ALLOWED_NSSAI;
        st5gNssaiQryReq.bitOpPlmn       = VOS_FALSE;
    }
    else if (gucAtParaIndex == 1)
    {
        st5gNssaiQryReq.enSNssaiQryType = gastAtParaList[0].ulParaValue;
        st5gNssaiQryReq.bitOpPlmn       = VOS_FALSE;
    }
    else if (gucAtParaIndex == 2)
    {
        st5gNssaiQryReq.enSNssaiQryType = gastAtParaList[0].ulParaValue;

        /* PLMN为5个或者6个digit */
        if ((gastAtParaList[1].usParaLen > 6)
         || (gastAtParaList[1].usParaLen < 5))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (AT_ConvertPlmnStrToHex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &stPlmn) != AT_OK)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        st5gNssaiQryReq.bitOpPlmn = VOS_TRUE;
        st5gNssaiQryReq.stPlmn    = stPlmn;
    }
    else
    {
        /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    ID_AT_MTA_5G_NSSAI_QRY_REQ,
                                    &st5gNssaiQryReq,
                                    (VOS_SIZE_T)sizeof(st5gNssaiQryReq),
                                    I0_UEPS_PID_MTA);

    if (TAF_SUCCESS != ulRslt)
    {
        AT_WARN_LOG("AT_SetC5gNssaiRdpPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_C5GNSSAIRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCsUePolicy(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulAllocLen;
    TAF_PS_5G_UE_POLICY_INFO_STRU      *pstUePolicyInfo = VOS_NULL_PTR;

    /* +CSUEPOLICY=<message_type>[,<UE_policy_information_length>,<UE_policy_information>[,<UE_policy_classmark>]] */
    /* 参数个数不合法 */
    if ((gucAtParaIndex > 4)
     || (gucAtParaIndex < 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不可能为2 */
    if (gucAtParaIndex == 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex >= 3)
    {
        /* 判断AT命令中的Length与实际码流的长度是否一致 */
        if (gastAtParaList[1].ulParaValue != gastAtParaList[2].usParaLen)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (gastAtParaList[2].usParaLen > AT_UE_POLICY_RSP_MAX_LEN)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulAllocLen = sizeof(TAF_PS_5G_UE_POLICY_INFO_STRU) + gastAtParaList[2].usParaLen / 2;
    }
    else
    {
        ulAllocLen = sizeof(TAF_PS_5G_UE_POLICY_INFO_STRU);
    }

    pstUePolicyInfo = (TAF_PS_5G_UE_POLICY_INFO_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, ulAllocLen);

    if (pstUePolicyInfo == VOS_NULL_PTR)
    {
        return AT_CME_MEMORY_FAILURE;
    }

    /* 赋初值 */
    memset_s(pstUePolicyInfo, ulAllocLen, 0x00, ulAllocLen);

    /* 第1个参数是必选参数 */
    pstUePolicyInfo->enUePolicyMsgType = (TAF_PS_POLICY_MSG_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    if (gucAtParaIndex >= 3)
    {
        pstUePolicyInfo->usLength   = gastAtParaList[2].usParaLen / 2;

        if (AT_SUCCESS != At_AsciiString2HexSimple(pstUePolicyInfo->aucContent,
                                                   gastAtParaList[2].aucPara,
                                                   (VOS_UINT16)gastAtParaList[2].usParaLen))
        {
            PS_MEM_FREE(WUEPS_PID_AT, pstUePolicyInfo);

            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 存在第4个参数 */
        if (gucAtParaIndex == 4)
        {
            pstUePolicyInfo->ucClassMarkLen = (VOS_UINT8)gastAtParaList[3].usParaLen / 2;

            if (pstUePolicyInfo->ucClassMarkLen > TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN)
            {
                PS_MEM_FREE(WUEPS_PID_AT, pstUePolicyInfo);

                return AT_CME_INCORRECT_PARAMETERS;
            }

            if (AT_SUCCESS != At_AsciiString2HexSimple(pstUePolicyInfo->aucClassMark,
                                                       gastAtParaList[3].aucPara,
                                                       (VOS_UINT16)gastAtParaList[3].usParaLen))
            {
                PS_MEM_FREE(WUEPS_PID_AT, pstUePolicyInfo);

                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
    }

    /* 调用DSM提供的设置接口 */
    if (TAF_PS_SetCsUePolicy(WUEPS_PID_AT,
                             AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                             0,
                             pstUePolicyInfo) != VOS_OK)
    {
        PS_MEM_FREE(WUEPS_PID_AT, pstUePolicyInfo);

        return AT_ERROR;
    }

    PS_MEM_FREE(WUEPS_PID_AT, pstUePolicyInfo);

    return AT_OK;
}

#endif


VOS_UINT32 AT_SetMcsPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;
    VOS_UINT32                          ulResult;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    pstNetCtx->ucMcsDirection = (AT_MCS_DIRECTION_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_MCS_SET_REQ,
                                      VOS_NULL_PTR,
                                      0,
                                      I0_UEPS_PID_MTA);

    if (ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MCS_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetRrcStatPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU stAtCmd;
    VOS_UINT32                          ulResult;

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stAtCmd.u.ucRrcStatRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stAtCmd.enReqType         = AT_MTA_SET_RRCSTAT_RPT_TYPE;

    /* 给MTA发送^RRCSTAT设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}


VOS_UINT32 AT_SetHfreqInfoPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU stAtCmd;
    VOS_UINT32                          ulResult;

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    stAtCmd.u.ucHfreqInfoRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stAtCmd.enReqType           = AT_MTA_SET_HFREQINFO_RPT_TYPE;

    /* 给MTA发送^HFREQINFO设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

VOS_UINT32 atSetCgeqosPara(VOS_UINT8 ucIndex)
{
    TAF_EPS_QOS_EXT_STRU                stEpsQosInfo;

    memset_s(&stEpsQosInfo, sizeof(stEpsQosInfo), 0x00, sizeof(TAF_EPS_QOS_EXT_STRU));

    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gucAtParaIndex > 6 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stEpsQosInfo.ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    if ( gastAtParaList[1].usParaLen != 0 )
    {
        stEpsQosInfo.bitOpQCI   = 1;
        stEpsQosInfo.ucQCI      = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }

    if ( gastAtParaList[2].usParaLen != 0 )
    {
        stEpsQosInfo.bitOpDLGBR = 1;
        stEpsQosInfo.ulDLGBR    = gastAtParaList[2].ulParaValue;
    }

    if (gastAtParaList[3].usParaLen != 0 )
    {
        stEpsQosInfo.bitOpULGBR = 1;
        stEpsQosInfo.ulULGBR    = gastAtParaList[3].ulParaValue;
    }

    if (gastAtParaList[4].usParaLen != 0 )
    {
        stEpsQosInfo.bitOpDLMBR = 1;
        stEpsQosInfo.ulDLMBR= gastAtParaList[4].ulParaValue;
    }

    if (gastAtParaList[5].usParaLen != 0 )
    {
        stEpsQosInfo.bitOpULMBR = 1;
        stEpsQosInfo.ulULMBR    = gastAtParaList[5].ulParaValue;
    }

    if ( TAF_PS_SetEpsQosInfo(WUEPS_PID_AT,
                              AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                              0,
                              &stEpsQosInfo) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGEQOS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 atQryCgeqosPara(VOS_UINT8 ucIndex)
{
    if( TAF_PS_GetEpsQosInfo(WUEPS_PID_AT,
                             AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                             0) != VOS_OK)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGEQOS_READ;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}



VOS_UINT32 atSetCgeqosrdpPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucCid;

    ucCid     = 0;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucCid = 0xff;
    }

    if ( TAF_PS_GetDynamicEpsQosInfo(WUEPS_PID_AT,
                                     AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                     0,
                                     ucCid) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGEQOSRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 atSetCgcontrdpPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucCid;

    ucCid     = 0;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucCid = 0xff;
    }

    if( TAF_PS_GetDynamicPrimPdpContextInfo(WUEPS_PID_AT,
                                            AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                            0, ucCid) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCONTRDP_SET;

    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */

}


VOS_UINT32 atSetCgscontrdpPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucCid;

    ucCid     = 0;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucCid = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucCid = 0xff;
    }

    if( TAF_PS_GetDynamicSecPdpContextInfo(WUEPS_PID_AT,
                                           AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                           0,
                                           ucCid) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGSCONTRDP_SET;

    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */

}


VOS_UINT32 atSetCgtftrdpPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucCid;

    ucCid       = 0;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucCid = (VOS_UINT8)(gastAtParaList[0].ulParaValue);
    }
    else
    {
        ucCid = 0xff;
    }

    if( TAF_PS_GetDynamicTftInfo(WUEPS_PID_AT,
                                 AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                 0,
                                 ucCid) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGTFTRDP_SET;

    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}


IMM_ZC_STRU *At_CsndBuildUdpPacket(
    const VOS_UINT32                          ulIpAddr,
    const VOS_UINT16                          usLength
)
{
    IMM_ZC_STRU                        *pstImmZc    = VOS_NULL_PTR;
    VOS_UINT8                          *pucData     = VOS_NULL_PTR;
    VOS_UINT32                          ulSrcAddr;
    VOS_UINT32                          ulDestAddr;
    VOS_UINT16                          usDestPort;
    VOS_UINT16                          usSrcPort;
    VOS_UINT16                          usTotalLen;

    usTotalLen  = usLength + AT_IP_HDR_LEN + AT_UDP_HDR_LEN;

    /* 申请跨核零拷贝内存 */
    pstImmZc    = IMM_ZcStaticAlloc(usTotalLen + IMM_MAC_HEADER_RES_LEN);
    if (pstImmZc == VOS_NULL_PTR)
    {
        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcStaticAlloc fail!");
        return VOS_NULL_PTR;
    }

    IMM_ZcReserve(pstImmZc, IMM_MAC_HEADER_RES_LEN);

    ulSrcAddr   = ulIpAddr;
    ulDestAddr  = ulIpAddr + 1;
    usDestPort  = 9600;
    usSrcPort   = 9700;

    pucData     = (VOS_UINT8 *)IMM_ZcPut(pstImmZc, usTotalLen);
    if (pucData == VOS_NULL_PTR)
    {
        IMM_ZcFree(pstImmZc);

        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcPut fail!");

        return VOS_NULL_PTR;
    }

#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON)
    pstImmZc->protocol = htons(ETH_P_IP);/*lint !e778*/
#endif

    /* 构造UDP头 */
    if (AT_BuildUdpHdr((AT_UDP_PACKET_FORMAT_STRU *)pucData,
                       usLength,
                       ulSrcAddr,
                       ulDestAddr,
                       usSrcPort,
                       usDestPort) != VOS_OK)
    {
        IMM_ZcFree(pstImmZc);

        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcPut fail!");

        return VOS_NULL_PTR;
    }

    return pstImmZc;
}

#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON)

VOS_UINT32 At_SetCsndPara(VOS_UINT8 ucIndex)
{
    IMM_ZC_STRU                        *pstImmZc    = VOS_NULL_PTR;
    VOS_UINT32                          ulIpAddr;
    VOS_UINT16                          usLength;
    PS_IFACE_ID_ENUM_UINT8              enIfaceId;

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) ||
        (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enIfaceId   = (PS_IFACE_ID_ENUM_UINT8)gastAtParaList[0].ulParaValue;
    if (enIfaceId >= PS_IFACE_ID_BUTT)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 计算UDP报文长度 */
    usLength    = (VOS_UINT16)gastAtParaList[1].ulParaValue;
    usLength    = (usLength > AT_CSND_PLAYLOAD_MAX_LEN) ? (AT_CSND_PLAYLOAD_MAX_LEN) : usLength;

    ulIpAddr    = AT_PS_GetIpAddrByIfaceId(ucIndex, enIfaceId);

    pstImmZc = At_CsndBuildUdpPacket(ulIpAddr, usLength);

    if (pstImmZc == VOS_NULL_PTR)
    {
        AT_ERR_LOG("At_SetCsndPara: At_CsndBuildUdpPacket fail!");
        return AT_ERROR;
    }

    /* 发送上行数据包 */
    if (ads_iface_tx(enIfaceId, pstImmZc) != VOS_OK)
    {
        AT_ERR_LOG("At_SetCsndPara: ads_iface_tx fail!");
        return AT_ERROR;
    }

    return AT_OK;
}
#else

VOS_UINT32 At_SetCsndPara(VOS_UINT8 ucIndex)
{
    IMM_ZC_STRU                        *pstImmZc = VOS_NULL_PTR;
    VOS_UINT8                           ucRabId;
    VOS_UINT16                          usLength;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulIpAddr;

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* RABID有效性检查[5,15] */
    ucRabId     = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    if (!AT_PS_IS_RABID_VALID(ucRabId))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 计算UDP报文长度 */
    usLength    = (VOS_UINT16)gastAtParaList[1].ulParaValue;
    usLength    = (usLength > AT_CSND_PLAYLOAD_MAX_LEN) ? (AT_CSND_PLAYLOAD_MAX_LEN) : usLength;

    ulIpAddr    = AT_PS_GetIpAddrByRabId(ucIndex, ucRabId);

    pstImmZc = At_CsndBuildUdpPacket(ulIpAddr, usLength);

    if (pstImmZc == VOS_NULL_PTR)
    {
        AT_ERR_LOG("At_SetCsndPara: At_CsndBuildUdpPacket fail!");
        return AT_ERROR;
    }

    enModemId       = MODEM_ID_0;
    if (AT_GetModemIdFromClient(ucIndex, &enModemId) != VOS_OK)
    {
        IMM_ZcFree(pstImmZc);
        AT_ERR_LOG("At_SetCsndPara: Get modem id fail.");
        return AT_ERROR;
    }

    if (enModemId != MODEM_ID_0)
    {
        ucRabId    |= AT_PS_RABID_MODEM_1_MASK;
    }

    /* 发送上行数据包 */
    if (ADS_UL_SendPacket(pstImmZc, ucRabId) != VOS_OK)
    {
        AT_ERR_LOG("At_SetCsndPara: ADS_UL_SendPacket fail!");
        return AT_ERROR;
    }

    return AT_OK;
}
#endif


TAF_UINT32 At_SetCgdataPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulCidIndex;
    TAF_CID_LIST_STATE_STRU             stCidListStateInfo;

    /* 初始化 */
    ulCidIndex  = 0;
    memset_s(&stCidListStateInfo, sizeof(stCidListStateInfo), 0x00, sizeof(TAF_CID_LIST_STATE_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多, 目前最多支持一个CID */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <L2P>不处理 */

    /* 参数设置 */
    stCidListStateInfo.ucState  = 1;

    if (gastAtParaList[1].usParaLen == 0)
    {
        ulCidIndex = 1;
    }
    else
    {
        ulCidIndex = gastAtParaList[1].ulParaValue;
    }

    /* 以CID作为下标, 标记对应的CID */
    stCidListStateInfo.aucCid[ulCidIndex] = 1;


    /* 执行命令操作 */
    if (TAF_PS_SetPdpContextState(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  0,
                                  &stCidListStateInfo) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGDATA_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;

}


TAF_UINT32 At_SetCgattPara(TAF_UINT8 ucIndex)
{
    TAF_MMA_DETACH_PARA_STRU           stDetachPara;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if(gastAtParaList[0].ulParaValue == 0)
    {
        /* 执行Detach操作 */
        memset_s(&stDetachPara, sizeof(stDetachPara), 0x00, sizeof(TAF_MMA_DETACH_PARA_STRU));
        stDetachPara.enDetachCause  = TAF_MMA_DETACH_CAUSE_USER_DETACH;
        stDetachPara.enDetachDomain = TAF_MMA_SERVICE_DOMAIN_PS;

        if (TAF_MMA_DetachReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stDetachPara) == VOS_TRUE)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGATT_DETAACH_SET;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }
    }
    else
    {
        /* 执行Attach操作 */
        if(TAF_MMA_AttachReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, TAF_MMA_ATTACH_TYPE_GPRS) == VOS_TRUE)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGATT_ATTACH_SET;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }
    }
}


TAF_UINT32 At_SetCgcattPara(TAF_UINT8 ucIndex)
{
    TAF_MMA_DETACH_PARA_STRU           stDetachPara;

    TAF_MMA_ATTACH_TYPE_ENUM_UINT8     enAttachType;

    enAttachType                       = TAF_MMA_ATTACH_TYPE_BUTT;

    /* 参数检查 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if(gastAtParaList[0].ulParaValue == 0)
    {
        /* 执行Detach操作 */
        memset_s(&stDetachPara, sizeof(stDetachPara), 0x00, sizeof(TAF_MMA_DETACH_PARA_STRU));
        stDetachPara.enDetachCause  = TAF_MMA_DETACH_CAUSE_USER_DETACH;

        /* 转换用户的DETACH类型 */
        stDetachPara.enDetachDomain = At_ConvertDetachTypeToServiceDomain(gastAtParaList[1].ulParaValue);

        if(TAF_MMA_DetachReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stDetachPara) == VOS_TRUE)
        {
            /* 设置当前操作类型 */
            switch(gastAtParaList[1].ulParaValue)
            {
                case AT_CGCATT_MODE_PS:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_PS_DETAACH_SET;
                break;

                case AT_CGCATT_MODE_CS:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_CS_DETAACH_SET;
                break;

            default:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_PS_CS_DETAACH_SET;
                break;
            }
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }
    }
    else
    {
        /* 转换用户的ATTACH类型 */
        enAttachType    = At_ConvertCgcattModeToAttachType(gastAtParaList[1].ulParaValue);

        /* 执行Attach操作 */
        if(TAF_MMA_AttachReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, enAttachType) == VOS_TRUE)
        {
            /* 设置当前操作类型 */
            switch(gastAtParaList[1].ulParaValue)
            {
                case AT_CGCATT_MODE_PS:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_PS_ATTACH_SET;
                break;

                case AT_CGCATT_MODE_CS:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_CS_ATTACH_SET;
                break;

            default:
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGCATT_PS_CS_ATTACH_SET;
                break;
            }
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }
    }
}
/* Added by s46746 for V7R1 phase II , 2011-10-18, begin */

VOS_VOID At_SetCopsActPara(
    TAF_MMA_RAT_TYPE_ENUM_UINT8        *penPhRat,
    VOS_UINT16                          usParaLen,
    VOS_UINT32                          ulParaValue
)
{
    /* 如果参数长度为0，使用无效值 */
    if (usParaLen == 0)
    {
        *penPhRat = TAF_MMA_RAT_BUTT;

        return;
    }

    /* 根据用户输入的参数值,转换为AT与MMA的接口定义的接入技术参数 */
    if (ulParaValue == AT_COPS_RAT_GSM)
    {
        *penPhRat = TAF_MMA_RAT_GSM;
    }
    else if (ulParaValue == AT_COPS_RAT_WCDMA)
    {
        *penPhRat = TAF_MMA_RAT_WCDMA;
    }
#if (FEATURE_LTE == FEATURE_ON)
    else if (ulParaValue == AT_COPS_RAT_LTE)
    {
        *penPhRat = TAF_MMA_RAT_LTE;
    }
#endif
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    else if (ulParaValue == AT_COPS_RAT_NR)
    {
        *penPhRat = TAF_MMA_RAT_NR;
    }
#endif
    else
    {
        *penPhRat = TAF_MMA_RAT_BUTT;
    }

    return;
}
/* Added by s46746 for V7R1 phase II , 2011-10-18, end */


VOS_UINT32 AT_DigitString2Hex(
    VOS_UINT8                          *pucDigitStr,
    VOS_UINT16                          usLen,
    VOS_UINT32                         *pulDestHex
)
{
    VOS_UINT32                          ulCurrValue;
    VOS_UINT32                          ulTotalVaue;
    VOS_UINT8                           ucLength;

    ulCurrValue     = 0;
    ulTotalVaue     = 0;
    ucLength        = 0;
    ulCurrValue = (VOS_UINT32)*pucDigitStr++;

    while (ucLength++ < usLen)
    {
        if((ulCurrValue  >= '0')
        && (ulCurrValue  <= '9'))
        {
            ulCurrValue  = ulCurrValue  - '0';
        }
        else
        {
            return VOS_FALSE;
        }

        if (ulTotalVaue > 0x0FFFFFFF)              /* 发生反转 */
        {
            return VOS_FALSE;
        }
        else
        {
            ulTotalVaue = (ulTotalVaue << AT_OCTET_MOVE_FOUR_BITS) + ulCurrValue;              /* accumulate digit */
            ulCurrValue = (VOS_UINT32)(VOS_UINT8)*pucDigitStr++;    /* get next Char */
        }
    }

    *pulDestHex = ulTotalVaue;
    return VOS_TRUE;
}


VOS_UINT32 AT_FormatNumericPlmnStr2PlmnId(
    TAF_PLMN_ID_STRU                   *pPlmn,
    VOS_UINT16                          usOprNameLen,
    VOS_CHAR                           *pucOprName
)
{
    if(AT_DigitString2Hex((VOS_UINT8*)pucOprName,AT_MBMS_MCC_LENGTH,&pPlmn->Mcc) == VOS_FALSE)
    {
        return VOS_FALSE;
    }

    if(AT_DigitString2Hex((VOS_UINT8*)&pucOprName[AT_MBMS_MCC_LENGTH],usOprNameLen-AT_MBMS_MNC_MAX_LENGTH,&pPlmn->Mnc) == VOS_FALSE)
    {
        return VOS_FALSE;
    }

    pPlmn->Mcc |= 0xFFFFF000;
    pPlmn->Mnc |= (0xFFFFFFFF << ((usOprNameLen-AT_MBMS_MNC_MAX_LENGTH)*4));

    return VOS_TRUE;
}


#if (FEATURE_CSG == FEATURE_ON)

VOS_UINT32 AT_SetCsgIdSearchPara(VOS_UINT8 ucIndex)
{
    /* 检查输入at命令参数是否合法，合法通知mma */
    TAF_MMA_CSG_SPEC_SEARCH_INFO_STRU   stCsgIdUserSel;
    VOS_UINT32                          ulRatType;

    stCsgIdUserSel.stPlmnId.Mcc = TAF_MMA_INVALID_MCC;
    stCsgIdUserSel.stPlmnId.Mnc = TAF_MMA_INVALID_MNC;
    stCsgIdUserSel.ulCsgId      = TAF_MMA_INVALID_CSG_ID_VALUE;
    stCsgIdUserSel.enRatType    = TAF_MMA_RAT_BUTT;
    ulRatType                   = TAF_MMA_RAT_BUTT;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不是3个 */
    if (gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* @oper长度非法 */
    if ((gastAtParaList[0].usParaLen != 5)
      &&(gastAtParaList[0].usParaLen != 6))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* CSG ID长度非法 */
    if ((gastAtParaList[1].usParaLen == 0)
      ||(gastAtParaList[1].usParaLen > 8))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    if (AT_String2Hex(gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen, &ulRatType) != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 指定的接入技术不为LTE，目前的阶段只支持指定搜LTE的CSG ID，后续如果支持其他接入技术，删除此判断即可 */
    if((ulRatType != AT_COPS_RAT_LTE))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<AcT> */
    At_SetCopsActPara(&stCsgIdUserSel.enRatType, gastAtParaList[2].usParaLen, ulRatType);

    /* 生成PLMN ID */
    if (AT_FormatNumericPlmnStr2PlmnId(&stCsgIdUserSel.stPlmnId,
                                        gastAtParaList[0].usParaLen, (VOS_CHAR*)gastAtParaList[0].aucPara) != VOS_TRUE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 生成CSG ID */
    if (AT_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &stCsgIdUserSel.ulCsgId) != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    if (TAF_MMA_SetCsgIdSearch(WUEPS_PID_AT,
                               gastAtClientTab[ucIndex].usClientId,
                               gastAtClientTab[ucIndex].opId,
                               &stCsgIdUserSel) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSG_SPEC_SEARCH;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;

}
#endif


LOCAL VOS_UINT32 AT_ProcCopsSetMode0(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_CTRL_STRU                   stCtrl;
    TAF_PLMN_USER_SEL_STRU              stPlmnUserSel;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_MMA_CTRL_STRU));
    memset_s(&stPlmnUserSel, sizeof(stPlmnUserSel), 0x00, sizeof(TAF_PLMN_USER_SEL_STRU));

    stCtrl.ulModuleId = WUEPS_PID_AT;
    stCtrl.usClientId = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId     = 0;

    stPlmnUserSel.ucBgSrchFlag          = VOS_FALSE;
    stPlmnUserSel.enSrchType            = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    if(TAF_MMA_PlmnSearchReq(&stCtrl, TAF_MMA_SEARCH_TYPE_AUTO, &stPlmnUserSel) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COPS_SET_AUTOMATIC;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode1(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_CTRL_STRU                   stCtrl;
    TAF_PLMN_USER_SEL_STRU              stPlmnUserSel;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;
    VOS_UINT32                          ulGetOperNameRst;
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enPhRat;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_MMA_CTRL_STRU));
    memset_s(&stPlmnUserSel, sizeof(stPlmnUserSel), 0x00, sizeof(TAF_PLMN_USER_SEL_STRU));

    /* 参数为空 */
    if (gastAtParaList[2].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口信息 */
    stCtrl.ulModuleId = WUEPS_PID_AT;
    stCtrl.usClientId = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId     = 0;

    /* 设置<AcT> */
    At_SetCopsActPara(&enPhRat, gastAtParaList[3].usParaLen, gastAtParaList[3].ulParaValue);

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    stPlmnUserSel.ucFormatType = pstNetCtx->ucCopsFormatType;
    stPlmnUserSel.enAccessMode = enPhRat;

    stPlmnUserSel.ucBgSrchFlag          = VOS_FALSE;
    stPlmnUserSel.enSrchType            = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    /* 根据输入PLMN的类型来保存到TAF_PLMN_USER_SEL_STRU结构中，发送到MMA模块，有MMA进行转换并处理指定搜。 */
    ulGetOperNameRst = AT_GetOperatorNameFromParam(&stPlmnUserSel.usOperNameLen,
                                                    stPlmnUserSel.ucOperName,
                                                    sizeof(stPlmnUserSel.ucOperName),
                                                    stPlmnUserSel.ucFormatType);

    if (ulGetOperNameRst != AT_OK )
    {
        return ulGetOperNameRst;
    }

    if (TAF_MMA_PlmnSearchReq(&stCtrl, TAF_MMA_SEARCH_TYPE_MANUAL, &stPlmnUserSel) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COPS_SET_MANUAL;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode2(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_DETACH_PARA_STRU           stDetachPara;

    memset_s(&stDetachPara, sizeof(stDetachPara), 0x00, sizeof(TAF_MMA_DETACH_PARA_STRU));

    stDetachPara.enDetachCause  = TAF_MMA_DETACH_CAUSE_COPS;

    /* 转换用户的DETACH类型 */
    stDetachPara.enDetachDomain = TAF_MMA_SERVICE_DOMAIN_CS_PS;

    if(TAF_MMA_DetachReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stDetachPara) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COPS_SET_DEREGISTER;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode3(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_COPS_FORMAT_TYPE_SET_REQ_STRU                   stCopsFormatSetReq;

    memset_s(&stCopsFormatSetReq, sizeof(stCopsFormatSetReq), 0x00, sizeof(stCopsFormatSetReq));

    stCopsFormatSetReq.ucCopsFormatType = (VOS_UINT8)gastAtParaList[1].ulParaValue;

    Taf_SetCopsFormatTypeReq(gastAtClientTab[ucIndex].usClientId,
                             gastAtClientTab[ucIndex].opId,
                             &stCopsFormatSetReq);

    return AT_OK;
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode4(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_CTRL_STRU                   stCtrl;
    TAF_PLMN_USER_SEL_STRU              stPlmnUserSel;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;
    VOS_UINT32                          ulGetOperNameRst;
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enPhRat;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_MMA_CTRL_STRU));
    memset_s(&stPlmnUserSel, sizeof(stPlmnUserSel), 0x00, sizeof(TAF_PLMN_USER_SEL_STRU));

    /* 参数为空 */
    if (gastAtParaList[2].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口信息 */
    stCtrl.ulModuleId = WUEPS_PID_AT;
    stCtrl.usClientId = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId     = 0;

    /* 设置<AcT> */
    At_SetCopsActPara(&enPhRat, gastAtParaList[3].usParaLen, gastAtParaList[3].ulParaValue);

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    stPlmnUserSel.ucFormatType = pstNetCtx->ucCopsFormatType;
    stPlmnUserSel.enAccessMode = enPhRat;
    stPlmnUserSel.ucBgSrchFlag          = VOS_FALSE;
    stPlmnUserSel.enSrchType            = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    /* 根据输入PLMN的类型来保存到TAF_PLMN_USER_SEL_STRU结构中，发送到MMA模块，有MMA进行转换并处理指定搜。 */
    ulGetOperNameRst = AT_GetOperatorNameFromParam(&stPlmnUserSel.usOperNameLen,
                                                    stPlmnUserSel.ucOperName,
                                                    sizeof(stPlmnUserSel.ucOperName),
                                                    stPlmnUserSel.ucFormatType);

    if (ulGetOperNameRst != AT_OK )
    {
        return ulGetOperNameRst;
    }

    if (TAF_MMA_PlmnSearchReq(&stCtrl, TAF_MMA_SEARCH_TYPE_MANUAL_AUTO, &stPlmnUserSel) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COPS_SET_MANUAL_AUTOMATIC_MANUAL;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetCopsPara(TAF_UINT8 ucIndex)
{
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;
    VOS_UINT32                          i;
    AT_USER_RESEL_PROC_TBL_STRU         astUserReselProcTbl[] =
    {
    /*   user option     reserved     proc func            */
        {0,               0,          AT_ProcCopsSetMode0},
        {1,               0,          AT_ProcCopsSetMode1},
        {2,               0,          AT_ProcCopsSetMode2},
        {3,               0,          AT_ProcCopsSetMode3},
        {4,               0,          AT_ProcCopsSetMode4},
    };

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        gastAtParaList[0].ulParaValue = 0;
    }

    /* 设置<mode> A32D07158
     * only in case of mode = 3(change the format), should the new format be saved.
     */
    /* 设置<format> */
    if(gastAtParaList[1].usParaLen != 0)
    {
        /* 在每次进行搜索时，不论是成功还是失败，PLMN要根据用户指定的最新的格式显示要求进行显示 */
        pstNetCtx->ucCopsFormatType = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    if (At_CheckCurrRatModeIsCL((VOS_UINT8)(gastAtClientTab[ucIndex].usClientId)) == VOS_TRUE)
    {
        if ((gastAtParaList[0].ulParaValue != 3)
         && (gastAtParaList[0].ulParaValue != 0))
        {
            return AT_CME_OPERATION_NOT_ALLOWED_IN_CL_MODE;
        }
    }
#endif


    for (i = 0; i < sizeof(astUserReselProcTbl)/sizeof(astUserReselProcTbl[0]); i++ )
    {
        if (gastAtParaList[0].ulParaValue == astUserReselProcTbl[i].ulUserResel)
        {
            return astUserReselProcTbl[i].pfUserReselProc(ucIndex);
        }
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetCesqPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;

    ulResult = TAF_MMA_QryCerssiReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, gastAtClientTab[ucIndex].opId);

    /* 执行命令操作 */
    if (ulResult == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CESQ_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCgclassPara(TAF_UINT8 ucIndex)
{
    TAF_PH_MS_CLASS_TYPE MsClass;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<class> */
    switch(gastAtParaList[0].ulParaValue)
    {
    case 0:
        MsClass = TAF_PH_MS_CLASS_A;
        break;

    case 1:
        MsClass = TAF_PH_MS_CLASS_B;
        break;

    case 2:
        MsClass = TAF_PH_MS_CLASS_CG;
        break;

    default:
        MsClass = TAF_PH_MS_CLASS_CC;
        break;
    }

    if (MsClass == TAF_PH_MS_CLASS_A)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32  AT_CheckUserRebootSupportFlg(VOS_VOID)
{
    TAF_NVIM_USER_REBOOT_SUPPORT_STRU       stUserRebootSupport;
    VOS_UINT32                              ulResult;
    VOS_UINT32                              ulLen;

    ulLen = sizeof(TAF_NVIM_USER_REBOOT_SUPPORT_STRU);

    memset_s(&stUserRebootSupport, ulLen, 0x00, ulLen);

    ulResult = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_User_Reboot_Support_Flg, &stUserRebootSupport, ulLen);

    if (ulResult != NV_OK)
    {
        AT_WARN_LOG("TAF_MMA_IsUserRebootSupport:Read Nvim Failed");
        return VOS_FALSE;
    }

    if (stUserRebootSupport.ucUserRebootConfig == 0xEF)
    {
        return VOS_TRUE;
    }

    return VOS_FALSE;
}


TAF_UINT32 At_SetCfunPara(TAF_UINT8 ucIndex)
{
    TAF_MMA_PHONE_MODE_PARA_STRU       stPhoneModePara;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
      && (gucAtParaIndex == 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fun> */
    if ( gastAtParaList[0].ulParaValue >= TAF_PH_MODE_NUM_MAX )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

/* 输出TAF的回放数据 */
#if (VOS_WIN32 == VOS_OS_VER)
    NAS_MSG_SndOutsideContextData_Part1();
    NAS_MSG_SndOutsideContextData_Part2();
    NAS_MSG_SndOutsideContextData_Part3();
#endif
/* 输出TAF的回放数据 */

    memset_s(&stPhoneModePara, sizeof(stPhoneModePara), 0x00, sizeof(TAF_MMA_PHONE_MODE_PARA_STRU));
    stPhoneModePara.PhMode  = (VOS_UINT8)gastAtParaList[0].ulParaValue;;

    if (gucAtParaIndex == 2)
    {
        stPhoneModePara.PhReset = (VOS_UINT8)gastAtParaList[1].ulParaValue;

        /* NV项打开时AT+CFUN=1,1直接在A核触发整机复位 */
        if ( (AT_CheckUserRebootSupportFlg() == VOS_TRUE)
          && (stPhoneModePara.PhMode == TAF_PH_MODE_FULL)
          && (stPhoneModePara.PhReset == TAF_PH_OP_MODE_RESET) )
        {
            gstAtSendData.usBufLen = 0;
            At_FormatResultData(ucIndex, AT_OK);
            VOS_TaskDelay(300); /*wait 300 tick*/
            (VOS_VOID)TAF_ACORE_NV_FLUSH();
            mdrv_om_system_error(NAS_REBOOT_MOD_ID_USER, 0, 0, VOS_NULL_PTR, 0);
            return AT_SUCCESS;
        }
    }

    if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stPhoneModePara) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CFUN_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgmiPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           aucMfrId[TAF_MAX_MFR_ID_STR_LEN + 1];

    memset_s(aucMfrId, TAF_MAX_MFR_ID_STR_LEN + 1, 0x00, TAF_MAX_MFR_ID_STR_LEN + 1);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_FMRID, aucMfrId, TAF_MAX_MFR_ID_STR_LEN) != NV_OK)
    {
        return AT_ERROR;
    }
    else
    {
        gstAtSendData.usBufLen = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                       (TAF_CHAR *)pgucAtSndCodeAddr,
                                                       (TAF_CHAR *)pgucAtSndCodeAddr,
                                                       "%s",
                                                        aucMfrId);

        return AT_OK;
    }
}

TAF_UINT32 At_SetCgmmPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_MSID_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGMM_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgmrPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_MSID_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGMR_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgsnPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* AT命令状态检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息 ID_AT_MTA_CGSN_QRY_REQ 给 MTA 处理， */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   ID_AT_MTA_CGSN_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);

    if(ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGSN_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCimiPara(TAF_UINT8 ucIndex)
{
    TAF_AT_NVIM_CIMI_PORT_CFG_STRU      stCimiPortCfg;

    stCimiPortCfg.ulCimiPortCfg = 0;

    /* 根据NV项配置参数，对命令下发的通道进行判断 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_CIMI_PORT_CFG,
                         &stCimiPortCfg,
                         sizeof(stCimiPortCfg)))
    {
        stCimiPortCfg.ulCimiPortCfg  = 0;
    }

    /* 该通道对应的Bit位不为0，则直接返回AT_ERROR */
    if ((stCimiPortCfg.ulCimiPortCfg & ((VOS_UINT32)1 << ucIndex)) != 0)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (AT_SUCCESS == SI_PIH_CimiSetReq(gastAtClientTab[ucIndex].usClientId,0))
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CIMI_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCsqPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

     /* 执行命令操作 */
    if(TAF_MMA_QryCsqReq(WUEPS_PID_AT,
                         gastAtClientTab[ucIndex].usClientId,
                         0) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSQ_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

VOS_UINT32 At_SetCbcPara(VOS_UINT8 ucIndex)
{
    if (mdrv_misc_support_check(BSP_MODULE_TYPE_CHARGE) == BSP_MODULE_SUPPORT )
    {

        /* E5 直接调用驱动的接口实现 */
        VOS_UINT8                           ucBcs;
        VOS_UINT8                           ucBcl;

        /* 参数检查 */
        if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (mdrv_misc_get_cbc_state(&ucBcs, &ucBcl) != VOS_OK)
        {
            return AT_ERROR;
        }

        gstAtSendData.usBufLen = (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                        (TAF_CHAR *)pgucAtSndCodeAddr,
                                                        (TAF_CHAR*)pgucAtSndCodeAddr,
                                                        "%s: %d,%d",
                                                        g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                                        ucBcs, ucBcl);
        return AT_OK;

    }
    else
    {
        /* 参数检查 */
        if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 执行命令操作 */
        if(TAF_MMA_QryBatteryCapacityReq(WUEPS_PID_AT,
                                         gastAtClientTab[ucIndex].usClientId,
                                         0) == VOS_TRUE)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CBC_SET;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }

    }

}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetCpdwPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                           ulRst;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 通过给C CPU发ID_TAF_MMA_CPLS_SET_REQ消息通知MT下电 */
    ulRst = TAF_MMA_MtPowerDownReq(WUEPS_PID_AT,
                                   gastAtClientTab[ucIndex].usClientId,
                                   0);

    if(ulRst == VOS_TRUE)

    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MMA_MT_POWER_DOWN;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}
#endif

TAF_UINT32 At_SetSnPara(TAF_UINT8 ucIndex)
{
    TAF_PH_SERIAL_NUM_STRU stSerialNum;
    TAF_UINT16            usLength;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD)
    {
        return At_WriteSnPara(ucIndex);
    }
    /* 从NV中读取 Serial Num,上报显示，返回 */

    memset_s(&stSerialNum, sizeof(stSerialNum), 0x00, sizeof(TAF_PH_SERIAL_NUM_STRU));

    usLength = TAF_SERIAL_NUM_NV_LEN;
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Serial_Num, stSerialNum.aucSerialNum, usLength) != NV_OK)
    {
        AT_WARN_LOG("At_SetSnPara:WARNING:NVIM Read en_NV_Item_Serial_Num falied!");
        return AT_ERROR;
    }
    else
    {
        memset_s((stSerialNum.aucSerialNum+TAF_SERIAL_NUM_LEN), (VOS_SIZE_T)(4*sizeof(stSerialNum.aucSerialNum[0])), 0x00, (VOS_SIZE_T)(4*sizeof(stSerialNum.aucSerialNum[0])));
        usLength = 0;
        usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s:",g_stParseContext[ucIndex].pstCmdElement->pszCmdName);
        usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s",stSerialNum.aucSerialNum);
    }
    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}


VOS_UINT32 At_WriteSnPara(VOS_UINT8 ucIndex)
{
    TAF_PH_SERIAL_NUM_STRU              stSerialNum;
    errno_t                             lMemResult;

    /* 参数个数不为1 */
    if (gucAtParaIndex != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 如果参数长度不等于16，直接返回错误 */
    if (gastAtParaList[0].usParaLen != TAF_SERIAL_NUM_LEN)
    {
        return AT_SN_LENGTH_ERROR;
    }

    /* 检查当前参数是否为数字字母字符串,不是则直接返回错误 */
    if (At_CheckNumCharString(gastAtParaList[0].aucPara,
                              gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 拷贝设置的16位SN参数到结构体变量stSerialNum.aucSerialNum中 */
    lMemResult = memcpy_s(stSerialNum.aucSerialNum, sizeof(stSerialNum.aucSerialNum), gastAtParaList[0].aucPara, TAF_SERIAL_NUM_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSerialNum.aucSerialNum), TAF_SERIAL_NUM_LEN);

    /* 将stSerialNum.aucSerialNum后四位填充为0xFF */
    memset_s((stSerialNum.aucSerialNum + TAF_SERIAL_NUM_LEN), TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN, 0xFF, (TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN));

    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Serial_Num,
                          stSerialNum.aucSerialNum,
                          TAF_SERIAL_NUM_NV_LEN))
    {
        AT_WARN_LOG("At_WriteSnPara:WARNING:TAF_ACORE_NV_WRITE en_NV_Item_Serial_Num failed!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return AT_OK;
}

VOS_UINT32 At_SetHwVerPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息DRV_AGENT_HARDWARE_QRY给AT AGENT处理，该消息无参数结构 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_HARDWARE_QRY,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DRV_AGENT_HARDWARE_QRY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

VOS_UINT32 At_SetFHVerPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息DRV_AGENT_FULL_HARDWARE_QRY给AT AGENT处理，该消息无参数结构 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   DRV_AGENT_FULL_HARDWARE_QRY,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if(ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DRV_AGENT_FULL_HARDWARE_QRY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;


}


VOS_UINT32 At_SetPfverPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 发消息到C核获取充电状态和电池电量 */
    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_PFVER_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("At_SetPfverPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PFVER_READ;
    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 At_SetCLACPara(VOS_UINT8 ucIndex)
{
    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gstAtSendData.usBufLen = 0;

    /* 依次输出支持的可显示的AT命令 */
    AT_ClacCmdProc();

    return AT_OK;
}


TAF_UINT32 At_SetCpbsPara(TAF_UINT8 ucIndex)
{
    SI_PB_STORATE_TYPE  Storage = SI_PB_STORAGE_UNSPECIFIED;
    TAF_UINT32          i;

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* VOS_StrCmp需要做指针非空检查，切记! */
    if((TAF_CHAR*)gastAtStringTab[AT_STRING_SM].pucText == TAF_NULL_PTR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((TAF_CHAR*)gastAtStringTab[AT_STRING_ON].pucText == TAF_NULL_PTR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((TAF_CHAR*)gastAtStringTab[AT_STRING_EN].pucText == TAF_NULL_PTR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((TAF_CHAR*)gastAtStringTab[AT_STRING_FD].pucText == TAF_NULL_PTR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((TAF_CHAR*)gastAtStringTab[AT_STRING_BD].pucText == TAF_NULL_PTR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for(i = 0; i < gastAtParaList[0].usParaLen ; i++)
    {
        gastAtParaList[0].aucPara[i] = At_UpChar(gastAtParaList[0].aucPara[i]);
    }

    if(VOS_StrCmp((TAF_CHAR*)gastAtStringTab[AT_STRING_ON].pucText,(TAF_CHAR*)gastAtParaList[0].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_ON;
    }
    else if(VOS_StrCmp((TAF_CHAR*)gastAtStringTab[AT_STRING_SM].pucText,(TAF_CHAR*)gastAtParaList[0].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_SM;
    }
    else if(VOS_StrCmp((TAF_CHAR*)gastAtStringTab[AT_STRING_FD].pucText,(TAF_CHAR*)gastAtParaList[0].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_FD;
    }
    else if(VOS_StrCmp((TAF_CHAR*)gastAtStringTab[AT_STRING_EN].pucText,(TAF_CHAR*)gastAtParaList[0].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_EC;
    }
    else if(VOS_StrCmp((TAF_CHAR*)gastAtStringTab[AT_STRING_BD].pucText,(TAF_CHAR*)gastAtParaList[0].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_BD;
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 执行命令操作 */
    if(SI_PB_Set(gastAtClientTab[ucIndex].usClientId, 0, Storage) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBS_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCpbr2Para(TAF_UINT8 ucIndex)
{
    AT_COMM_PB_CTX_STRU                *pstCommPbCntxt = VOS_NULL_PTR;
    VOS_UINT32                          ulResult;
    VOS_UINT16                          usIndex1;
    VOS_UINT16                          usIndex2;

    pstCommPbCntxt = AT_GetCommPbCtxAddr();

    /* 命令格式检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 命令参数个数检查 */
    if ((gucAtParaIndex < 1) || (gucAtParaIndex > 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AT+CPBR=, */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<index1> */
    usIndex1 = (VOS_UINT16)gastAtParaList[0].ulParaValue;

    if (gucAtParaIndex > 1)
    {
        if (gastAtParaList[1].usParaLen == 0)
        {
            /* AT+CPBR=<index1>, */
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            /* AT+CPBR=<index1>,<index2> */
            usIndex2 = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        }
    }
    else
    {
        /* AT+CPBR=<index1> */
        usIndex2 = usIndex1;
    }

    /* HSUART端口受限发送瓶颈, 需要逐条发送 */
    if (AT_CheckHsUartUser(ucIndex) == VOS_TRUE)
    {
        pstCommPbCntxt->usCurrIdx       = usIndex1;
        pstCommPbCntxt->usLastIdx       = usIndex2;
        pstCommPbCntxt->ulSingleReadFlg = (usIndex1 == usIndex2) ? VOS_TRUE : VOS_FALSE;

        ulResult = SI_PB_Read(gastAtClientTab[ucIndex].usClientId,
                              0, SI_PB_STORAGE_UNSPECIFIED,
                              pstCommPbCntxt->usCurrIdx,
                              pstCommPbCntxt->usCurrIdx);
    }
    else
    {
        ulResult = SI_PB_Read(gastAtClientTab[ucIndex].usClientId,
                              0, SI_PB_STORAGE_UNSPECIFIED,
                              usIndex1,
                              usIndex2);
    }

    if (ulResult == TAF_SUCCESS)
    {
        gulPBPrintTag = TAF_FALSE;
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBR2_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCpbrPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[1].usParaLen == 0)
    {
        gastAtParaList[1].ulParaValue = gastAtParaList[0].ulParaValue;
    }

    if (AT_CheckHsUartUser(ucIndex) == VOS_TRUE)
    {
        AT_GetCommPbCtxAddr()->usCurrIdx       = (VOS_UINT16)gastAtParaList[0].ulParaValue;
        AT_GetCommPbCtxAddr()->usLastIdx       = (VOS_UINT16)gastAtParaList[1].ulParaValue;
        AT_GetCommPbCtxAddr()->ulSingleReadFlg = (gastAtParaList[0].ulParaValue == gastAtParaList[1].ulParaValue) ? VOS_TRUE : VOS_FALSE;

        ulResult = SI_PB_Read(gastAtClientTab[ucIndex].usClientId,
                              0, SI_PB_STORAGE_UNSPECIFIED,
                              AT_GetCommPbCtxAddr()->usCurrIdx,
                              AT_GetCommPbCtxAddr()->usCurrIdx);
    }
    else
    {
        ulResult = SI_PB_Read(gastAtClientTab[ucIndex].usClientId,
                              0, SI_PB_STORAGE_UNSPECIFIED,
                              (TAF_UINT16)gastAtParaList[0].ulParaValue,
                              (TAF_UINT16)gastAtParaList[1].ulParaValue);
    }

    if (ulResult == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBR_SET;

        gulPBPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_PbDeleteProc(TAF_UINT8 ucIndex)
{
    /* 针对AT+CPBW=,和AT+CPBW=0的情况 */
    if(gastAtParaList[0].usParaLen == 0 || gastAtParaList[0].ulParaValue == 0)
    {
        return AT_CME_INVALID_INDEX;
    }

    if(SI_PB_Delete(gastAtClientTab[ucIndex].usClientId,
                    0, SI_PB_STORAGE_UNSPECIFIED,
                    (TAF_UINT16)gastAtParaList[0].ulParaValue) == AT_SUCCESS)

    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    AT_ERR_LOG("At_PbDeleteProc error: delete pb record failed");

    return AT_ERROR;
}



TAF_UINT32 At_SetCpbwPara(TAF_UINT8 ucIndex)
{
    SI_PB_RECORD_STRU                   stRecords;
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    TAF_UINT16                          usLen;
    TAF_UINT16                          usAlphaTagLength;
    TAF_UINT32                          ulResult;
    TAF_UINT32                          ulResultTemp;
    errno_t                             lMemResult;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)    /* 参数检查 */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gucAtParaIndex > 5)/* 参数过多 */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (gucAtParaIndex == 1)
    {
        ulResult = At_PbDeleteProc(ucIndex);

        return ulResult;
    }

    if((gastAtParaList[1].usParaLen == 0)&&(gastAtParaList[3].usParaLen == 0))
    {
        return AT_ERROR;
    }

    /* 确认编码类型，UNICODE或是ASCII码 */
    memset_s(&stRecords, sizeof(stRecords), 0x00, sizeof(stRecords));/* 初始化 */

    if((gastAtParaList[4].ulParaValue == AT_CSCS_UCS2_CODE) && (gucAtParaIndex == 5))
    {
        stRecords.AlphaTagType = AT_CSCS_UCS2_CODE;
    }
    else if((gastAtParaList[4].ulParaValue == AT_CSCS_IRA_CODE) && (gucAtParaIndex == 5))
    {
        stRecords.AlphaTagType = AT_CSCS_IRA_CODE;
    }
    else if(gucAtParaIndex == 4)
    {
        stRecords.AlphaTagType = AT_CSCS_IRA_CODE;
    }
    else
    {
        stRecords.AlphaTagType = AT_CSCS_IRA_CODE;
    }

    if(gastAtParaList[0].usParaLen != 0)/* 设置<index> */
    {
        stRecords.Index = (TAF_UINT16)gastAtParaList[0].ulParaValue;
    }

    if(gastAtParaList[1].usParaLen != 0)/* 设置<number> */
    {
        if(gastAtParaList[1].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[1].aucPara   + 1;
            usLen     = gastAtParaList[1].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[1].aucPara;
            usLen     = gastAtParaList[1].usParaLen;
        }

        if(At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        if(usLen > SI_PB_PHONENUM_MAX_LEN)
        {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(stRecords.Number, sizeof(stRecords.Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stRecords.Number), usLen);

        stRecords.NumberLength = (TAF_UINT8)usLen;
    }

    if(gastAtParaList[2].usParaLen != 0)/* 设置<type> */
    {
        /* 号码类型待修改 */
        stRecords.NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[1].aucPara[0]))
                              ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[2].ulParaValue;
    }
    else
    {
        stRecords.NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[1].aucPara[0]);
    }

    if(stRecords.NumberType < 128)
    {
        return AT_CME_INVALID_INDEX;
    }

    if(gastAtParaList[3].usParaLen != 0) /* 设置<text> */
    {
        /* 如果输入的AT命令已经指示是UNICODE编码要进行编码转换成ASCII码 */
        usAlphaTagLength = gastAtParaList[3].usParaLen;


        if(stRecords.AlphaTagType == AT_CSCS_UCS2_CODE)
        {
            /* 当ASCII位数必须是UNICODE的偶数倍 */
            if ((usAlphaTagLength % 2) != 0)
            {
                return AT_ERROR;
            }

            if(At_UnicodePrint2Unicode(gastAtParaList[3].aucPara,&usAlphaTagLength) == AT_FAILURE)
            {
                return AT_ERROR;
            }

            if (At_CheckNameUCS2Code(gastAtParaList[3].aucPara, &usAlphaTagLength) == AT_FAILURE)
            {
                return AT_ERROR;
            }

            stRecords.AlphaTagType = gastAtParaList[3].aucPara[0];
        }

        /* 最终得到的姓名字段的长度不能超过TAF_PB_RECORD_STRU
           结构中的最大长度，否则会导致堆栈溢出 */
        if(usAlphaTagLength > SI_PB_ALPHATAG_MAX_LEN)
        {
            usAlphaTagLength = SI_PB_ALPHATAG_MAX_LEN;
        }


        lMemResult = memcpy_s(stRecords.AlphaTag, sizeof(stRecords.AlphaTag), gastAtParaList[3].aucPara, usAlphaTagLength);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stRecords.AlphaTag), usAlphaTagLength);

        stRecords.ucAlphaTagLength = (TAF_UINT8)usAlphaTagLength;
    }

    if(gastAtParaList[0].usParaLen == 0) /* 添加 */
    {
        if( SI_PB_Add(gastAtClientTab[ucIndex].usClientId,
                      0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }

        return AT_ERROR;
    }

    ulResult      = SI_PB_GetSPBFlag();
    ulResultTemp  = SI_PB_GetStorateType();

    if((ulResult == 1)&&(ulResultTemp == SI_PB_STORAGE_SM))
    {
        if ( SI_PB_SModify(gastAtClientTab[ucIndex].usClientId,
                           0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
    }


    if (SI_PB_Modify(gastAtClientTab[ucIndex].usClientId,
                     0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_CME_INCORRECT_PARAMETERS;

}


TAF_VOID At_PbIraToUnicode(TAF_UINT8  *pucSrc,
                           TAF_UINT16 usSrcLen,
                           TAF_UINT8  *pucDst,
                           TAF_UINT16 *pusDstLen)
{
    TAF_UINT16      usIndex;
    TAF_UINT16      usUCS2;

    for (usIndex = 0; usIndex < usSrcLen; usIndex++)
    {
        /* 查IRA到UNICODE转义表， 将IRA字符转换为unicode编码 */
        usUCS2 = g_astIraToUnicode[pucSrc[usIndex]].usUnicode;
        *pucDst = (TAF_UINT8)(usUCS2 >> 8);
        pucDst++;
        *pucDst = (TAF_UINT8)usUCS2;
        pucDst++;
    }

    /* 转换后长度为原来的2倍 */
    *pusDstLen = (TAF_UINT16)(usSrcLen << 1);

    return;
}


TAF_UINT32 At_OneUnicodeToGsm(TAF_UINT16 usSrc, TAF_UINT8 *pucDst,
    TAF_UINT32 ulDstBufLen, TAF_UINT16 *pusDstLen)
{
    TAF_UINT16      usIndex;

    /* 避免输入码流为A0A1时存入SIM卡内容为1B40读出时上报为007C*/
    if (usSrc == 0x00A0)
    {
        AT_LOG1("At_OneUnicodeToGsm no found one unicode[0x%x] to gsm",usSrc);

        return AT_FAILURE;
    }

    if (ulDstBufLen < 2)
    {
        AT_LOG1("At_OneUnicodeToGsm Dst len[%d] is not enough.", ulDstBufLen);
        return AT_FAILURE;
    }

    /* 查找GSM 到 UNICODE基本表 */
    for(usIndex = 0; usIndex < AT_PB_GSM_MAX_NUM; usIndex++)
    {
        if(usSrc == g_astGsmToUnicode[usIndex].usUnicode)
        {
            *pucDst = g_astGsmToUnicode[usIndex].ucOctet;

            *pusDstLen = 1;

            return AT_SUCCESS;
        }
    }

    /* 查找GSM 到 UNICODE扩展表 */
    for(usIndex = 0; usIndex < AT_PB_GSM7EXT_MAX_NUM; usIndex++)
    {
        if(usSrc == g_astGsm7extToUnicode[usIndex].usUnicode)
        {
            *pucDst++ = AT_PB_GSM7EXT_SYMBOL;
            *pucDst = g_astGsm7extToUnicode[usIndex].ucOctet;

            *pusDstLen = 2;

            return AT_SUCCESS;
        }
    }

    /* 未查找到时返回失败 */
    *pusDstLen = 0;

    AT_LOG1("At_OneUnicodeToGsm no found one unicode[0x%x] to gsm",usSrc);

    return AT_FAILURE;
}


TAF_UINT32 At_UnicodeTransferToGsmCalcLength(TAF_UINT8  *pucSrc,
                                             TAF_UINT16 usSrcLen,
                                             TAF_UINT16 *pusDstLen)
{
     TAF_UINT16     usIndex;
     TAF_UINT16     usUnicodeChar;
     TAF_UINT8      aucGsmData[2];
     TAF_UINT16     usGsmDataLen;

     for (usIndex = 0; usIndex < (usSrcLen >> 1); usIndex++)
     {
        usUnicodeChar = (*pucSrc << 8) | (*(pucSrc + 1));

        /* 判断UNICODE是否可以转义为GSM7BIT */
        if (At_OneUnicodeToGsm(usUnicodeChar, aucGsmData, sizeof(aucGsmData), &usGsmDataLen) != AT_SUCCESS)
        {
            AT_ERR_LOG("At_UnicodeTransferToGsmCalcLength error");

            return AT_FAILURE;
        }

        pucSrc     += 2;

        *pusDstLen += usGsmDataLen;
     }

     return AT_SUCCESS;
}


TAF_VOID At_PbUnicodeParse(TAF_UINT8  *pucSrc,
                           TAF_UINT16 usSrcLen,
                           TAF_UINT32 *pulAlphaTagType,
                           TAF_UINT16 *pusDstLen,
                           TAF_UINT16 *pusCodeBase)
{
    TAF_UINT16      usGsmCodeLen = 0;
    TAF_UINT16      us81CodeLen = 0;
    TAF_UINT16      us82CodeLen = 0;
    TAF_UINT16      us81Base;
    TAF_UINT16      us82Base;
    TAF_UINT16      usMinCodeLen;
    TAF_UINT32      ulAlphaTagType;
    TAF_UINT16      usCodeBase;

    /* 先尝试转成GSM模式,如果能转换成功，则返回 */
    if (At_UnicodeTransferToGsmCalcLength(pucSrc, usSrcLen, &usGsmCodeLen) == AT_SUCCESS)
    {
        *pulAlphaTagType = SI_PB_ALPHATAG_TYPE_GSM;
        *pusDstLen       = usGsmCodeLen;
        *pusCodeBase     = 0;

        return;
    }

    /***************************************************************************
                            默认置为80编码
    ***************************************************************************/
    usMinCodeLen   = usSrcLen + 1;
    ulAlphaTagType = SI_PB_ALPHATAG_TYPE_UCS2_80;
    usCodeBase     = 0;

    /* 计算81编码长度,选定最小编码长度及相应的编码方式 */
    if (At_UnicodeTransferTo81CalcLength(pucSrc, usSrcLen, &us81Base, &us81CodeLen) == AT_SUCCESS)
    {
        if (us81CodeLen <= usMinCodeLen)
        {
            usMinCodeLen   = us81CodeLen;
            ulAlphaTagType = SI_PB_ALPHATAG_TYPE_UCS2_81;
            usCodeBase     = us81Base;
        }
    }

    /* 计算82编码长度,选定最小编码长度及相应的编码方式 */
    if (At_UnicodeTransferTo82CalcLength(pucSrc, usSrcLen, &us82Base, &us82CodeLen) == AT_SUCCESS)
    {
        if (us82CodeLen <= usMinCodeLen)
        {
            usMinCodeLen   = us82CodeLen;
            ulAlphaTagType = SI_PB_ALPHATAG_TYPE_UCS2_82;
            usCodeBase     = us82Base;
        }
    }

    *pusDstLen          = usMinCodeLen;
    *pusCodeBase        = usCodeBase;
    *pulAlphaTagType    = ulAlphaTagType;

    return;
}


TAF_UINT32 At_UnicodeTransferToGsm(TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen,
                                              TAF_UINT8 *pucDst, TAF_UINT32 ulDstLen)
{
    TAF_UINT16      usIndex;
    TAF_UINT16      usUnicodeChar;
    TAF_UINT16      usGsmDataLen = 0;

    for (usIndex = 0; usIndex < (usSrcLen >> 1); usIndex++)
    {
        usUnicodeChar = (*pucSrc << 8)|(*(pucSrc + 1));

        /* 逐个字符进行转换 */
        if (At_OneUnicodeToGsm(usUnicodeChar, pucDst,
            (ulDstLen - usGsmDataLen), &usGsmDataLen) != AT_SUCCESS)
        {
            AT_ERR_LOG("At_UnicodeTransferToGsm error");

            return AT_FAILURE;
        }

        pucDst += usGsmDataLen;
        pucSrc += 2;
    }

    return AT_SUCCESS;
}


TAF_VOID At_UnicodeTransferTo80(TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen, TAF_UINT8 *pucDst)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulSrcSize;
    pucDst[0] = SI_PB_ALPHATAG_TYPE_UCS2_80;

    ulSrcSize  = TAF_STD_MemFunc_Min(SI_PB_ALPHATAG_MAX_LEN - 1, usSrcLen);
    lMemResult = memcpy_s(&pucDst[1], SI_PB_ALPHATAG_MAX_LEN - 1, pucSrc, ulSrcSize);
    TAF_MEM_CHK_RTN_VAL(lMemResult, SI_PB_ALPHATAG_MAX_LEN - 1, usSrcLen);

    return;
}


TAF_UINT32 At_PbUnicodeTransfer(TAF_UINT8           *pucSrc,
                                TAF_UINT16          usSrcLen,
                                SI_PB_RECORD_STRU   *pstRecord,
                                TAF_UINT16          usCodeBase)
{
    TAF_UINT32      ulResult = AT_FAILURE;

    switch (pstRecord->AlphaTagType)
    {
        case SI_PB_ALPHATAG_TYPE_GSM:
            ulResult = At_UnicodeTransferToGsm(pucSrc, usSrcLen,
                            pstRecord->AlphaTag, sizeof(pstRecord->AlphaTag));

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_81:
            ulResult = At_UnicodeTransferTo81(pucSrc, usSrcLen, usCodeBase, pstRecord->AlphaTag);

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_82:
            ulResult = At_UnicodeTransferTo82(pucSrc, usSrcLen, usCodeBase, pstRecord->AlphaTag);

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_80:
            At_UnicodeTransferTo80(pucSrc, usSrcLen, pstRecord->AlphaTag);
            ulResult = AT_SUCCESS;

            break;

        default:

            break;
    }

    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("At_PbUnicodeTransfer: UCS2 transfer to gsm, 80, 81 or 82 error");
    }

    return ulResult;
}


TAF_UINT32 At_PbAlphaTagProc(SI_PB_RECORD_STRU *pstRecord, AT_PARSE_PARA_TYPE_STRU *pstAtParaList)
{
    errno_t                             lMemResult;
    TAF_UINT8                          *pucAlphaTag = VOS_NULL_PTR;
    TAF_UINT16                          usAlphaTagLen;
    TAF_UINT16                          usAlphaCodeLen;
    TAF_UINT16                          usCodeBase;

    /* 姓名字段为空时，不用处理姓名字段，但电话号码应该保存，所以返回成功 */
    if (pstAtParaList->usParaLen == 0)
    {
        return AT_SUCCESS;
    }

    if (AT_CSCS_GSM_7Bit_CODE == gucAtCscsType)
    {
        if (pstAtParaList->usParaLen > gstPBATInfo.usNameMaxLen)
        {
            AT_ERR_LOG("At_PbAlphaTagProc error: text string to long in gsm7");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        pstRecord->AlphaTagType = SI_PB_ALPHATAG_TYPE_GSM;

        /* GSM模式下判断是否所有输入码流小于0x7f，若大于0x7f时提示用户输入中含有非法字符 */
        if (At_Gsm7BitFormat(pstAtParaList->aucPara,
                             pstAtParaList->usParaLen,
                             pstRecord->AlphaTag,
                             &pstRecord->ucAlphaTagLength) != AT_SUCCESS)
        {
            AT_ERR_LOG("At_PbAlphaTagProc: error:the eighth bit is 1 in gsm7");

            return AT_CME_INVALID_CHARACTERS_IN_TEXT_STRING;
        }

        return AT_SUCCESS;
    }

    /* 分配空间用于存储中间转换的姓名字段，最多保存为80编码，因此最大空间为输入长度2倍 */
    usAlphaTagLen = (TAF_UINT16)(pstAtParaList->usParaLen << 1);

    pucAlphaTag = (TAF_UINT8*)VOS_MemAlloc(WUEPS_PID_AT, DYNAMIC_MEM_PT, usAlphaTagLen);

    if (pucAlphaTag == VOS_NULL_PTR)
    {
        AT_ERR_LOG("At_PbAlphaTagProc error:malloc failed");

        return AT_FAILURE;
    }

    /* IRA模式输入时先查表转换为UCS2，再处理 */
    if (gucAtCscsType == AT_CSCS_IRA_CODE)
    {
        At_PbIraToUnicode(pstAtParaList->aucPara,
                          pstAtParaList->usParaLen,
                          pucAlphaTag,
                          &usAlphaTagLen);
    }
    else
    {
        /* UCS2编码方式下，两字节标识一个字符，即码流是四的倍数 */
        if ((pstAtParaList->usParaLen % 4) != 0)
        {
            VOS_MemFree(WUEPS_PID_AT, pucAlphaTag);

            AT_LOG1("At_PbAlphaTagProc error: ucs2 codes length [%d] is nor 4 multiple",
                    pstAtParaList->usParaLen);

            return AT_ERROR;
        }

        if(At_UnicodePrint2Unicode(pstAtParaList->aucPara, &(pstAtParaList->usParaLen)) == AT_FAILURE)
        {
            VOS_MemFree(WUEPS_PID_AT, pucAlphaTag);

            AT_ERR_LOG("At_PbAlphaTagProc error: Printunicode to unicode failed");

            return AT_ERROR;
        }

        usAlphaTagLen = pstAtParaList->usParaLen;

        lMemResult = memcpy_s(pucAlphaTag, usAlphaTagLen, pstAtParaList->aucPara, usAlphaTagLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, usAlphaTagLen, usAlphaTagLen);
    }

    /* 对UCS2或IRA模式转换后的UCS2码流确定存储格式 */
    At_PbUnicodeParse(pucAlphaTag, usAlphaTagLen, &pstRecord->AlphaTagType, &usAlphaCodeLen, &usCodeBase);

    /* 最终确定的编码长度大于电话本姓名字段能存储的长度时，提醒用户输入太长 */
    if (usAlphaCodeLen > gstPBATInfo.usNameMaxLen)
    {
        VOS_MemFree(WUEPS_PID_AT, pucAlphaTag);

        AT_LOG1("At_PbAlphaTagProc error: name length [%d] too long", usAlphaCodeLen);

        return AT_CME_TEXT_STRING_TOO_LONG;
    }

    pstRecord->ucAlphaTagLength = (TAF_UINT8)usAlphaCodeLen;

    if (At_PbUnicodeTransfer(pucAlphaTag, usAlphaTagLen, pstRecord, usCodeBase) != AT_SUCCESS)
    {
        VOS_MemFree(WUEPS_PID_AT, pucAlphaTag);

        AT_ERR_LOG("At_PbAlphaTagProc: fail to convert UCS2");

        return AT_ERROR;
    }

    VOS_MemFree(WUEPS_PID_AT, pucAlphaTag);

    return AT_SUCCESS;
}


TAF_UINT32 At_PbEmailTransferToGsm(TAF_UINT8 *pucSrc, TAF_UINT16 usSrcLen,
    TAF_UINT8 *pucDst, VOS_UINT32 ulDstBufLen, VOS_UINT32 *pulDstLen)
{
    TAF_UINT16      usGsmCodeLen = 0;
    TAF_UINT8       aucEmailUCS2[2 * SI_PB_EMAIL_MAX_LEN];
    TAF_UINT16      usUCS2Len;

    memset_s(aucEmailUCS2, sizeof(aucEmailUCS2), 0x00, sizeof(aucEmailUCS2));

    /* 先将输入码流转换为UCS2再做处理 */
    At_PbIraToUnicode(pucSrc, usSrcLen, aucEmailUCS2, &usUCS2Len);

    /* 判断UCS2能否转换为GSM7bit存储 */
    if (At_UnicodeTransferToGsmCalcLength(aucEmailUCS2, usUCS2Len, &usGsmCodeLen) != AT_SUCCESS)
    {
        AT_ERR_LOG("At_PbEmailTransferToGsm error: failed to transfer to Gsm");

        return AT_CME_INVALID_CHARACTERS_IN_TEXT_STRING;
    }

    /* EMAIL的长度大于电话本EMAIL字段能存储的长度时，提醒用户输入太长 */
    if (usGsmCodeLen > gstPBATInfo.usEmailLen)
    {
        AT_LOG1("At_PbEmailTransferToGsm error: mail length [%d] too long", usGsmCodeLen);

        return AT_CME_TEXT_STRING_TOO_LONG;
    }

    *pulDstLen = usGsmCodeLen;

    /* 若能转换为GSM7bit则进行转换 */
    At_UnicodeTransferToGsm(aucEmailUCS2, usUCS2Len, pucDst, ulDstBufLen);

    return AT_SUCCESS;
}


TAF_UINT32 At_SetCpbfPara(TAF_UINT8 ucIndex)
{
    SI_PB_STORATE_TYPE                  Storage = SI_PB_STORAGE_UNSPECIFIED;
    SI_PB_RECORD_STRU                   stRecords;
    TAF_UINT32                          ulResult;

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 处理电话本姓名字段，从传输模式转换为存储模式GSM7BIT或UCS2 80/81/82 */
    ulResult = At_PbAlphaTagProc(&stRecords, &gastAtParaList[0]);

    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("At_SetCpbfPara:something wrong in At_PbAlphaTagProc");
        return ulResult;
    }

    /* 执行命令操作 */
    if( SI_PB_Search ( gastAtClientTab[ucIndex].usClientId, 0,
                       Storage, stRecords.ucAlphaTagLength,
                       stRecords.AlphaTag) == AT_SUCCESS
        )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBF_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_SetModemStatusPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    /* 参数不符合 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 内容长度不符合 */
    if((gastAtParaList[0].usParaLen != 1) || (gastAtParaList[1].usParaLen != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是balong modem复位，不需要处理该命令 */
    if(gastAtParaList[0].ulParaValue == 0)
    {
        return AT_OK;
    }

    ulRst = AT_FillAndSndCSIMAMsg(gastAtClientTab[ucIndex].usClientId, gastAtParaList[1].ulParaValue);

    if (ulRst == VOS_OK)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }

}


TAF_UINT32 At_SetCpbwPara2(TAF_UINT8 ucIndex)
{
    SI_PB_RECORD_STRU                   stRecords;
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    TAF_UINT16                          usLen;
    TAF_UINT32                          ulResult;
    TAF_UINT32                          ulResultTemp;
    errno_t                             lMemResult;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD) /* 参数检查 */
    {
        AT_ERR_LOG("At_SetCpbwPara2 error:incorect parameters");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gucAtParaIndex > 4) /* 参数过多 */
    {
        AT_ERR_LOG("At_SetCpbwPara2 error: too many parameters");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (gucAtParaIndex == 1)
    {
        ulResult = At_PbDeleteProc(ucIndex);

        return ulResult;
    }

    if((gastAtParaList[1].usParaLen == 0)&&(gastAtParaList[3].usParaLen == 0))
    {
        return AT_ERROR;
    }

    memset_s(&stRecords, sizeof(stRecords), 0x00, sizeof(stRecords));/* 初始化 */

    if(gastAtParaList[0].usParaLen != 0)/* 设置<index> */
    {
        stRecords.Index = (TAF_UINT16)gastAtParaList[0].ulParaValue;
    }

    if(gastAtParaList[1].usParaLen != 0)/* 设置<number> */
    {
        if(gastAtParaList[1].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[1].aucPara   + 1;
            usLen     = gastAtParaList[1].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[1].aucPara;
            usLen     = gastAtParaList[1].usParaLen;
        }

        if(At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            AT_ERR_LOG("At_SetCpbwPara2 error: invalid characters in dial string");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (usLen > SI_PB_PHONENUM_MAX_LEN)
        {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(stRecords.Number, sizeof(stRecords.Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stRecords.Number), usLen);

        stRecords.NumberLength = (TAF_UINT8)usLen;
    }

    /* 处理电话本姓名字段，从传输模式转换为存储模式GSM7BIT或UCS2 80/81/82 */
    ulResult = At_PbAlphaTagProc(&stRecords, &gastAtParaList[3]);

    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("At_SetCpbwPara2:something wrong in At_PbAlphaTagProc");
        return ulResult;
    }

    if (gastAtParaList[2].usParaLen != 0)/* 设置<type> */
    {
        /* 号码类型待修改 */
        stRecords.NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[1].aucPara[0]))
                              ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[2].ulParaValue;
    }
    else
    {
        stRecords.NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[1].aucPara[0]);
    }

    if (stRecords.NumberType < 128)
    {
        AT_ERR_LOG("At_SetCpbwPara2 error: invalid index");

        return AT_CME_INVALID_INDEX;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        /* 添加记录 */
        if (SI_PB_Add(gastAtClientTab[ucIndex].usClientId,
                                    0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }

        AT_ERR_LOG("At_SetCpbwPara2 error: add pb record failed");

        return AT_ERROR;
    }

    /* 修改记录 */
    ulResult      = SI_PB_GetSPBFlag();
    ulResultTemp  = SI_PB_GetStorateType();

    if((ulResult == 1)&&(ulResultTemp == SI_PB_STORAGE_SM))
    {
        if ( SI_PB_SModify(gastAtClientTab[ucIndex].usClientId,
                           0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
    }

    if (SI_PB_Modify(gastAtClientTab[ucIndex].usClientId,
                     0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    AT_ERR_LOG("At_SetCpbwPara2 error: modify pb record failed");

    return AT_ERROR;
}

TAF_UINT32 At_SetScpbwNum1Type1(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    errno_t                             lMemResult;
    TAF_UINT16                          usLen;

    if (gastAtParaList[1].usParaLen != 0)    /* 设置<num1> */
    {
        if (gastAtParaList[1].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[1].aucPara   + 1;
            usLen     = gastAtParaList[1].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[1].aucPara;
            usLen     = gastAtParaList[1].usParaLen;
        }

        if (At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            AT_ERR_LOG("At_SetScpbwNum1Type1: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (usLen > SI_PB_PHONENUM_MAX_LEN)
        {
            AT_ERR_LOG("At_SetScpbwNum1Type1: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(pstRecords->Number, sizeof(pstRecords->Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstRecords->Number), usLen);

        pstRecords->NumberLength = (TAF_UINT8)usLen;
    }

    /* 当号码为空时，类型字段按协议置为0xFF */
    if (gastAtParaList[1].usParaLen == 0)
    {
        pstRecords->NumberType = 0xFF;
        pstRecords->NumberLength = 0;
    }
    else
    {
        if (gastAtParaList[2].usParaLen != 0)/* 设置<type1> */
        {
            /* 号码类型待修改 */
            pstRecords->NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[1].aucPara[0]))
                                  ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[2].ulParaValue;
        }
        else
        {
            pstRecords->NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[1].aucPara[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum2Type2(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    errno_t                             lMemResult;
    TAF_UINT16                          usLen;

    if (gastAtParaList[3].usParaLen != 0)    /* 设置<num2> */
    {
        if (gastAtParaList[3].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[3].aucPara   + 1;
            usLen     = gastAtParaList[3].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[3].aucPara;
            usLen     = gastAtParaList[3].usParaLen;
        }

        if (At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            AT_ERR_LOG("At_SetScpbwNum2Type2: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (usLen > (SI_PB_PHONENUM_MAX_LEN + 2))
        {
            AT_ERR_LOG("At_SetScpbwNum2Type2: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(pstRecords->AdditionNumber[0].Number, sizeof(pstRecords->AdditionNumber[0].Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstRecords->AdditionNumber[0].Number), usLen);

        pstRecords->AdditionNumber[0].NumberLength = (TAF_UINT8)usLen;
    }

    if(gastAtParaList[3].usParaLen == 0)
    {
        pstRecords->AdditionNumber[0].NumberType = 0xFF;
        pstRecords->AdditionNumber[0].NumberLength = 0;
    }
    else
    {
        if (gastAtParaList[4].usParaLen != 0)/* 设置<type2> */
        {
            /* 号码类型待修改 */
            pstRecords->AdditionNumber[0].NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[3].aucPara[0]))
                                                    ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[4].ulParaValue;
        }
        else
        {
            pstRecords->AdditionNumber[0].NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[3].aucPara[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum3Type3(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    errno_t                             lMemResult;
    TAF_UINT16                          usLen;

    if (gastAtParaList[5].usParaLen != 0)    /* 设置<num3> */
    {
        if (gastAtParaList[5].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[5].aucPara   + 1;
            usLen     = gastAtParaList[5].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[5].aucPara;
            usLen     = gastAtParaList[5].usParaLen;
        }

        if (At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            AT_ERR_LOG("At_SetScpbwNum3Type3: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (usLen > (SI_PB_PHONENUM_MAX_LEN + 2))
        {
            AT_ERR_LOG("At_SetScpbwNum3Type3: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(pstRecords->AdditionNumber[1].Number, sizeof(pstRecords->AdditionNumber[1].Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstRecords->AdditionNumber[1].Number), usLen);

        pstRecords->AdditionNumber[1].NumberLength = (TAF_UINT8)usLen;
    }

    if(gastAtParaList[5].usParaLen == 0)
    {
        pstRecords->AdditionNumber[1].NumberType = 0xFF;
        pstRecords->AdditionNumber[1].NumberLength = 0;
    }
    else
    {
        if (gastAtParaList[6].usParaLen != 0)/* 设置<type3> */
        {
            /* 号码类型待修改 */
            pstRecords->AdditionNumber[1].NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[5].aucPara[0]))
                                                    ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[6].ulParaValue;
        }
        else
        {
            pstRecords->AdditionNumber[1].NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[5].aucPara[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum4Type4(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    TAF_UINT8                          *pucNumber = VOS_NULL_PTR;
    errno_t                             lMemResult;
    TAF_UINT16                          usLen;

    if (gastAtParaList[7].usParaLen != 0)    /* 设置<num4> */
    {
        if (gastAtParaList[7].aucPara[0] == '+')
        {
            pucNumber = gastAtParaList[7].aucPara   + 1;
            usLen     = gastAtParaList[7].usParaLen - 1;
        }
        else
        {
            pucNumber = gastAtParaList[7].aucPara;
            usLen     = gastAtParaList[7].usParaLen;
        }

        if (At_CheckPBString(pucNumber,&usLen) == AT_FAILURE)
        {
            AT_ERR_LOG("At_SetScpbwNum4Type4: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (usLen > (SI_PB_PHONENUM_MAX_LEN + 2))
        {
            AT_ERR_LOG("At_SetScpbwNum4Type4: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        lMemResult = memcpy_s(pstRecords->AdditionNumber[2].Number, sizeof(pstRecords->AdditionNumber[2].Number), pucNumber, usLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstRecords->AdditionNumber[2].Number), usLen);

        pstRecords->AdditionNumber[2].NumberLength = (TAF_UINT8)usLen;
    }

    if(gastAtParaList[7].usParaLen == 0)
    {
        pstRecords->AdditionNumber[2].NumberType = 0xFF;
        pstRecords->AdditionNumber[2].NumberLength = 0;
    }
    else
    {
        if (gastAtParaList[8].usParaLen != 0)/* 设置<type4> */
        {
            /* 号码类型待修改 */
            pstRecords->AdditionNumber[2].NumberType = (PB_NUMBER_TYPE_INTERNATIONAL == At_GetCodeType(gastAtParaList[7].aucPara[0]))
                                                    ? PB_NUMBER_TYPE_INTERNATIONAL : (TAF_UINT8)gastAtParaList[8].ulParaValue;
        }
        else
        {
            pstRecords->AdditionNumber[2].NumberType = (TAF_UINT8)At_GetCodeType(gastAtParaList[7].aucPara[0]);
        }
    }

    return AT_SUCCESS;

}

VOS_VOID At_SetScpbwAlphaTagType(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    if (gastAtParaList[10].ulParaValue == AT_CSCS_UCS2_CODE)
    {
        pstRecords->AlphaTagType = AT_CSCS_UCS2_CODE;
    }
    else if (gastAtParaList[10].ulParaValue == AT_CSCS_IRA_CODE)
    {
        pstRecords->AlphaTagType = AT_CSCS_IRA_CODE;
    }
    else
    {
        pstRecords->AlphaTagType = AT_CSCS_IRA_CODE;
    }

}

TAF_UINT32 At_SetScpbwText(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    errno_t                             lMemResult;
    TAF_UINT16                          usAlphaTagLength;

    if (gastAtParaList[9].usParaLen != 0) /* 设置<text> */
    {
        /* 如果输入的AT命令已经指示是UNICODE编码要进行编码转换成ASCII码 */
        usAlphaTagLength = gastAtParaList[9].usParaLen;

        if (pstRecords->AlphaTagType == AT_CSCS_UCS2_CODE)
        {
            /* 当ASCII位数必须是UNICODE的偶数倍 */
            if ((usAlphaTagLength % 2) != 0)
            {
                return AT_ERROR;
            }

            if (At_UnicodePrint2Unicode(gastAtParaList[9].aucPara,&usAlphaTagLength) == AT_FAILURE)
            {
                return AT_ERROR;
            }

            if (At_CheckNameUCS2Code(gastAtParaList[9].aucPara, &usAlphaTagLength) == AT_FAILURE)
            {
                return AT_ERROR;
            }

            pstRecords->AlphaTagType = gastAtParaList[9].aucPara[0];
        }

        /* 最终得到的姓名字段的长度不能超过TAF_PB_RECORD_STRU
        结构中的最大长度，否则会导致堆栈溢出 */
        if (usAlphaTagLength > SI_PB_ALPHATAG_MAX_LEN)
        {
            AT_ERR_LOG("At_SetScpbwText: cme incorrect parameters!");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        lMemResult = memcpy_s(pstRecords->AlphaTag, sizeof(pstRecords->AlphaTag), gastAtParaList[9].aucPara, usAlphaTagLength);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstRecords->AlphaTag), usAlphaTagLength);

        pstRecords->ucAlphaTagLength = (TAF_UINT8)usAlphaTagLength;
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwEmail(
    SI_PB_RECORD_STRU                   *pstRecords
)
{
    TAF_UINT32                          ulResult;

    if (gastAtParaList[11].usParaLen != 0)  /* 设置<email> */
    {
        if (gastAtParaList[11].usParaLen > SI_PB_EMAIL_MAX_LEN)
        {
            AT_ERR_LOG("At_SetScpbwEmail: cme text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        ulResult = At_PbEmailTransferToGsm(gastAtParaList[11].aucPara,
                                           gastAtParaList[11].usParaLen,
                                           pstRecords->Email.Email,
                                           sizeof(pstRecords->Email.Email),
                                           &pstRecords->Email.EmailLen);

        if (ulResult != AT_SUCCESS)
        {
            return ulResult;
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_CheckScpbwPara(
    TAF_UINT8                           ucIndex
)
{
    TAF_UINT32                          ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)    /* 参数检查 */
    {
        AT_ERR_LOG("At_CheckScpbwPara: cmd opt type error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 12)/* 参数过多 */
    {
        AT_ERR_LOG("At_CheckScpbwPara: para num too many");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (gucAtParaIndex == 1)
    {
        ulResult = At_PbDeleteProc(ucIndex);

        return ulResult;
    }

    if ((gastAtParaList[1].usParaLen == 0) && (gastAtParaList[3].usParaLen == 0)
     && (gastAtParaList[5].usParaLen == 0) && (gastAtParaList[7].usParaLen == 0)
     && (gastAtParaList[9].usParaLen == 0) && (gastAtParaList[11].usParaLen == 0))
    {
        AT_ERR_LOG("At_CheckScpbwPara: para len error");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}



TAF_UINT32 At_SetScpbwPara(
    TAF_UINT8                           ucIndex
)
{
    SI_PB_RECORD_STRU                   stRecords;
    TAF_UINT32                          ulRslt;

    ulRslt = At_CheckScpbwPara(ucIndex);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    /* 确认编码类型，UNICODE或是ASCII码 */
    memset_s(&stRecords, sizeof(stRecords), 0x00, sizeof(stRecords));/* 初始化 */

    /* 设置<index> */
    if (gastAtParaList[0].usParaLen != 0)
    {
        stRecords.Index = (TAF_UINT16)gastAtParaList[0].ulParaValue;
    }

    ulRslt = At_SetScpbwNum1Type1(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    ulRslt = At_SetScpbwNum2Type2(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    ulRslt = At_SetScpbwNum3Type3(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    ulRslt = At_SetScpbwNum4Type4(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    /* 设置ucAlphaTagType */
    At_SetScpbwAlphaTagType(&stRecords);

    /* 设置text */
    ulRslt = At_SetScpbwText(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    /* 设置Email */
    ulRslt = At_SetScpbwEmail(&stRecords);

    if (ulRslt != AT_SUCCESS)
    {
        return ulRslt;
    }

    if (gastAtParaList[0].usParaLen == 0) /* 添加 */
    {
        if (SI_PB_SAdd(gastAtClientTab[ucIndex].usClientId, 0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }

        return AT_ERROR;

    }

    /* 修改 */
    if (SI_PB_SModify(gastAtClientTab[ucIndex].usClientId, 0, SI_PB_STORAGE_UNSPECIFIED, &stRecords) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPBW_SET;/* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}



TAF_UINT32 At_SetScpbrPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[1].usParaLen == 0)
    {
        gastAtParaList[1].ulParaValue = gastAtParaList[0].ulParaValue;
    }

    if (SI_PB_SRead(gastAtClientTab[ucIndex].usClientId,
                    0, SI_PB_STORAGE_UNSPECIFIED,
                    (TAF_UINT16)gastAtParaList[0].ulParaValue,
                    (TAF_UINT16)gastAtParaList[1].ulParaValue) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SCPBR_SET;

        gulPBPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}



TAF_UINT32 At_SetCnumPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if(SI_PB_Read(gastAtClientTab[ucIndex].usClientId,0, SI_PB_STORAGE_ON, 0, 0) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CNUM_READ;

        gulPBPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}



TAF_UINT32 At_SetCsimPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CSIM_COMMAND_STRU            Command;
    errno_t                             lMemResult;

    /* 参数检查 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&Command, sizeof(Command), 0x00, sizeof(Command));

    if((gastAtParaList[0].ulParaValue % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[1].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[1].aucPara,&gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].ulParaValue != (TAF_UINT32)(gastAtParaList[1].usParaLen * 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<length> */
    Command.ulLen = gastAtParaList[1].usParaLen;

    /* 设置<command> */
    lMemResult = memcpy_s((TAF_VOID*)Command.aucCommand, sizeof(Command.aucCommand), (TAF_VOID*)gastAtParaList[1].aucPara, (VOS_UINT16)Command.ulLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(Command.aucCommand), (VOS_UINT16)Command.ulLen);

    /* 执行命令操作 */
    if(SI_PIH_GenericAccessReq(gastAtClientTab[ucIndex].usClientId, 0, &Command) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSIM_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCchoPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CCHO_COMMAND_STRU    stCchoCmd;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if((gastAtParaList[0].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if(At_AsciiNum2HexString(gastAtParaList[0].aucPara, &gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_SetCchoPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCchoCmd.ulAIDLen   = gastAtParaList[0].usParaLen;
    stCchoCmd.pucADFName = gastAtParaList[0].aucPara;

    /* 执行命令操作 */
    if(SI_PIH_CchoSetReq(gastAtClientTab[ucIndex].usClientId, 0, &stCchoCmd) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCHO_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCchpPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CCHP_COMMAND_STRU    stCchpCmd;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((gastAtParaList[0].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(gastAtParaList[0].aucPara, &gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_SetCchopPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCchpCmd.ulAIDLen   = gastAtParaList[0].usParaLen;
    stCchpCmd.pucADFName = gastAtParaList[0].aucPara;
    stCchpCmd.ucAPDUP2   = (VOS_UINT8)gastAtParaList[1].ulParaValue;

    /* 执行命令操作 */
    if(SI_PIH_CchpSetReq(gastAtClientTab[ucIndex].usClientId, 0, &stCchpCmd) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCHP_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetPrivateCchoPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CCHO_COMMAND_STRU    stCchoCmd = {0};

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if((gastAtParaList[0].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if(At_AsciiNum2HexString(gastAtParaList[0].aucPara, &gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_SetPrivateCchoPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCchoCmd.ulAIDLen   = gastAtParaList[0].usParaLen;
    stCchoCmd.pucADFName = gastAtParaList[0].aucPara;

    /* 执行命令操作 */
    if(SI_PIH_PrivateCchoSetReq(gastAtClientTab[ucIndex].usClientId, 0, &stCchoCmd) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PRIVATECCHO_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetPrivateCchpPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CCHP_COMMAND_STRU    stCchpCmd = {0};

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((gastAtParaList[0].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(gastAtParaList[0].aucPara, &gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_SetPrivateCchpPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCchpCmd.ulAIDLen   = gastAtParaList[0].usParaLen;
    stCchpCmd.pucADFName = gastAtParaList[0].aucPara;
    stCchpCmd.ucAPDUP2   = (VOS_UINT8)gastAtParaList[1].ulParaValue;

    /* 执行命令操作 */
    if(SI_PIH_PrivateCchpSetReq(gastAtClientTab[ucIndex].usClientId, 0, &stCchpCmd) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PRIVATECCHP_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}



TAF_UINT32 At_SetCchcPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if(SI_PIH_CchcSetReq(gastAtClientTab[ucIndex].usClientId,
                         0,
                         gastAtParaList[0].ulParaValue) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCHC_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCglaPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CGLA_COMMAND_STRU    stCglaCmd;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <length>需要为2的整数倍 */
    if((gastAtParaList[1].ulParaValue % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if((gastAtParaList[2].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if(At_AsciiNum2HexString(gastAtParaList[2].aucPara, &gastAtParaList[2].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_SetCglaPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* length字段是实际命令长度的2倍 */
    if(gastAtParaList[1].ulParaValue != (TAF_UINT32)(gastAtParaList[2].usParaLen * 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCglaCmd.ulSessionID   = gastAtParaList[0].ulParaValue;
    stCglaCmd.ulLen         = gastAtParaList[2].usParaLen;
    stCglaCmd.pucCommand    = gastAtParaList[2].aucPara;

    /* 执行命令操作 */
    if(SI_PIH_CglaSetReq(gastAtClientTab[ucIndex].usClientId, 0, &stCglaCmd) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGLA_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCardATRPara(TAF_UINT8 ucIndex)
{
    if (SI_PIH_GetCardATRReq(gastAtClientTab[ucIndex].usClientId, 0) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CARD_ATR_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetUsimStub(VOS_UINT8 ucIndex)
{
    TAF_MMA_USIM_STUB_SET_REQ_STRU                          stUsimStub;
    VOS_UINT32                                              ulEf;
    VOS_UINT32                                              ulTotalNum;
    VOS_UINT32                                              ulEfId;
    VOS_UINT32                                              ulEfLen;
    VOS_UINT32                                              ulApptype;
    VOS_UINT8                                               i;
    VOS_UINT8                                               ucNum;
#if (VOS_WIN32 != VOS_OS_VER)
    MODEM_ID_ENUM_UINT16                                    enModemID;
    TAF_NVIM_ENHANCED_OPER_NAME_SERVICE_CFG_STRU            stOperNameServiceCfg;
    VOS_UINT32                                              ulRet;
#endif
    errno_t                                                 lMemResult;

    ucNum      = 0;
    ulEf       = 0;
    ulTotalNum = 0;
    ulApptype  = 0;
    ulEfId     = 0;
    ulEfLen    = 0;
    memset_s(&stUsimStub, sizeof(stUsimStub), 0x00, sizeof(stUsimStub));

    /* 读取nv项，nv项关闭，返回失败 */

#if (VOS_WIN32 != VOS_OS_VER)
    memset_s(&stOperNameServiceCfg, sizeof(stOperNameServiceCfg), 0x00, sizeof(stOperNameServiceCfg));
    enModemID  = MODEM_ID_0;

    ulRet      = AT_GetModemIdFromClient(ucIndex, &enModemID);

    if (ulRet != VOS_OK)
    {
        return AT_ERROR;
    }

    if(NV_OK != TAF_ACORE_NV_READ(enModemID, en_NV_Item_ENHANCED_OPERATOR_NAME_SRV_CFG, &stOperNameServiceCfg,
                          sizeof(TAF_NVIM_ENHANCED_OPER_NAME_SERVICE_CFG_STRU)))
    {
        return AT_ERROR;
    }

    if (stOperNameServiceCfg.ucReserved5 == VOS_FALSE)
    {
        return AT_ERROR;
    }
#endif

    (VOS_VOID)At_String2Hex(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen, &ulEfId);
    (VOS_VOID)At_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &ulApptype);
    (VOS_VOID)At_String2Hex(gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen, &ulTotalNum);
    (VOS_VOID)At_String2Hex(gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen, &ulEfLen);

    stUsimStub.ucTotalNum = (VOS_UINT8)ulTotalNum;
    stUsimStub.usEfId     = (VOS_UINT16)ulEfId;
    stUsimStub.usEfLen    = (VOS_UINT16)ulEfLen;
    stUsimStub.ulApptype  = (VOS_UINT8)ulApptype;

    for (i=0; i < (gastAtParaList[4].usParaLen/2); i++)
    {
        (VOS_VOID)At_String2Hex(gastAtParaList[4].aucPara+ 2*i, 2, &ulEf);

        if (ucNum >= TAF_MMA_MAX_EF_LEN)
        {
           return AT_ERROR;
        }

        lMemResult = memcpy_s(&stUsimStub.aucEf[ucNum], AT_CONST_NUM_1, &ulEf, AT_CONST_NUM_1);
        TAF_MEM_CHK_RTN_VAL(lMemResult, AT_CONST_NUM_1, AT_CONST_NUM_1);
        ucNum++;
    }

    TAF_SetUsimStub(gastAtClientTab[ucIndex].usClientId,
                    gastAtClientTab[ucIndex].opId,
                    &stUsimStub);

    return AT_OK;
}


VOS_UINT32 At_SetRefreshStub(VOS_UINT8 ucIndex)
{
    TAF_MMA_REFRESH_STUB_SET_REQ_STRU                       stRefreshStub;
    VOS_UINT8                                               i;
    VOS_UINT32                                              ulTotalNum;
    VOS_UINT32                                              ulRefreshFileType;
    VOS_UINT32                                              ulReceivePid;
    VOS_UINT32                                              ulFileId;
#if (VOS_WIN32 != VOS_OS_VER)
    TAF_NVIM_ENHANCED_OPER_NAME_SERVICE_CFG_STRU            stOperNameServiceCfg;
    MODEM_ID_ENUM_UINT16                                    enModemID;
    VOS_UINT32                                              ulRet;
#endif

    ulTotalNum        = 0;
    ulRefreshFileType = 0;
    ulReceivePid      = 0;
    ulFileId          = 0;
    memset_s(&stRefreshStub, sizeof(stRefreshStub), 0x00, sizeof(stRefreshStub));

    /* 读取nv项，nv项关闭，返回失败 */
#if (VOS_WIN32 != VOS_OS_VER)
    memset_s(&stOperNameServiceCfg, sizeof(stOperNameServiceCfg), 0x00, sizeof(stOperNameServiceCfg));
    enModemID  = MODEM_ID_0;

    ulRet      = AT_GetModemIdFromClient(ucIndex, &enModemID);

    if (ulRet != VOS_OK)
    {
        return AT_ERROR;
    }

    if(NV_OK != TAF_ACORE_NV_READ(enModemID, en_NV_Item_ENHANCED_OPERATOR_NAME_SRV_CFG, &stOperNameServiceCfg,
                          sizeof(TAF_NVIM_ENHANCED_OPER_NAME_SERVICE_CFG_STRU)))
    {
        return AT_ERROR;
    }

    if (stOperNameServiceCfg.ucReserved5 == VOS_FALSE)
    {
        return AT_ERROR;
    }
#endif

    (VOS_VOID)At_String2Hex(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen, &ulReceivePid);
    (VOS_VOID)At_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &ulRefreshFileType);
    (VOS_VOID)At_String2Hex(gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen, &ulTotalNum);

    stRefreshStub.ulReceivePid      = ulReceivePid;
    stRefreshStub.ucTotalNum        = (VOS_UINT8)ulTotalNum;
    stRefreshStub.usRefreshFileType = (VOS_UINT8)ulRefreshFileType;

    if (stRefreshStub.ucTotalNum > TAF_MMA_MAX_FILE_ID_NUM)
    {
        stRefreshStub.ucTotalNum = TAF_MMA_MAX_FILE_ID_NUM;
    }

    for (i = 0; i < stRefreshStub.ucTotalNum; i++)
    {
        (VOS_VOID)At_String2Hex(gastAtParaList[i+3].aucPara, gastAtParaList[i+3].usParaLen, &ulFileId);
        stRefreshStub.ausEfId[i] = (VOS_UINT16)ulFileId;
    }

    TAF_SetRefreshStub(gastAtClientTab[ucIndex].usClientId,
                    gastAtClientTab[ucIndex].opId,
                    &stRefreshStub);

    return AT_OK;
}
#endif

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetAutoReselStub(VOS_UINT8 ucIndex)
{
    TAF_MMA_AUTO_RESEL_STUB_SET_REQ_STRU                    stAutoReselStub;

    memset_s(&stAutoReselStub, sizeof(stAutoReselStub), 0x00, sizeof(stAutoReselStub));

    stAutoReselStub.ucActiveFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    TAF_SetAutoReselStub(gastAtClientTab[ucIndex].usClientId,
                    gastAtClientTab[ucIndex].opId,
                    &stAutoReselStub);

    return AT_OK;
}
#endif
#if ( VOS_WIN32 == VOS_OS_VER )

VOS_UINT32 At_SetDelayBgStub(VOS_UINT8 ucIndex)
{
    VOS_UINT32                                              ulDelayLen;
    VOS_UINT32                                              ulOnOff;

    ulDelayLen        = 0;
    ulOnOff          = 0;

    At_String2Hex(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen, &ulOnOff);
    At_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &ulDelayLen);

    NAS_SetHighPrioPlmnRefreshTriggerBGSearchCfg((VOS_UINT8)ulOnOff, ulDelayLen);

    return AT_OK;
}
#endif



TAF_UINT32  At_CrsmFilePathCheck(TAF_UINT32 ulEfId, TAF_UINT8 *pucFilePath, TAF_UINT16 *pusPathLen)
{
    errno_t                             lMemResult;
    TAF_UINT16                          usLen;
    TAF_UINT16                          ausPath[USIMM_MAX_PATH_LEN]  = {0};
    TAF_UINT16                          ausTmpPath[USIMM_MAX_PATH_LEN]  = {0};
    TAF_UINT16                          usPathLen;
    TAF_UINT16                          i;

    usPathLen   = *pusPathLen;
    usLen       = 0;

    if (usPathLen > USIMM_MAX_PATH_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < (usPathLen/sizeof(TAF_UINT16)); i++)
    {
        ausTmpPath[i] = ((pucFilePath[i*2]<<0x08)&0xFF00) + pucFilePath[(i*2)+1];
    }

    /* 如果路径不是以3F00开始，需要添加3F00作开头 */
    if (ausTmpPath[0] != MFID)
    {
        if (usPathLen == USIMM_MAX_PATH_LEN)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ausPath[0] = MFID;

        usLen++;
    }

    lMemResult = memcpy_s(&ausPath[usLen], (USIMM_MAX_PATH_LEN - usLen) * ((VOS_SIZE_T)sizeof(TAF_UINT16)),ausTmpPath, usPathLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, (USIMM_MAX_PATH_LEN - usLen) * ((VOS_SIZE_T)sizeof(TAF_UINT16)), usPathLen);

    usLen += (usPathLen/sizeof(TAF_UINT16));

    if ((ulEfId & 0xFF00) == EFIDUNDERMF)
    {
        usLen = 1;
    }
    /* 4F文件要在5F下，路径长度为3 */
    else if ((ulEfId & 0xFF00) == EFIDUNDERMFDFDF)
    {
        if ((usLen != 3)
            ||((ausPath[1]&0xFF00) != DFIDUNDERMF)
            ||((ausPath[2]&0xFF00) != DFIDUNDERMFDF))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    /* 6F文件要在7F下，路径长度为2 */
    else if ((ulEfId & 0xFF00) == EFIDUNDERMFDF)
    {
        if ((usLen != 2)
            ||((ausPath[1]&0xFF00) != DFIDUNDERMF))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
    }

    *pusPathLen  = usLen;

    lMemResult = memcpy_s(pucFilePath, AT_PARA_MAX_LEN + 1, ausPath, (VOS_SIZE_T)(usLen*2));
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_PARA_MAX_LEN + 1, (VOS_SIZE_T)(usLen*2));

    return AT_SUCCESS;
}


TAF_UINT32  At_CrsmApduParaCheck(VOS_VOID)
{
    TAF_UINT16                          usFileTag;

    /* 命令类型参数检查，第一个参数不能为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_ERR_LOG("At_SetCrsmPara: command type null");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 除STATUS命令外，文件ID输入不能为空 */
    if ((gastAtParaList[1].ulParaValue == 0)
        && (gastAtParaList[0].ulParaValue != USIMM_STATUS))
    {
        AT_ERR_LOG("At_CrsmApduParaCheck: File Id null.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取文件ID前两位 */
    usFileTag   = (gastAtParaList[1].ulParaValue >> 8) & (0x00FF);

    /* 输入的文件ID必须是EF文件，前两位不可以是3F/5F/7F */
    if ((usFileTag == MFLAB)
       || (usFileTag == DFUNDERMFLAB)
       || (usFileTag == DFUNDERDFLAB))
    {
        AT_ERR_LOG("At_CrsmApduParaCheck: File Id error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <P1><P2><P3>这三个参数全部为空 */
    if ((gastAtParaList[2].usParaLen == 0)
        && (gastAtParaList[3].usParaLen == 0)
        && (gastAtParaList[4].usParaLen == 0))
    {
        return AT_SUCCESS;
    }

    /* <P1><P2><P3>这三个参数全部不为空 */
    if ((gastAtParaList[2].usParaLen != 0)
        && (gastAtParaList[3].usParaLen != 0)
        && (gastAtParaList[4].usParaLen != 0))
    {
        return AT_SUCCESS;
    }

    /* 其它情况下属于输入AT命令参数不完整 */
    return AT_CME_INCORRECT_PARAMETERS;

}


TAF_UINT32 At_CrsmFilePathParse(SI_PIH_CRSM_STRU *pstCommand)
{
    errno_t                             lMemResult;
    TAF_UINT32                          ulResult;

    /* 如果词法解析器解析第七个参数为空，说明没有文件路径输入，直接返回成功 */
    if ((gastAtParaList[6].usParaLen == 0)
     && (pstCommand->usEfId != VOS_NULL_WORD))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 在转换前输入的文件路径长度必须是4的整数倍 */
    if ((gastAtParaList[6].usParaLen % 4) != 0)
    {
        AT_ERR_LOG("At_CrsmFilePathParse: Path error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*将输入的字符串转换成十六进制数组*/
    if(At_AsciiNum2HexString(gastAtParaList[6].aucPara, &gastAtParaList[6].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_CrsmFilePathParse: At_AsciiNum2HexString error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果有填写文件ID和路径，要做文件路径检查，输入的路径长度以U16为单位 */
    ulResult = At_CrsmFilePathCheck((TAF_UINT16)gastAtParaList[1].ulParaValue,
                                    gastAtParaList[6].aucPara,
                                    &gastAtParaList[6].usParaLen);

    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("At_CrsmFilePathParse: At_CrsmFilePathCheck error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充文件路径和长度 */
    pstCommand->usPathLen   = gastAtParaList[6].usParaLen;

    /* 文件路径长度是U16为单位的，路径拷贝的长度要乘2 */
    lMemResult = memcpy_s(pstCommand->ausPath, sizeof(pstCommand->ausPath), gastAtParaList[6].aucPara, (VOS_SIZE_T)(gastAtParaList[6].usParaLen*sizeof(VOS_UINT16)));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstCommand->ausPath), (VOS_SIZE_T)(gastAtParaList[6].usParaLen*sizeof(VOS_UINT16)));

    return AT_SUCCESS;
}


TAF_UINT32 At_CrsmParaStatusCheck (SI_PIH_CRSM_STRU *pstCommand)
{
    /* STATUS命令如果没有输入文件ID，就不需要做选文件操作，直接发STATUS命令 */
    if (gastAtParaList[1].ulParaValue == 0)
    {
        pstCommand->usEfId = VOS_NULL_WORD;
    }
    else
    {
        pstCommand->usEfId = (TAF_UINT16)gastAtParaList[1].ulParaValue;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->enCmdType   =   USIMM_STATUS;

    return At_CrsmFilePathParse(pstCommand);
}


TAF_UINT32 At_CrsmParaReadBinaryCheck (SI_PIH_CRSM_STRU *pstCommand)
{

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;
    pstCommand->enCmdType   =   USIMM_READ_BINARY;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(pstCommand);
}



TAF_UINT32 At_CrsmParaReadRecordCheck(SI_PIH_CRSM_STRU *pstCommand)
{

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;
    pstCommand->enCmdType   =   USIMM_READ_RECORD;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(pstCommand);
}


VOS_UINT32 At_CrsmParaGetRspCheck(SI_PIH_CRSM_STRU *pstCommand)
{

    /* 参数个数不能少于2个，至少要有命令类型和文件ID */
    if (gucAtParaIndex < 2)
    {
        AT_ERR_LOG("At_CrsmParaGetRspCheck: Para less than 2.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;
    pstCommand->enCmdType   =   USIMM_GET_RESPONSE;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(pstCommand);
}


VOS_UINT32 At_CrsmParaUpdateBinaryCheck (SI_PIH_CRSM_STRU *pstCommand)
{
    errno_t                             lMemResult;

    /* Update Binary命令至少要有6个参数，可以没有文件路径 */
    if (gucAtParaIndex < 6)
    {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: Para less than 6.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;
    pstCommand->enCmdType   =   USIMM_UPDATE_BINARY;

    /* 第六个参数输入的<data>字符串在转换前数据长度必须是2的倍数且不能为0 */
    if (((gastAtParaList[5].usParaLen % 2) != 0)
        || (gastAtParaList[5].usParaLen == 0))
    {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[5].aucPara, &gastAtParaList[5].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (gastAtParaList[5].usParaLen > sizeof(pstCommand->aucContent))
    {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: gastAtParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    lMemResult = memcpy_s((TAF_VOID*)pstCommand->aucContent,
                          sizeof(pstCommand->aucContent),
                          (TAF_VOID*)gastAtParaList[5].aucPara,
                          gastAtParaList[5].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstCommand->aucContent), gastAtParaList[5].usParaLen);

    return At_CrsmFilePathParse(pstCommand);
}


VOS_UINT32 At_CrsmParaUpdateRecordCheck (SI_PIH_CRSM_STRU *pstCommand)
{
    errno_t                             lMemResult;

    /* Update Binary命令至少要有6个参数，可以没有文件路径 */
    if (gucAtParaIndex < 6)
    {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: Para less than 6.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;
    pstCommand->enCmdType   =   USIMM_UPDATE_RECORD;

     /* 第六个参数输入的<data>字符串数据长度必须是2的倍数且不能为0 */
    if (((gastAtParaList[5].usParaLen % 2) != 0)
        || (gastAtParaList[5].usParaLen == 0))
    {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[5].aucPara, &gastAtParaList[5].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (gastAtParaList[5].usParaLen > sizeof(pstCommand->aucContent))
    {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: gastAtParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    lMemResult = memcpy_s((TAF_VOID*)pstCommand->aucContent,
                          sizeof(pstCommand->aucContent),
                          (TAF_VOID*)gastAtParaList[5].aucPara,
                          gastAtParaList[5].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstCommand->aucContent), gastAtParaList[5].usParaLen);

    return At_CrsmFilePathParse(pstCommand);
}


VOS_UINT32 At_CrsmParaSearchRecordCheck (
    SI_PIH_CRSM_STRU                   *pstCommand)
{
    /* Search Record命令至少要有7个参数 */
    if (gucAtParaIndex < 6)
    {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: Para less than 7.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    pstCommand->ucP1        =   (TAF_UINT8)gastAtParaList[2].ulParaValue;
    pstCommand->ucP2        =   (TAF_UINT8)gastAtParaList[3].ulParaValue;
    pstCommand->ucP3        =   (TAF_UINT8)gastAtParaList[4].ulParaValue;

    /* 填写数据结构中的<fileid> */
    pstCommand->usEfId      =   (TAF_UINT16)gastAtParaList[1].ulParaValue;

    pstCommand->enCmdType   =   USIMM_SEARCH_RECORD;

     /* 第六个参数输入的<data>字符串数据长度必须是2的倍数且不能为0 */
    if (((gastAtParaList[5].usParaLen % 2) != 0)
     || (gastAtParaList[5].usParaLen == 0))
    {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[5].aucPara, &gastAtParaList[5].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (gastAtParaList[5].usParaLen > sizeof(pstCommand->aucContent))
    {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: gastAtParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    if (memcpy_s((TAF_VOID*)pstCommand->aucContent,
                 sizeof(pstCommand->aucContent),
                 (TAF_VOID*)gastAtParaList[5].aucPara,
                 gastAtParaList[5].usParaLen) != EOK)
    {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: memcpy_s fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return At_CrsmFilePathParse(pstCommand);
}


TAF_UINT32 At_SetCrsmPara(TAF_UINT8 ucIndex)
{
    SI_PIH_CRSM_STRU                    stCommand;
    TAF_UINT32                          ulResult;

    /* 参数过多 */
    if (gucAtParaIndex > 7)
    {
        AT_ERR_LOG("At_SetCrsmPara: too many para");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果有输入<P1><P2><P3>，这三个参数不能只填写部分参数 */
    if (At_CrsmApduParaCheck() != AT_SUCCESS)
    {
       AT_ERR_LOG("At_SetCrsmPara: At_CrsmApduParaCheck fail.");

       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stCommand, sizeof(stCommand), 0x00, sizeof(SI_PIH_CRSM_STRU));

    switch(gastAtParaList[0].ulParaValue)
    {
        case USIMM_STATUS:
            ulResult = At_CrsmParaStatusCheck(&stCommand);
            break;
        case USIMM_READ_BINARY:
            ulResult = At_CrsmParaReadBinaryCheck(&stCommand);
            break;
        case USIMM_READ_RECORD:
            ulResult = At_CrsmParaReadRecordCheck(&stCommand);
            break;
        case USIMM_GET_RESPONSE:
            ulResult = At_CrsmParaGetRspCheck(&stCommand);
            break;
        case USIMM_UPDATE_BINARY:
            ulResult = At_CrsmParaUpdateBinaryCheck(&stCommand);
            break;
        case USIMM_UPDATE_RECORD:
            ulResult = At_CrsmParaUpdateRecordCheck(&stCommand);
            break;
        case USIMM_SEARCH_RECORD:
            ulResult = At_CrsmParaSearchRecordCheck(&stCommand);
            break;
        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }

    if (ulResult != AT_SUCCESS )
    {
        AT_ERR_LOG("At_SetCrsmPara: para parse fail");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if(SI_PIH_CrsmSetReq(gastAtClientTab[ucIndex].usClientId, 0,&stCommand) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CRSM_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_CheckCpinPara(VOS_VOID)
{
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();


    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 如果<pin>过长或过短，直接返回错误 */
    if ( (gastAtParaList[0].usParaLen > TAF_PH_PINCODELENMAX)
      || (gastAtParaList[0].usParaLen < TAF_PH_PINCODELENMIN) )
    {
        if (*pucSystemAppConfig != SYSTEM_APP_ANDROID)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            /* AP-MODEM形态下，当参数个数为1时, 第一个参数允许长度为16 */
            if ( (gastAtParaList[0].usParaLen != TAF_PH_UNLOCKCODELEN)
              || (gucAtParaIndex != 1) )
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
    }

    /* 如果两个参数时，<newpin>过长或过短，直接返回错误 */
    if (gucAtParaIndex == 2)
    {
        if ( (gastAtParaList[1].usParaLen > TAF_PH_PINCODELENMAX)
          || (gastAtParaList[1].usParaLen < TAF_PH_PINCODELENMIN) )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;

}


TAF_UINT32 At_SetCpinPara(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    TAF_UINT32                          ulResult;
    MN_PH_SET_CPIN_REQ_STRU             stSetCPinReq;

    /* 参数检查 */
    ulResult = At_CheckCpinPara();
    if(ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    stSetCPinReq.usPara0Len = gastAtParaList[0].usParaLen;
    stSetCPinReq.usPara1Len = gastAtParaList[1].usParaLen;
    lMemResult = memcpy_s((VOS_VOID*)stSetCPinReq.aucPara0, sizeof(stSetCPinReq.aucPara0), (VOS_VOID*)gastAtParaList[0].aucPara, stSetCPinReq.usPara0Len);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSetCPinReq.aucPara0), stSetCPinReq.usPara0Len);
    lMemResult = memcpy_s((VOS_VOID*)stSetCPinReq.aucPara1, sizeof(stSetCPinReq.aucPara1), (VOS_VOID*)gastAtParaList[1].aucPara, stSetCPinReq.usPara1Len);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSetCPinReq.aucPara1), stSetCPinReq.usPara1Len);


    /* 通过TAF_MSG_MMA_SET_PIN 消息来设置CPIN */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      At_GetOpId(),
                                      TAF_MSG_MMA_SET_PIN,
                                      (VOS_VOID*)&stSetCPinReq,
                                      sizeof(stSetCPinReq),
                                      I0_WUEPS_PID_MMA);

    if(ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MSG_MMA_SET_PIN;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}

TAF_UINT32 At_SetCpin2Para(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    TAF_PH_PIN_DATA_STRU stPinData;
    TAF_UINT32           ulResult;

    /* 参数检查 */
    ulResult = At_CheckCpinPara();
    if(ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&stPinData, sizeof(stPinData), 0xFF, sizeof(stPinData));

    /* 设置<pin> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        lMemResult = memcpy_s((TAF_VOID*)stPinData.aucOldPin, sizeof(stPinData.aucOldPin), (TAF_VOID*)gastAtParaList[0].aucPara,gastAtParaList[0].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPinData.aucOldPin), gastAtParaList[0].usParaLen);
    }

    /* 设置<newpin> */
    if(gastAtParaList[1].usParaLen != 0)
    {
        lMemResult = memcpy_s((TAF_VOID*)stPinData.aucNewPin, sizeof(stPinData.aucNewPin), (TAF_VOID*)gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPinData.aucNewPin), gastAtParaList[1].usParaLen);
    }

    /* 设置CmdType */
    if(gastAtParaList[1].usParaLen == 0)
    {
        stPinData.PinType = TAF_SIM_PIN2;
        stPinData.CmdType = TAF_PIN_VERIFY;
    }
    else
    {
        stPinData.PinType = TAF_SIM_PUK2;
        stPinData.CmdType = TAF_PIN_UNBLOCK;
    }

    /* 执行命令操作 */
    if(Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId, 0,&stPinData) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        if(gastAtParaList[1].usParaLen == 0)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPIN2_VERIFY_SET;
        }
        else
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPIN2_UNBLOCK_SET;
        }
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

/*****************************************************************************
 Prototype      : At_SetIccidPara
 Description    : ^ICCID
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetIccidPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参照标竿，直接返回AT_OK */
    return AT_OK;
}


TAF_UINT32 At_SetPNNPara(TAF_UINT8 ucIndex)
{
    TAF_PH_QRY_USIM_INFO_STRU           stUsimInfo;

    memset_s(&stUsimInfo, sizeof(stUsimInfo), 0x00, sizeof(stUsimInfo));

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[0].ulParaValue != 0)
        &&(gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (gastAtParaList[0].ulParaValue == 0)
    {
        stUsimInfo.Icctype = TAF_PH_ICC_SIM;
    }
    else
    {
        stUsimInfo.Icctype = TAF_PH_ICC_USIM;
    }
    stUsimInfo.enEfId = TAF_PH_PNN_FILE;
    /*linear fixed file only support 254 reocrd*/
    if(gastAtParaList[1].usParaLen != 0)
    {
        if( (gastAtParaList[1].ulParaValue > 0xFE)
         || (gastAtParaList[1].ulParaValue == 0))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            stUsimInfo.ulRecNum = gastAtParaList[1].ulParaValue;
        }
    }
    else
    {
        stUsimInfo.ulRecNum = 0;

        /* 在读取PNN列表的时候进行分次下发，每次只读取TAF_MMA_PNN_INFO_MAX_NUM个，以防止A核申请内存失败造成复位 */
        stUsimInfo.stPnnQryIndex.usPnnCurrIndex = 0;   /* 第一次下发的时候，Index为0，后面在收到TAF的CNF消息的时候再进行分批次下发 */
        stUsimInfo.stPnnQryIndex.usPnnNum       = TAF_MMA_PNN_INFO_MAX_NUM;
    }

    /* 执行命令操作 */
    if(TAF_QryUsimInfo(gastAtClientTab[ucIndex].usClientId,0,&stUsimInfo) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PNN_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCPNNPara(TAF_UINT8 ucIndex)
{
    TAF_PH_ICC_TYPE                     IccType;

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[0].ulParaValue != 0)
        &&(gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (gastAtParaList[0].ulParaValue == 0)
    {
        IccType = TAF_PH_ICC_SIM;
    }
    else
    {
        IccType = TAF_PH_ICC_USIM;
    }

    /* 执行命令操作 */
    if(TAF_QryCpnnInfo(gastAtClientTab[ucIndex].usClientId,0,IccType) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPNN_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetOPLPara (TAF_UINT8 ucIndex)
{
    TAF_PH_QRY_USIM_INFO_STRU           stUsimInfo;

    /* 参数检查 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[0].ulParaValue != 0)
        &&(gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue == 0)
    {
        stUsimInfo.Icctype = TAF_PH_ICC_SIM;
    }
    else
    {
        stUsimInfo.Icctype = TAF_PH_ICC_USIM;
    }
    stUsimInfo.enEfId = TAF_PH_OPL_FILE;
    /*linear fixed file only support 254 reocrd*/
    if((gastAtParaList[1].usParaLen != 0))
    {
        if((gastAtParaList[1].ulParaValue > 0xFE)
        || (gastAtParaList[1].ulParaValue == 0))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            stUsimInfo.ulRecNum = gastAtParaList[1].ulParaValue;
        }
    }
    else
    {
        stUsimInfo.ulRecNum = 0;
    }

    /* 执行命令操作 */
    if(TAF_QryUsimInfo(gastAtClientTab[ucIndex].usClientId,0,&stUsimInfo) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_OPL_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}
/*****************************************************************************
 Prototype      : At_SetCardlockPara
 Description    : ^CARDLOCK
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2008-03-15
    Author      : luojian
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCardlockPara(TAF_UINT8 ucIndex)
{
    TAF_ME_PERSONALISATION_DATA_STRU    stMePersonalisationData;
    errno_t                             lMemResult;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <unlock_code>必须为长度为8的数字字符串 */
    if( gastAtParaList[0].usParaLen == TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX)
    {
        if ( At_CheckNumString(gastAtParaList[0].aucPara,
                               TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) == AT_FAILURE
           )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            memset_s( &stMePersonalisationData, sizeof(stMePersonalisationData), 0x00 ,sizeof(TAF_ME_PERSONALISATION_DATA_STRU) );
            /* 复制用户解锁码 */
            lMemResult = memcpy_s(stMePersonalisationData.aucOldPwd,
                                  sizeof(stMePersonalisationData.aucOldPwd),
                                  gastAtParaList[0].aucPara,
                                  TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMePersonalisationData.aucOldPwd), TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
        }
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 安全命令类型为校验密码 */
    stMePersonalisationData.CmdType        = TAF_ME_PERSONALISATION_VERIFY;
    /* 锁卡操作为锁网络 */
    stMePersonalisationData.MePersonalType = TAF_OPERATOR_PERSONALISATION;
     /* 执行命令操作 */
    if(Taf_MePersonalisationHandle(gastAtClientTab[ucIndex].usClientId, 0,&stMePersonalisationData) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CARD_LOCK_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_FillSsBsService(
    TAF_SS_ERASESS_REQ_STRU            *pstSSPara,
    AT_PARSE_PARA_TYPE_STRU            *pstAtPara
)
{
    if ( (pstAtPara->usParaLen == 0 )
      || (pstAtPara->ulParaValue == AT_CLCK_PARA_CLASS_ALL) )
    {
        /* 默认值 */
        pstSSPara->OP_BsService = 0;
    }
    else
    {
        if(At_SsPrint2Class(&(pstSSPara->BsService),
                            (VOS_UINT8)pstAtPara->ulParaValue) == AT_FAILURE)
        {
            return VOS_ERR;
        }
        pstSSPara->OP_BsService = 1;
    }

    return VOS_OK;
}


VOS_UINT32 AT_FillSsNoRepCondTime(
    VOS_UINT8                           ucSsCode,
    AT_PARSE_PARA_TYPE_STRU            *pstAtPara,
    TAF_SS_REGISTERSS_REQ_STRU         *pstSSPara
)
{
    if ((ucSsCode == TAF_ALL_FORWARDING_SS_CODE)
     || (ucSsCode == TAF_ALL_COND_FORWARDING_SS_CODE)
     || (ucSsCode == TAF_CFNRY_SS_CODE))
    {
        if (pstAtPara->usParaLen)
        {
            pstSSPara->OP_NoRepCondTime = 1;
            pstSSPara->NoRepCondTime    = (TAF_SS_NOREPLYCONDITIONTIME)pstAtPara->ulParaValue;
        }
        else
        {
            /* 默认值 */
            pstSSPara->OP_NoRepCondTime = 1;
            pstSSPara->NoRepCondTime    = 20;
        }
    }

    return VOS_OK;
}


TAF_UINT32 At_SetCcwaPara(TAF_UINT8 ucIndex)
{
    TAF_SS_ERASESS_REQ_STRU             para;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&para, sizeof(para), 0x00, sizeof(para));

    /* 设置SsCode */
    para.SsCode = TAF_CW_SS_CODE;

    /* 设置<n> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        pstSsCtx->ucCcwaType = (AT_CCWA_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        pstSsCtx->ucCcwaType = AT_CCWA_DISABLE_TYPE;
    }

    if(gastAtParaList[1].usParaLen == 0)
    {
        return AT_OK;
    }

    /* 设置<class> */
    if (AT_FillSsBsService(&para, &gastAtParaList[2]) != VOS_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    switch(gastAtParaList[1].ulParaValue)
    {
    case 0: /* disable */
        if(TAF_DeactivateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCWA_DISABLE;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }

    case 1: /* enable */
        if(TAF_ActivateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCWA_ENABLE;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }

    default: /* query status */
        gastAtClientTab[ucIndex].ulTemp = gastAtParaList[2].ulParaValue;
        para.OP_BsService = 0;
        if(TAF_InterrogateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
        {
            /* 设置当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCWA_QUERY;
            return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
        }
        else
        {
            return AT_ERROR;
        }
    }
}


VOS_UINT32 AT_CheckCcfcParaValid( VOS_VOID  )
{

    /* 参数检查 */
    if ( (gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[1].usParaLen == 0) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 8 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<number>过长，直接返回错误 */
    if ( gastAtParaList[2].usParaLen > TAF_SS_MAX_FORWARDED_TO_NUM_LEN )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<subaddr>过长，直接返回错误 */
    if ( gastAtParaList[5].usParaLen > TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查NUM号码输入不正确 */
    if ( gastAtParaList[2].usParaLen != 0 )
    {
        if( At_CheckDialString(gastAtParaList[2].aucPara,
            gastAtParaList[2].usParaLen) == AT_FAILURE )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 检查SubAddress号码输入不正确 */
    if ( gastAtParaList[5].usParaLen != 0 )
    {
        if( At_CheckDialString(gastAtParaList[5].aucPara,
            gastAtParaList[5].usParaLen) == AT_FAILURE )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_OK;
}


TAF_SS_CODE AT_GetSsCodeFromCfccPara( VOS_VOID  )
{
    TAF_SS_CODE                         ssCode;

    /* 设置SsCode */
    switch( gastAtParaList[0].ulParaValue )
    {
    case 0:
        ssCode = TAF_CFU_SS_CODE;
        break;

    case 1:
        ssCode = TAF_CFB_SS_CODE;
        break;

    case 2:
        ssCode = TAF_CFNRY_SS_CODE;
        break;

    case 3:
        ssCode = TAF_CFNRC_SS_CODE;
        break;

    case 4:
        ssCode = TAF_ALL_FORWARDING_SS_CODE;
        break;

    default:
        ssCode = TAF_ALL_COND_FORWARDING_SS_CODE;
        break;
    }

    return ssCode;
}


VOS_VOID AT_SetNumAttribute(
    TAF_SS_NUMTYPE                      *pNumType,
    TAF_UINT8                           *pucFwdToNum
    )
{
    errno_t                             lMemResult;
    /* Modified by s46746 for SS FDN&Call Control, 2013-05-28, begin */
    /* +表示国际号码，在号码类型中已经指示，不需要拷贝到消息中 */
    if (gastAtParaList[2].aucPara[0] == '+')
    {
        lMemResult = memcpy_s((TAF_CHAR*)pucFwdToNum,
                              TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                              (TAF_CHAR*)(gastAtParaList[2].aucPara+1),
                              (VOS_SIZE_T)(gastAtParaList[2].usParaLen-1));
        TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1, (VOS_SIZE_T)(gastAtParaList[2].usParaLen-1));
    }
    else
    {
        lMemResult = memcpy_s((TAF_CHAR*)pucFwdToNum,
                              TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                              (TAF_CHAR*)gastAtParaList[2].aucPara,
                              gastAtParaList[2].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1, gastAtParaList[2].usParaLen);
    }
    /* Modified by s46746 for SS FDN&Call Control, 2013-05-28, end */

    if( gastAtParaList[3].usParaLen )
    {
        *pNumType = (TAF_SS_NUMTYPE)gastAtParaList[3].ulParaValue;
    }
    else
    {
        *pNumType = At_GetCodeType(gastAtParaList[2].aucPara[0]);
    }
}


VOS_VOID AT_SetSubAddrAttribute(
    TAF_SS_SUBADDRTYPE                  *pSubAddrType,
    TAF_UINT8                           *pucFwdToSubAddr
)
{
    errno_t                             lMemResult;
    lMemResult = memcpy_s((TAF_CHAR*)pucFwdToSubAddr,
                          TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN + 1,
                          (TAF_CHAR*)gastAtParaList[5].aucPara,
                          gastAtParaList[5].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN + 1, gastAtParaList[5].usParaLen);

    if( gastAtParaList[6].usParaLen )
    {
        *pSubAddrType = (TAF_UINT8)gastAtParaList[6].ulParaValue;
    }
    else
    {
        *pSubAddrType = 128;
    }

}


VOS_UINT32 AT_DeactivateSSReq(
    TAF_UINT8                           ucIndex,
    TAF_SS_ERASESS_REQ_STRU             *pstEraseReq
)
{
    if( TAF_DeactivateSSReq(gastAtClientTab[ucIndex].usClientId,
        0,
        pstEraseReq) == AT_SUCCESS )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCFC_DISABLE;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_ActivateSSReq(
    TAF_UINT8                           ucIndex,
    TAF_SS_ERASESS_REQ_STRU             *pstActivateReq
)
{
    if( TAF_ActivateSSReq(gastAtClientTab[ucIndex].usClientId,
        0,
        pstActivateReq) == AT_SUCCESS )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCFC_ENABLE;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32  AT_InterrogateSSReq(
    TAF_UINT8                           ucIndex,
    TAF_SS_ERASESS_REQ_STRU             *pstInterrogateReq
)
{
    gastAtClientTab[ucIndex].ulTemp = gastAtParaList[4].ulParaValue;

    if ( TAF_InterrogateSSReq(gastAtClientTab[ucIndex].usClientId,
        0,
        pstInterrogateReq) == AT_SUCCESS )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCFC_QUERY;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_RegisterSSReq(
    TAF_UINT8                           ucIndex,
    TAF_SS_REGISTERSS_REQ_STRU          *pstRegisterReq
)
{
    if ( TAF_RegisterSSReq(gastAtClientTab[ucIndex].usClientId,
        0,
        pstRegisterReq) == AT_SUCCESS )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCFC_REGISTRATION;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_EraseSSReq(
    TAF_UINT8                           ucIndex,
    TAF_SS_ERASESS_REQ_STRU             *pstEraseSSReq
)
{
    if ( TAF_EraseSSReq(gastAtClientTab[ucIndex].usClientId,
        0,
        pstEraseSSReq) == AT_SUCCESS )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCFC_ERASURE;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCcfcPara(TAF_UINT8 ucIndex)
{
    TAF_SS_REGISTERSS_REQ_STRU          para;
    TAF_SS_ERASESS_REQ_STRU             sndpara;
    VOS_UINT32                          ulRet;

    ulRet = AT_CheckCcfcParaValid();
    if ( ulRet != AT_OK )
    {
        return ulRet;
    }

    /* 初始化 */
    memset_s(&para, sizeof(para), 0x00, sizeof(para));
    memset_s(&sndpara, sizeof(sndpara), 0x00, sizeof(sndpara));

    para.SsCode = AT_GetSsCodeFromCfccPara();

    /* 设置<number>,<type> */
    if ( gastAtParaList[2].usParaLen != 0 )
    {
        para.OP_FwdToNum = 1;
        para.OP_NumType  = 1;
        AT_SetNumAttribute(&para.NumType,para.aucFwdToNum);
    }
    else
    {
        para.OP_FwdToNum = 0;
        para.OP_NumType  = 0;
    }

    /* 设置<subaddr>,<satype> */
    if ( gastAtParaList[5].usParaLen != 0 )
    {
        para.OP_FwdToAddr = 1;
        para.OP_SubAddrType = 1;
        AT_SetSubAddrAttribute(&(para.SubAddrType), para.aucFwdToSubAddr);
    }
    else
    {
        para.OP_FwdToAddr   = 0;
        para.OP_SubAddrType = 0;
    }

    /* 设置<time> */
    AT_FillSsNoRepCondTime(para.SsCode, &gastAtParaList[7], &para);

    /* 设置<class> */
    if (AT_FillSsBsService(&sndpara, &gastAtParaList[4]) != VOS_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    sndpara.SsCode    = para.SsCode;

    if (sndpara.OP_BsService == VOS_TRUE)
    {
        para.OP_BsService               = sndpara.OP_BsService;
        para.BsService.BsType           = sndpara.BsService.BsType;
        para.BsService.BsServiceCode    = sndpara.BsService.BsServiceCode;
    }

    /* 执行命令操作 */
    switch(gastAtParaList[1].ulParaValue)
    {
    case 0: /* <mode>: disable */
        ulRet = AT_DeactivateSSReq(ucIndex,&sndpara);
        break;

    case 1: /* <mode>: enable */
        ulRet = AT_ActivateSSReq(ucIndex,&sndpara);
        break;

    case 2: /* <mode>: query status */
        ulRet = AT_InterrogateSSReq(ucIndex,&sndpara);
        break;

    case 3: /* <mode>: registration */
        ulRet = AT_RegisterSSReq(ucIndex,&para);
        break;

    default:    /* <mode>: erasure */
        ulRet = AT_EraseSSReq(ucIndex,&sndpara);
        break;
    }

    return ulRet;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)
/*****************************************************************************
 Prototype      : At_SetCmlckPara
 Description    : +CLCK=<fac>,<action>[,<passwd>[,<data>]]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2007-10-06
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCmlckPara (TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    TAF_UINT32                          ulresult;


    /* 参数检查 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))

    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* data长度大于15，直接返回参数错误 */
    if (gastAtParaList[3].usParaLen > TAF_MAX_IMSI_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch(gastAtParaList[0].ulParaValue)
    {
        case AT_CMLCK_PS_TYPE:
        {
            TAF_ME_PERSONALISATION_DATA_STRU stMePersonalisationData;

            if(gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(&stMePersonalisationData, sizeof(stMePersonalisationData), 0x00, sizeof(TAF_ME_PERSONALISATION_DATA_STRU));

            /* 设置<passwd> */
            if(gastAtParaList[2].usParaLen != 0)
            {
                lMemResult = memcpy_s((TAF_CHAR*)stMePersonalisationData.aucOldPwd, sizeof(stMePersonalisationData.aucOldPwd), (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMePersonalisationData.aucOldPwd), gastAtParaList[2].usParaLen);
            }

            /* 设置PinType */
            stMePersonalisationData.MePersonalType = TAF_SIM_PERSONALISATION;

            if(gastAtParaList[3].usParaLen != 0)
            {
                ulresult = At_AsciiNum2Num(stMePersonalisationData.unMePersonalisationSet.SimPersionalisationStr.aucSimPersonalisationStr,
                                           gastAtParaList[3].aucPara,
                                           gastAtParaList[3].usParaLen);
                if (ulresult != AT_SUCCESS)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                stMePersonalisationData.unMePersonalisationSet.SimPersionalisationStr.DataLen= (VOS_UINT8)gastAtParaList[3].usParaLen;
            }


            /* 设置CmdType */
            switch(gastAtParaList[1].ulParaValue)
            {
            case 0:
                if (gastAtParaList[3].usParaLen == 0)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_SET;

                break;

            case 1:
                stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_RETRIEVE;

                break;

            default:
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 执行命令操作 */
            if(Taf_MePersonalisationHandle(gastAtClientTab[ucIndex].usClientId, 0,&stMePersonalisationData) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }

        }

        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }


}
#endif

VOS_UINT32 AT_CheckPinLength(
    VOS_UINT16                          usLen,
    VOS_UINT8                          *pucPin
)
{
    if (pucPin == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_CheckPinLength():PIN is NULL PTR");
        return VOS_ERR;
    }

    if ((usLen > TAF_PH_PINCODELENMAX)
     || (usLen < TAF_PH_PINCODELENMIN))
    {
        AT_ERR_LOG("AT_CheckPinLength():PIN LENGTH is Error");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckPinValue(
    VOS_UINT16                          usLen,
    VOS_UINT8                          *pucPin
)
{
    VOS_UINT8                           i;

    if (pucPin == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_CheckPinValue(): PIN is NULL PTR");
        return VOS_ERR;
    }

    for (i = 0; i < usLen ; i++ )
    {
        if ( (pucPin[i] >'9' )
           ||(pucPin[i] <'0'))
        {
            AT_ERR_LOG("AT_CheckPinValue(): PIN Value is Error");
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckPinAvail(
    VOS_UINT16                          usLen,
    VOS_UINT8                          *pucPin
)
{
    if (AT_CheckPinLength(usLen, pucPin) != VOS_OK)
    {
        AT_ERR_LOG("AT_CheckPinAvail(): PIN Length is Error");
        return VOS_ERR;
    }
    else
    {
        if (AT_CheckPinValue(usLen, pucPin) != VOS_OK)
        {
            AT_ERR_LOG("AT_CheckPinAvail():PIN Value is Error");
            return VOS_ERR;
        }
    }
    return VOS_OK;
}


AT_MTA_PERS_CATEGORY_ENUM_UINT8 AT_GetSimlockUnlockCategoryFromClck(VOS_VOID)
{
    switch(gastAtParaList[0].ulParaValue)
    {
        case AT_CLCK_PN_TYPE:
            return AT_MTA_PERS_CATEGORY_NETWORK;
        case AT_CLCK_PU_TYPE:
            return AT_MTA_PERS_CATEGORY_NETWORK_SUBSET;
        case AT_CLCK_PP_TYPE:
            return AT_MTA_PERS_CATEGORY_SERVICE_PROVIDER;
        default:
            return AT_MTA_PERS_CATEGORY_BUTT;
    }

}

#if (FEATURE_PHONE_SC == FEATURE_ON)

TAF_UINT32 AT_SetClckFacEqualPNPUPPPara(TAF_UINT8 ucIndex)
{
    AT_MTA_SIMLOCKUNLOCK_REQ_STRU       stSimlockUnlockSetReq;

    switch(gastAtParaList[1].ulParaValue)
    {
        case AT_CLCK_MODE_UNLOCK:/* 设置<mode>为0，则进行锁网锁卡解锁操作 */
            {

                memset_s(&stSimlockUnlockSetReq, sizeof(stSimlockUnlockSetReq), 0x00, sizeof(AT_MTA_SIMLOCKUNLOCK_REQ_STRU));
                stSimlockUnlockSetReq.enCategory = AT_GetSimlockUnlockCategoryFromClck();

                /* <password>参数检查 */
                if (gastAtParaList[2].usParaLen != AT_SIMLOCKUNLOCK_PWD_PARA_LEN)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                /* 密码的合法性检查，密码为16个“0”-“9”ASCII字符,密码由ASCII码转换为十进制数字 */
                if (At_AsciiNum2Num(stSimlockUnlockSetReq.aucPassword,
                       gastAtParaList[2].aucPara,
                       gastAtParaList[2].usParaLen) != AT_SUCCESS)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                /* 发送跨核消息到C核, 解锁锁网锁卡 */
                if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                              gastAtClientTab[ucIndex].opId,
                              ID_AT_MTA_SIMLOCKUNLOCK_SET_REQ,
                              &stSimlockUnlockSetReq,
                              sizeof(AT_MTA_SIMLOCKUNLOCK_REQ_STRU),
                              I0_UEPS_PID_MTA) != TAF_SUCCESS)
                {
                    return AT_ERROR;
                }

                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_SIMLOCKUNLOCK;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */


            }
        case AT_CLCK_MODE_LOCK:/* 设置<mode>为1，则直接返回错误信息 */
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        case AT_CLCK_MODE_QUERY_STATUS:/* 设置<mode>为2，则进行锁网锁卡功能查询操作 */
            {
                return AT_OK;
            }
        default:
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
    }

}
#endif



TAF_UINT32 At_SetClckPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           aucPin[TAF_PH_PINCODELENMAX];
    VOS_UINT32                          CmdType;
    VOS_UINT32                          Result;
    errno_t                             lMemResult;

    /* 参数检查 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fac> */
    switch(gastAtParaList[0].ulParaValue)
    {
    case AT_CLCK_P2_TYPE:
        return AT_CME_INCORRECT_PARAMETERS;

    case AT_CLCK_SC_TYPE:
        {
            TAF_PH_PIN_DATA_STRU stPinData;

            if (gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(&stPinData, sizeof(stPinData), 0xFF, sizeof(stPinData));

            /* 设置<passwd> */
            if(gastAtParaList[2].usParaLen != 0)
            {
                lMemResult = memcpy_s((TAF_CHAR*)stPinData.aucOldPin, sizeof(stPinData.aucOldPin), (TAF_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPinData.aucOldPin), gastAtParaList[2].usParaLen);
            }

            stPinData.PinType = TAF_SIM_PIN;

            /* 设置CmdType */
            switch(gastAtParaList[1].ulParaValue)
            {
            case 0:
                stPinData.CmdType = TAF_PIN_DISABLE;
                if (AT_CheckPinAvail(gastAtParaList[2].usParaLen, gastAtParaList[2].aucPara) != VOS_OK)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                break;

            case 1:
                stPinData.CmdType = TAF_PIN_ENABLE;
                if (AT_CheckPinAvail(gastAtParaList[2].usParaLen, gastAtParaList[2].aucPara) != VOS_OK)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                break;

            default:
                stPinData.CmdType = TAF_PIN_QUERY;
                break;
            }

            /* 执行命令操作 */
            if(Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId, 0,&stPinData) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }
    case AT_CLCK_FD_TYPE:
        {
            if(gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(aucPin, sizeof(aucPin), 0xFF, sizeof(aucPin));

            /* 设置<passwd> */
            if(gastAtParaList[2].usParaLen != 0)
            {
                lMemResult = memcpy_s((TAF_CHAR*)aucPin, sizeof(aucPin), (TAF_CHAR*)gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucPin), gastAtParaList[2].usParaLen);
            }

            CmdType = gastAtParaList[1].ulParaValue;

            /* 执行命令操作，当前只有FDN相关的操作，AT命令并不支持BDN功能 */
            if(CmdType == SI_PIH_FDN_BDN_ENABLE)
            {
                Result = SI_PIH_FdnEnable(gastAtClientTab[ucIndex].usClientId, 0, aucPin, TAF_PH_PINCODELENMAX);
            }
            else if(CmdType == SI_PIH_FDN_BDN_DISABLE)
            {
                Result = SI_PIH_FdnDisable(gastAtClientTab[ucIndex].usClientId, 0, aucPin, TAF_PH_PINCODELENMAX);
            }
            else
            {
                Result = SI_PIH_FdnBdnQuery(gastAtClientTab[ucIndex].usClientId, 0, SI_PIH_FDN_QUERY);
            }

            if(Result == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }

    case AT_CLCK_PS_TYPE:
        {
            TAF_ME_PERSONALISATION_DATA_STRU stMePersonalisationData;

            if(gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(&stMePersonalisationData, sizeof(stMePersonalisationData), 0x00, sizeof(TAF_ME_PERSONALISATION_DATA_STRU));

            /* 设置<passwd> */
            if(gastAtParaList[2].usParaLen != 0)
            {
                lMemResult = memcpy_s((VOS_CHAR*)stMePersonalisationData.aucOldPwd, sizeof(stMePersonalisationData.aucOldPwd), (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMePersonalisationData.aucOldPwd), gastAtParaList[2].usParaLen);
            }

            /* 设置PinType */
            stMePersonalisationData.MePersonalType = TAF_SIM_PERSONALISATION;


            /* 设置CmdType */
            switch(gastAtParaList[1].ulParaValue)
            {
            case 0:
                stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_DEACTIVE;
                break;

            case 1:
                stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_ACTIVE;
                break;

            default:
                stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_QUERY;
                break;
            }

            /* 执行命令操作 */
            if(Taf_MePersonalisationHandle(gastAtClientTab[ucIndex].usClientId, 0,&stMePersonalisationData) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }

#if (FEATURE_PHONE_SC == FEATURE_ON)
    case AT_CLCK_PN_TYPE:
    case AT_CLCK_PU_TYPE:
    case AT_CLCK_PP_TYPE:
        {
            return AT_SetClckFacEqualPNPUPPPara(ucIndex);
        }
#endif



    default:
        {
            TAF_SS_ERASESS_REQ_STRU para;

            /* 初始化 */
            memset_s(&para, sizeof(para), 0x00, sizeof(para));

            /* 设置<password> */
            if (gastAtParaList[2].usParaLen > 0)
            {
                if (gastAtParaList[2].usParaLen != TAF_SS_MAX_PASSWORD_LEN)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                para.OP_Password = VOS_TRUE;
                lMemResult = memcpy_s((VOS_CHAR *)para.aucPassword,
                                      sizeof(para.aucPassword),
                                      (VOS_CHAR *)gastAtParaList[2].aucPara,
                                      gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(para.aucPassword), gastAtParaList[2].usParaLen);
            }


            /* 设置SsCode */
            At_SsPrint2Code(&para.SsCode,(TAF_UINT8)gastAtParaList[0].ulParaValue);

            /* 设置<class> */
            if (AT_FillSsBsService(&para, &gastAtParaList[3]) != VOS_OK)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 执行命令操作 */
            switch(gastAtParaList[1].ulParaValue)
            {
            case 0: /* <mode>: unlock */
                if(TAF_DeactivateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
                {
                    /* 设置当前操作类型 */
                    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_LOCK;
                    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
                }
                else
                {
                    return AT_ERROR;
                }

            case 1: /* <mode>: lock */
                if(TAF_ActivateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
                {
                    /* 设置当前操作类型 */
                    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_UNLOCK;
                    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
                }
                else
                {
                    return AT_ERROR;
                }

            default: /* <mode>: query status */
                para.OP_BsService = 0;
                gastAtClientTab[ucIndex].ulTemp = gastAtParaList[3].ulParaValue;
                if(TAF_InterrogateSSReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
                {
                    /* 设置当前操作类型 */
                    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLCK_QUERY;
                    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
                }
                else
                {
                    return AT_ERROR;
                }
            }
        }
    }
}


TAF_UINT32 At_SetCtfrPara(TAF_UINT8 ucIndex)
{
    MN_CALL_SUPS_PARAM_STRU             stCallSupsParam;
    VOS_UINT32                          ulRst;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<number>过长，直接返回错误 */
    if(gastAtParaList[0].usParaLen > (MN_CALL_MAX_BCD_NUM_LEN * 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<subaddr>过长，直接返回错误 */
    if(gastAtParaList[2].usParaLen > (MN_CALL_MAX_BCD_NUM_LEN * 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stCallSupsParam, sizeof(stCallSupsParam), 0x00, sizeof(stCallSupsParam));

    gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen]='\0';

    ulRst = AT_AsciiNumberToBcd((VOS_CHAR *)gastAtParaList[0].aucPara,
                                stCallSupsParam.stRedirectNum.aucBcdNum,
                                &stCallSupsParam.stRedirectNum.ucNumLen);
    if (ulRst != MN_ERR_NO_ERROR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCallSupsParam.callId = 0;
    stCallSupsParam.enCallSupsCmd = MN_CALL_SUPS_CMD_DEFLECT_CALL;
    stCallSupsParam.stRedirectNum.enNumType = (TAF_UINT8)gastAtParaList[1].ulParaValue;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stCallSupsParam,
                              ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                              sizeof(stCallSupsParam),
                              enModemId) == VOS_OK)
    {
        /* 停止自动接听 */
        pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);

        if (pstCcCtx->stS0TimeInfo.bTimerStart == VOS_TRUE)
        {
            AT_StopRelTimer(pstCcCtx->stS0TimeInfo.ulTimerName, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CTFR_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetCusdPara(VOS_UINT8 ucIndex)
{
    TAF_SS_PROCESS_USS_REQ_STRU        *pPara = VOS_NULL_PTR;
    VOS_UINT32                          ulRet;
    TAF_SS_DATA_CODING_SCHEME           DatacodingScheme;
    VOS_UINT32                          ulProcRet;


    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    /* 获取SS上下文 */
    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    ulRet =  AT_ERROR;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[2].usParaLen == 0)
    {
        /* 默认为7bit编码 */
        DatacodingScheme = TAF_SS_7bit_LANGUAGE_UNSPECIFIED;
    }
    else
    {
        DatacodingScheme = (TAF_SS_DATA_CODING_SCHEME)gastAtParaList[2].ulParaValue;

        /*产品线要求支持uss2的ussd*/
    }

    /* 如果<str>号码过长，直接返回错误 */
    if(At_CheckUssdNumLen(ucIndex, DatacodingScheme, gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /*lint -save -e516 */
    pPara    = (TAF_SS_PROCESS_USS_REQ_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_SS_PROCESS_USS_REQ_STRU));
    /*lint -restore */
    if (pPara == TAF_NULL_PTR)
    {
        return AT_ERROR;
    }

    /* 初始化 */
    memset_s(pPara, sizeof(TAF_SS_PROCESS_USS_REQ_STRU), 0x00, sizeof(TAF_SS_PROCESS_USS_REQ_STRU));

    /* 设置<n> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        if(gastAtParaList[0].ulParaValue != 2)
        {
            pPara->enCusdType    = (TAF_SS_CUSD_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
        }
    }
    else
    {
        pPara->enCusdType    = TAF_SS_CUSD_TYPE_DISABLE;
    }

    /* <n>: cancel session */
    if(gastAtParaList[0].ulParaValue == 2)
    {
        if(TAF_SsReleaseComplete(gastAtClientTab[ucIndex].usClientId, 0) == AT_SUCCESS)
        {
            ulRet = AT_OK;

        }
        else
        {
            ulRet = AT_ERROR;
        }
    }
    else
    {
        /*  AT+CUSD=0时，也需要给C核发消息，但不用等C核回复 */
        if(gastAtParaList[1].usParaLen == 0)
        {
            memset_s(&(pPara->UssdStr), sizeof(pPara->UssdStr), 0x00, sizeof(pPara->UssdStr));
        }
        else
        {
            ulProcRet = At_ConvUssdStrInCmd(&(pPara->UssdStr), DatacodingScheme, ucIndex);
            if (ulProcRet != AT_OK)
            {
                /*lint -save -e516 */
                PS_MEM_FREE(WUEPS_PID_AT, pPara);
                /*lint -restore */
                return ulProcRet;
            }
        }
        /* 设置<dcs> */
        pPara->DatacodingScheme = DatacodingScheme;

        pPara->usUssdTransMode = pstSsCtx->usUssdTransMode;
        /* 执行命令操作 */
        if(TAF_ProcessUnstructuredSSReq(gastAtClientTab[ucIndex].usClientId, 0, pPara) == AT_SUCCESS)
        {
            /*  AT+CUSD=0时，也需要给C核发消息，但不用等C核回复 */
            if(gastAtParaList[1].usParaLen == 0)
            {
                ulRet =  AT_OK;
            }
            else
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CUSD_REQ;

                /* 返回命令处理挂起状态 */
                ulRet =  AT_WAIT_ASYNC_RETURN;
            }
        }
        else
        {
            ulRet =  AT_ERROR;
        }

    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pPara);
    /*lint -restore */
    return ulRet;
}

TAF_UINT32 At_SetCpwdPara(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          i;
    /* 参数检查 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0) || (gastAtParaList[2].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fac> */
    switch(gastAtParaList[0].ulParaValue)
    {
    case AT_CLCK_P2_TYPE:
    case AT_CLCK_SC_TYPE:
        {
            TAF_PH_PIN_DATA_STRU stPinData;

            if((gastAtParaList[1].usParaLen > TAF_PH_PINCODELENMAX) || (gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX)
             ||(gastAtParaList[1].usParaLen < TAF_PH_PINCODELENMIN) || (gastAtParaList[2].usParaLen < TAF_PH_PINCODELENMIN))
            {
                return AT_ERROR;
            }

            /* 初始化 */
            memset_s(&stPinData, sizeof(stPinData), 0xFF, sizeof(stPinData));

            /* 设置<pin> */
            if(gastAtParaList[1].usParaLen != 0)
            {
                for(i=0; i<gastAtParaList[1].usParaLen; i++)
                {
                    if((gastAtParaList[1].aucPara[i] > '9' )||(gastAtParaList[1].aucPara[i] < '0'))
                    {
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                }

                lMemResult = memcpy_s((TAF_VOID*)stPinData.aucOldPin, sizeof(stPinData.aucOldPin), (TAF_VOID*)gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPinData.aucOldPin), gastAtParaList[1].usParaLen);
            }

            /* 设置<newpin> */
            if(gastAtParaList[2].usParaLen != 0)
            {
                for(i=0; i<gastAtParaList[2].usParaLen; i++)
                {
                    if((gastAtParaList[2].aucPara[i] > '9' )||(gastAtParaList[2].aucPara[i] < '0'))
                    {
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                }

                lMemResult = memcpy_s((TAF_VOID*)stPinData.aucNewPin, sizeof(stPinData.aucNewPin), (TAF_VOID*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPinData.aucNewPin), gastAtParaList[2].usParaLen);
            }
            /* 设置PinType */
            if(gastAtParaList[0].ulParaValue == AT_CLCK_P2_TYPE)
            {
                stPinData.PinType = TAF_SIM_PIN2;
            }
            else
            {
                stPinData.PinType = TAF_SIM_PIN;
            }

            /* 设置CmdType */
            stPinData.CmdType = TAF_PIN_CHANGE;

            /* 执行命令操作 */
            if(Taf_PhonePinHandle(gastAtClientTab[ucIndex].usClientId, 0,&stPinData) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPWD_CHANGE_PIN;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }

    case AT_CLCK_PS_TYPE:
        {
            TAF_ME_PERSONALISATION_DATA_STRU stMePersonalisationData;

            if((gastAtParaList[1].usParaLen > TAF_PH_PINCODELENMAX) || (gastAtParaList[2].usParaLen > TAF_PH_PINCODELENMAX))
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(&stMePersonalisationData, (VOS_SIZE_T)sizeof(stMePersonalisationData), 0x00, (VOS_SIZE_T)sizeof(stMePersonalisationData));

            /* 设置<oldpwd> */
            lMemResult = memcpy_s((VOS_VOID*)stMePersonalisationData.aucOldPwd, sizeof(stMePersonalisationData.aucOldPwd), (VOS_VOID*)gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMePersonalisationData.aucOldPwd), gastAtParaList[1].usParaLen);

            /* 设置<newpwd> */
            lMemResult = memcpy_s((VOS_CHAR*)stMePersonalisationData.aucNewPwd, sizeof(stMePersonalisationData.aucNewPwd), (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMePersonalisationData.aucNewPwd), gastAtParaList[2].usParaLen);

            /* 设置MePersonalType */
            stMePersonalisationData.MePersonalType = TAF_SIM_PERSONALISATION;

            /* 设置CmdType */
            stMePersonalisationData.CmdType = TAF_ME_PERSONALISATION_PWD_CHANGE;

            /* 执行命令操作 */
            if(Taf_MePersonalisationHandle(gastAtClientTab[ucIndex].usClientId, 0,&stMePersonalisationData) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPWD_CHANGE_PIN;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }


    default:
        {
            TAF_SS_REGPWD_REQ_STRU para;

            if((gastAtParaList[1].usParaLen > TAF_SS_MAX_PASSWORD_LEN) || (gastAtParaList[2].usParaLen > TAF_SS_MAX_PASSWORD_LEN))
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            memset_s(&para, sizeof(para), 0x00, sizeof(para));

            /* 设置<oldpwd> */
            lMemResult = memcpy_s((TAF_CHAR*)para.aucOldPwdStr, sizeof(para.aucOldPwdStr), (TAF_CHAR*)gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(para.aucOldPwdStr), gastAtParaList[1].usParaLen);

            /* 设置<newpwd> */
            lMemResult = memcpy_s((TAF_CHAR*)para.aucNewPwdStr, sizeof(para.aucNewPwdStr), (TAF_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(para.aucNewPwdStr), gastAtParaList[2].usParaLen);

            /* 设置<newpwd> */
            lMemResult = memcpy_s((TAF_CHAR*)para.aucNewPwdStrCnf, sizeof(para.aucNewPwdStrCnf), (TAF_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(para.aucNewPwdStrCnf), gastAtParaList[2].usParaLen);

            /* 设置SsCode */
            At_SsPrint2Code(&para.SsCode,(TAF_UINT8)gastAtParaList[0].ulParaValue);

            /* 执行命令操作 */
            if(TAF_RegisterPasswordReq(gastAtClientTab[ucIndex].usClientId, 0,&para) == AT_SUCCESS)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPWD_SET;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        }
    }
}

TAF_VOID At_SetDialIGPara(TAF_UINT8 ucIndex,TAF_UINT8 ucParaIndex,TAF_UINT8 *pClir, MN_CALL_CUG_CFG_STRU *pstCcug)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /*->A32D08138*/
    /* 默认情况是使用CCA设置的默认值 */

    *pClir   = pstSsCtx->ucClirType;
    *pstCcug = pstSsCtx->stCcugCfg;
    /*<-A32D08138*/

    switch(gastAtParaList[ucParaIndex].aucPara[0])
    {
    case 'i':
        *pClir = MN_CALL_CLIR_SUPPRESS;
        break;

    case 'I':
        *pClir = MN_CALL_CLIR_INVOKE;
        break;

    case 'g':
    case 'G':
        pstCcug->bEnable = 1;
        break;

    default:
        break;
    }

    switch(gastAtParaList[ucParaIndex + 1].aucPara[0])
    {
    case 'g':
    case 'G':
        pstCcug->bEnable = 1;
        break;

    default:
        break;
    }
}


TAF_UINT32 At_SetDialGprsPara(
    TAF_UINT8                           ucIndex,
    TAF_UINT8                           ucCid,
    TAF_GPRS_ACTIVE_TYPE_UINT8          enActiveType
)
{
    TAF_PPP_REQ_CONFIG_INFO_STRU        stPppReqConfigInfo;
    VOS_UINT16                          usPppId = 0;
    VOS_UINT8                           aucEventInfo[4];
    memset_s(&stPppReqConfigInfo, sizeof(stPppReqConfigInfo), 0x00, sizeof(TAF_PPP_REQ_CONFIG_INFO_STRU));

    /* 进行激活操作 */
    if(enActiveType == TAF_IP_ACTIVE_TE_PPP_MT_PPP_TYPE)    /* MT中启动PPP */
    {
        gastAtClientTab[ucIndex].ucCid = ucCid;   /* 保存当前指定的cid */

        if(Ppp_CreatePppReq(&usPppId) == AT_SUCCESS)    /* TE中启动了PPP，MT中启动PPP */
        {
            /*EVENT-At_SetDialGprsPara: usPppId/index*/
            aucEventInfo[0] = (TAF_UINT8)(usPppId >> 8);
            aucEventInfo[1] = (TAF_UINT8)usPppId;
            aucEventInfo[2] = ucIndex;
            AT_EventReport(WUEPS_PID_AT, NAS_OM_EVENT_DCE_CREATE_PPP,
                           aucEventInfo, sizeof(aucEventInfo));

            gastAtPppIndexTab[usPppId] = ucIndex;       /* 记录PPP id和Index的对应关系 */
            gastAtClientTab[ucIndex].usPppId = usPppId; /* 保存PPP id */

            At_SetMode(ucIndex,AT_DATA_MODE,AT_PPP_DATA_MODE);   /* 切换为PPP数传状态 */

            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_PPP_CALL_SET;

            return AT_CONNECT;
        }
        else
        {

            return AT_ERROR;
        }
    }
    else
    {
        stPppReqConfigInfo.stAuth.enAuthType = TAF_PDP_AUTH_TYPE_NONE;
        stPppReqConfigInfo.stIPCP.usIpcpLen  = 0;

        /* 创建透传的PPP实体 */
        if (Ppp_CreateRawDataPppReq(&usPppId) != AT_SUCCESS)
        {

            return AT_ERROR;
        }

        if ( TAF_PS_PppDialOrig(WUEPS_PID_AT,
                                AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                0,
                                ucCid,
                                &stPppReqConfigInfo) != VOS_OK )
        {
            PPP_RcvAtCtrlOperEvent(usPppId, PPP_AT_CTRL_REL_PPP_RAW_REQ);

            /*向PPP发送HDLC去使能操作*/
            PPP_RcvAtCtrlOperEvent(usPppId, PPP_AT_CTRL_HDLC_DISABLE);
            return AT_ERROR;
        }

        gastAtPppIndexTab[usPppId]          = ucIndex;  /* 记录PPP id和Index的对应关系 */
        gastAtClientTab[ucIndex].usPppId    = usPppId;  /* 保存PPP id */

        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_IP_CALL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
}



TAF_UINT32 At_SetDial98Para(TAF_UINT8 ucIndex)
{
    TAF_ATD_PARA_STRU                   stAtdPara;

    /* 初始化 */
    memset_s(&stAtdPara, sizeof(stAtdPara), 0x00, sizeof(TAF_ATD_PARA_STRU));

    /* CID存在 */
    if (gastAtParaList[4].usParaLen != 0)
    {
        if(At_Auc2ul(gastAtParaList[4].aucPara,gastAtParaList[4].usParaLen,&gastAtParaList[4].ulParaValue) == AT_FAILURE)
        {
            return AT_ERROR;
        }

        if(gastAtParaList[4].ulParaValue > 0xFF)   /* 需要检查，否则过界 */
        {
            return AT_ERROR;
        }

        /* 获取当前用户输入的CID */
        stAtdPara.ucCid = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    }
    else
    {
        /* 设置默认CID */
        stAtdPara.ucCid = AT_DIAL_DEFAULT_CID;
    }

    /* 获取GPRS激活类型 */
    if ( TAF_PS_GetGprsActiveType(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  0,
                                  &stAtdPara) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetDial99Para(VOS_UINT8 ucIndex)
{
    VOS_INT32                           lParaPPPFlg;
    VOS_INT32                           lParaNULLFlg;
    VOS_UINT8                           ucTmp;
    VOS_UINT8                           ucStar;
    VOS_UINT8                           ucL2pIndex;
    VOS_UINT8                           ucCidIndex;
    TAF_ATD_PARA_STRU                   stAtdPara;

    /* 初始化 */
    ucTmp      = 0;
    ucStar     = 0;
    ucL2pIndex = 0;
    ucCidIndex = 0;
    memset_s(&stAtdPara, sizeof(stAtdPara), 0x00, sizeof(TAF_ATD_PARA_STRU));

    /* 解析参数列表 */
    for (ucTmp = 1; ucTmp < gucAtParaIndex; ucTmp++)
    {
        if (gastAtParaList[ucTmp].aucPara[0] == '*')
        {
            ucStar++;
        }
        else
        {
            switch (ucStar)
            {
                case 1:
                case 2:
                    break;

                case 3:
                    ucL2pIndex = ucTmp;
                    break;

                case 4:
                    ucCidIndex = ucTmp;
                    break;

                default:
                    return AT_ERROR;
            }
        }
    }

    /* 获取CID: 不存在CID参数时, 取默认值1 */
    if (ucCidIndex != 0)
    {
        if (At_Auc2ul(gastAtParaList[ucCidIndex].aucPara,gastAtParaList[ucCidIndex].usParaLen,&gastAtParaList[ucCidIndex].ulParaValue) == AT_FAILURE)
        {
            return AT_ERROR;
        }

        /* 需要检查，否则过界 */
        if (gastAtParaList[ucCidIndex].ulParaValue > 0xFF)
        {
            return AT_ERROR;
        }

        stAtdPara.ucCid = (VOS_UINT8)gastAtParaList[ucCidIndex].ulParaValue;
    }
    else
    {
        stAtdPara.ucCid = AT_DIAL_DEFAULT_CID;
    }

    /* 获取L2P协议类型: 兼容不支持的协议类型 */
    if (ucL2pIndex != 0)
    {
        lParaPPPFlg =  VOS_StrCmp((TAF_CHAR*)gastAtParaList[ucL2pIndex].aucPara,"1");
        lParaNULLFlg = VOS_StrCmp((TAF_CHAR*)gastAtParaList[ucL2pIndex].aucPara,"0");

        if ( (VOS_StrCmp((TAF_CHAR*)gastAtParaList[ucL2pIndex].aucPara,"PPP") == 0)
          || (lParaPPPFlg == 0) )
        {
            stAtdPara.bitOpL2p  = VOS_TRUE;
            stAtdPara.enL2p     = TAF_L2P_PPP;
        }
        else if ( (VOS_StrCmp((TAF_CHAR*)gastAtParaList[ucL2pIndex].aucPara,"NULL") == 0)
               || (lParaNULLFlg == 0) )
        {
            stAtdPara.bitOpL2p  = VOS_TRUE;
            stAtdPara.enL2p     = TAF_L2P_NULL;
        }
        else
        {
            ;
        }
    }
    else
    {
        ;
    }

    /* 获取GPRS激活类型 */
    if ( TAF_PS_GetGprsActiveType(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  0,
                                  &stAtdPara) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetDial777Para(TAF_UINT8 ucIndex)
{
    TAF_ATD_PARA_STRU                   stAtdPara;

    /* 初始化 */
    memset_s(&stAtdPara, sizeof(stAtdPara), 0x00, sizeof(TAF_ATD_PARA_STRU));

    /* 设置默认CID */
    stAtdPara.ucCid = AT_DIAL_DEFAULT_CID;

    /* 获取GPRS激活类型 */
    if ( TAF_PS_GetGprsActiveType(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  0,
                                  &stAtdPara) != VOS_OK )
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_FillCalledNumPara(
    VOS_UINT8                          *pucAtPara,
    VOS_UINT16                          usLen,
    MN_CALL_CALLED_NUM_STRU            *pstCalledNum
)
{
    VOS_UINT32                          ulRelt;

    /* 号码类型检查 */
    if (*pucAtPara == '+')
    {
        /* 国际号码的第一个字符不需要编码,最多可以为81个字符 */
        if (usLen > (MN_CALL_MAX_CALLED_ASCII_NUM_LEN + 1))
        {
            return VOS_ERR;
        }

        *(pucAtPara + usLen) = '\0';
        pucAtPara  += 1;

        pstCalledNum->enNumType
            = (MN_CALL_IS_EXIT | (MN_CALL_TON_INTERNATIONAL << 4) | MN_CALL_NPI_ISDN);
    }
    else
    {
        /* 国内号码或未知号码最多可以为80个字符 */
        if (usLen > MN_CALL_MAX_CALLED_ASCII_NUM_LEN)
        {
            return VOS_ERR;
        }

        *(pucAtPara + usLen) = '\0';

        pstCalledNum->enNumType
            = (MN_CALL_IS_EXIT | (MN_CALL_TON_UNKNOWN << 4) | MN_CALL_NPI_ISDN);
    }

    ulRelt = AT_AsciiNumberToBcd((VOS_CHAR *)pucAtPara,
                                 pstCalledNum->aucBcdNum,
                                 &pstCalledNum->ucNumLen);

    if (ulRelt != MN_ERR_NO_ERROR)
    {
        return VOS_ERR;
    }

    AT_JudgeIsPlusSignInDialString((VOS_CHAR *)pucAtPara,
                                   &pstCalledNum->ucIsExistPlusSign,
                                   &pstCalledNum->ucPlusSignLocation);

    return VOS_OK;
}


TAF_UINT32 At_SetDialNumPara(TAF_UINT8 ucIndex,MN_CALL_TYPE_ENUM_U8 CallType)
{
    MN_CALL_ORIG_PARAM_STRU             stOrigParam;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    MODEM_ID_ENUM_UINT16                enModemId;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /*目前华为移动的AT命令的需求，应该只要满足一般的语音呼叫即可*/

    /* 初始化 */
    memset_s(&stOrigParam, sizeof(stOrigParam), 0x00, sizeof(stOrigParam));

    /* 设置<dial_string> */
    if (AT_FillCalledNumPara(gastAtParaList[1].aucPara,
                             gastAtParaList[1].usParaLen,
                             &stOrigParam.stDialNumber) != VOS_OK)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stOrigParam.enCallType = CallType;

    At_SetDialIGPara(ucIndex,2,&stOrigParam.enClirCfg,&stOrigParam.stCugCfg);

    stOrigParam.enCallMode = pstSsCtx->enCModType;

    stOrigParam.stDataCfg = pstSsCtx->stCbstDataCfg;

    /* 考虑数据卡的接口，这里的定义视频呼叫域为3GPP的 */
    if (CallType == MN_CALL_TYPE_VIDEO)
    {
        stOrigParam.enVoiceDomain = TAF_CALL_VOICE_DOMAIN_3GPP;
    }
    else
    {
        stOrigParam.enVoiceDomain = TAF_CALL_VOICE_DOMAIN_AUTO;
    }

    /* 遗留问题6、呼叫接口，需要增加设置I、G的参数；需要修改D命令实现 */

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stOrigParam,
                              ID_TAF_CCM_CALL_ORIG_REQ,
                              sizeof(stOrigParam),
                              enModemId) == VOS_OK)
    {
        if(CallType == MN_CALL_TYPE_VOICE)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_CS_VOICE_CALL_SET;
        }
        else
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_CS_DATA_CALL_SET;
        }
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);

        return AT_ERROR;
    }
}

VOS_UINT32 At_DialNumByIndexFromPb(VOS_UINT8              ucIndex,
                                            SI_PB_EVENT_INFO_STRU  *pEvent)
{
    errno_t                             lMemResult;

    /*将从电话本读到的号码写入gastAtParaList[1].aucPara*/
    lMemResult = memcpy_s(&gastAtParaList[1].aucPara[0],
                          AT_PARA_MAX_LEN + 1,
                          pEvent->PBEvent.PBReadCnf.PBRecord.Number,
                          TAF_MIN(pEvent->PBEvent.PBReadCnf.PBRecord.NumberLength, SI_PB_PHONENUM_MAX_LEN));
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_PARA_MAX_LEN + 1, TAF_MIN(pEvent->PBEvent.PBReadCnf.PBRecord.NumberLength, SI_PB_PHONENUM_MAX_LEN));
    gastAtParaList[1].aucPara[pEvent->PBEvent.PBReadCnf.PBRecord.NumberLength] = '\0';
    gastAtParaList[1].usParaLen = pEvent->PBEvent.PBReadCnf.PBRecord.NumberLength;
    /* D[<dial_string>][I][G][;] */
    return At_SetDialNumPara(ucIndex,gastAtClientTab[ucIndex].AtCallInfo.CallType);
}

/*****************************************************************************
 Prototype      : At_SetDialVoiceIndexPara
 Description    : D><n>[I][G][;]
 Input          : ucIndex --- 用户索引
                  CallType --- 呼叫类型
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetDialVoiceIndexPara(TAF_UINT8 ucIndex, MN_CALL_TYPE_ENUM_U8 enCallType)
{
    TAF_UINT32 uLIndex = 0;
    SI_PB_STORATE_TYPE  Storage = SI_PB_STORAGE_UNSPECIFIED;

    if(At_Auc2ul(gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen,&uLIndex) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].AtCallInfo.CallType = enCallType;

    At_SetDialIGPara(ucIndex,3,&gastAtClientTab[ucIndex].AtCallInfo.ClirInfo,&gastAtClientTab[ucIndex].AtCallInfo.CugMode);

    if ( SI_PB_Read( gastAtClientTab[ucIndex].usClientId,
                     0,
                     Storage,
                     (TAF_UINT16)uLIndex,
                     (TAF_UINT16)uLIndex) == AT_SUCCESS
        )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_GET_NUMBER_BEFORE_CALL;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}
/*****************************************************************************
 Prototype      : At_SetDialVoiceNamePara
 Description    : D><name>[I][G][;]
 Input          : ucIndex --- 用户索引
                  CallType --- 呼叫类型
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetDialVoiceNamePara(TAF_UINT8 ucIndex,MN_CALL_TYPE_ENUM_U8 CallType)
{

    if(At_CheckNumLen(SI_PB_ALPHATAG_MAX_LEN,gastAtParaList[2].usParaLen) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    if(At_CheckStringPara(&gastAtParaList[2]) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    /* 设置ucAlphaTagType */
    if(gucAtCscsType == AT_CSCS_UCS2_CODE)
    {
        if(At_UnicodePrint2Unicode(gastAtParaList[2].aucPara,&gastAtParaList[2].usParaLen) == AT_FAILURE)
        {
            return AT_ERROR;
        }
    }

    gastAtClientTab[ucIndex].AtCallInfo.CallType = CallType;

    At_SetDialIGPara(ucIndex,3,&gastAtClientTab[ucIndex].AtCallInfo.ClirInfo,&gastAtClientTab[ucIndex].AtCallInfo.CugMode);


    return AT_ERROR;
}

TAF_UINT32 At_SetDialVoiceMemPara(TAF_UINT8 ucIndex, MN_CALL_TYPE_ENUM_U8 CallType)
{
    TAF_UINT32 uLIndex = 0;
    SI_PB_STORATE_TYPE  Storage = SI_PB_STORAGE_UNSPECIFIED;

    if(At_Auc2ul(gastAtParaList[3].aucPara,gastAtParaList[3].usParaLen,&uLIndex) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    if(VOS_StrCmp((TAF_CHAR*)"SM",(TAF_CHAR*)gastAtParaList[2].aucPara) == 0)
    {
        Storage = SI_PB_STORAGE_SM;
    }
    else
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].AtCallInfo.CallType = CallType;

    At_SetDialIGPara(ucIndex,4,&gastAtClientTab[ucIndex].AtCallInfo.ClirInfo,&gastAtClientTab[ucIndex].AtCallInfo.CugMode);

    if ( SI_PB_Read ( gastAtClientTab[ucIndex].usClientId,
                      0,
                      Storage,
                      (TAF_UINT16)uLIndex,
                      (TAF_UINT16)uLIndex) == AT_SUCCESS
        )
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_D_GET_NUMBER_BEFORE_CALL;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32  At_CheckAtDPin(VOS_UINT8 ucIndex)
{
    TAF_UINT32                          ulRst;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulGetModemIdRslt;
    AT_USIM_INFO_CTX_STRU              *pstUsimInfoCtx = VOS_NULL_PTR;

    enModemId = MODEM_ID_0;

    ulGetModemIdRslt = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulGetModemIdRslt != VOS_OK)
    {
        AT_ERR_LOG("At_CheckAtDPin:Get Modem Id fail!");
        return AT_ERROR;
    }

    pstUsimInfoCtx = AT_GetUsimInfoCtxFromModemId(enModemId);


    /*SIM卡状态判断*/
    switch (pstUsimInfoCtx->enCardStatus)
    {
        /* 仅替换消息类型 */
        case USIMM_CARDAPP_SERVIC_AVAILABLE:
            ulRst = AT_SUCCESS;
            break;
        case USIMM_CARDAPP_SERVIC_SIM_PIN:
            ulRst = AT_CME_SIM_PIN_REQUIRED;
            break;
        case USIMM_CARDAPP_SERVIC_SIM_PUK:
            ulRst = AT_CME_SIM_PUK_REQUIRED;
            break;
        case USIMM_CARDAPP_SERVIC_UNAVAILABLE:
        case USIMM_CARDAPP_SERVIC_NET_LCOK:
        case USIMM_CARDAPP_SERVICE_IMSI_LOCK:
            ulRst = AT_CME_SIM_FAILURE;
            break;
        case USIMM_CARDAPP_SERVIC_ABSENT:
            ulRst = AT_CME_SIM_NOT_INSERTED;
            break;
        default:
            ulRst = AT_ERROR;
            break;
    }

    return ulRst;
}


TAF_UINT32  At_PsDPara(TAF_UINT8 ucIndex)
{
    TAF_UINT32    ulRst;

    ulRst = At_CheckAtDPin(ucIndex);
    if (ulRst != AT_SUCCESS)
    {
        return ulRst;
    }

    if(At_CheckSemicolon(gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen - 1]) == AT_SUCCESS) /* 如果带分号,D*752#+436644101453; */
    {

        /* D*752#+436644101453; */
        gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen - 1] = 0;
        gastAtParaList[0].usParaLen--;
    }
    else if(gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen - 1] == '#')
    {
        if(VOS_StrNiCmp((TAF_CHAR*)gastAtParaList[2].aucPara,"98", gastAtParaList[2].usParaLen) == 0)
        {
            /* D*<GPRS_SC_IP>[*<cid>[,<cid>]]# */
            return At_SetDial98Para(ucIndex);
        }
        else if(VOS_StrNiCmp((TAF_CHAR*)gastAtParaList[2].aucPara,"99", gastAtParaList[2].usParaLen) == 0)
        {
            /* D*<GPRS_SC>[*[<called_address>][*[<L2P>][*[<cid>]]]]# */
            return At_SetDial99Para(ucIndex);
        }
        else if(VOS_StrNiCmp((TAF_CHAR*)gastAtParaList[2].aucPara, "777", gastAtParaList[2].usParaLen) == 0)
        {
            return At_SetDial777Para(ucIndex);
        }
        else
        {

        }
    }
    else
    {

    }
    return AT_ERROR;

}



VOS_UINT8 At_JudgeIfIsPsCall(VOS_VOID)
{
    VOS_UINT8                           ucPsCallFlg;

    if (gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen - 1] != '#')
    {
        ucPsCallFlg = VOS_FALSE;
    }
    else if (AT_CheckStrStartWith(&gastAtParaList[0].aucPara[1], gastAtParaList[0].usParaLen, (VOS_UINT8 *)"*98", AT_DATA_DIAL_LEN))
    {
        ucPsCallFlg = VOS_TRUE;
    }
    else if (AT_CheckStrStartWith(&gastAtParaList[0].aucPara[1], gastAtParaList[0].usParaLen, (VOS_UINT8 *)"*99", AT_DATA_DIAL_LEN))
    {
        ucPsCallFlg = VOS_TRUE;
    }
    else if (AT_CheckStrStartWith(&gastAtParaList[1].aucPara[0], gastAtParaList[1].usParaLen, (VOS_UINT8 *)"#777", AT_CDATA_DIAL_777_LEN) )
    {
        ucPsCallFlg = VOS_TRUE;
    }
    else
    {
        ucPsCallFlg = VOS_FALSE;
    }

    return ucPsCallFlg;
}

TAF_UINT32 At_SetDPara(TAF_UINT8 ucIndex)
{
    /* cS call */
    if(At_JudgeIfIsPsCall() != VOS_TRUE)
    {
        MN_CALL_TYPE_ENUM_U8 CallType = MN_CALL_TYPE_VOICE;

        g_ucDtrDownFlag = VOS_FALSE;
#if (FEATURE_ECALL == FEATURE_ON)
        /* 当前有ecall正在通话或者发起 */
        if (AT_HaveEcallActive(ucIndex, VOS_FALSE) == VOS_TRUE)
        {
            return AT_NO_CARRIER;
        }
#endif/* FEATURE_ECALL == FEATURE_ON */
        if(gastAtParaList[0].aucPara[gastAtParaList[0].usParaLen - 1] != ';')
        {
            CallType = MN_CALL_TYPE_VIDEO;
        }

        if(gastAtParaList[1].aucPara[0] == '>')
        {
            if((gastAtParaList[2].aucPara[0] >= 'A') && (gastAtParaList[2].aucPara[0] <= 'Z'))
            {
                /* D>mem<n>[I][G][;] */
                return At_SetDialVoiceMemPara(ucIndex,CallType);
            }
            else if((gastAtParaList[2].aucPara[0] >= '0') && (gastAtParaList[2].aucPara[0] <= '9'))
            {
                /* D><n>[I][G][;] */
                return At_SetDialVoiceIndexPara(ucIndex,CallType);
            }
            else
            {
                /* D><name>[I][G][;] */
                return At_SetDialVoiceNamePara(ucIndex,CallType);
            }
        }
        else
        {
            /* D[<dial_string>][I][G][;] */
            return At_SetDialNumPara(ucIndex,CallType);
        }
    }
    else
    {
        return At_PsDPara(ucIndex);
    }

}


TAF_UINT32 At_SetAPara(TAF_UINT8 ucIndex)
{
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_SUPS_PARAM_STRU             stSupsCmdPara;
    VOS_UINT32                          ulTimerId;

    VOS_UINT8                           ucNumOfCalls;
    VOS_UINT8                           ucTmp;
    VOS_UINT32                          ulRlst;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    TAFAGENT_CALL_INFO_PARAM_STRU       astCallInfos[MN_CALL_MAX_NUM];
    MODEM_ID_ENUM_UINT16                enModemId;

    pstCcCtx = AT_GetModemCcCtxAddrFromClientId(ucIndex);

    memset_s(astCallInfos, sizeof(astCallInfos), 0x00, sizeof(astCallInfos));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /*从同步API获取通话信息*/
    ulRlst = TAF_AGENT_GetCallInfoReq(gastAtClientTab[ucIndex].usClientId,
                                      &ucNumOfCalls,
                                      astCallInfos);

    if (ulRlst != VOS_OK)
    {
        return AT_ERROR;
    }

    if (ucNumOfCalls == 0)
    {
        return AT_NO_CARRIER;
    }

    for (ucTmp = 0; ucTmp < ucNumOfCalls; ucTmp++)
    {
        /*设置了自动接听的情况下如果呼叫已经处于incoming态，再触发ATA操作，返回ok*/
        if ((astCallInfos[ucTmp].enCallState == MN_CALL_S_INCOMING)
             && (pstCcCtx->stS0TimeInfo.ucS0TimerLen != 0)
             && (pstCcCtx->stS0TimeInfo.bTimerStart == TAF_FALSE))
        {
            return AT_OK;
        }
        /*设置了自动接听的情况下如果呼叫已经处于非incoming态，再触发ATA操作，返回error*/
        else if ((pstCcCtx->stS0TimeInfo.ucS0TimerLen != 0)
              && (pstCcCtx->stS0TimeInfo.bTimerStart == TAF_FALSE))
        {
            return AT_NO_CARRIER;
        }
        /* 呼叫已经是active状态再收到ata直接回复ok */
        else if (astCallInfos[ucTmp].enCallState == MN_CALL_S_ACTIVE)
        {
            return AT_OK;
        }
        else
        {
        }
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stSupsCmdPara, sizeof(stSupsCmdPara), 0x00, sizeof(stSupsCmdPara));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stSupsCmdPara.enCallSupsCmd = MN_CALL_SUPS_CMD_HOLD_ACT_ACPT_OTH;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stSupsCmdPara,
                              ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                              sizeof(stSupsCmdPara),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_A_SET;
        if (pstCcCtx->stS0TimeInfo.bTimerStart == TAF_TRUE)
        {
            ulTimerId = pstCcCtx->stS0TimeInfo.ulTimerName;

            AT_StopRelTimer(ulTimerId, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_NO_CARRIER;
    }
}


VOS_UINT32 AT_MODEM_HangupCall(VOS_UINT8 ucIndex)
{
    AT_UART_LINE_CTRL_STRU             *pstLineCtrl = VOS_NULL_PTR;
    VOS_UINT32                          ulRslt;

    pstLineCtrl = AT_GetUartLineCtrlInfo();

    /* ONLINE-COMMAND模式下, 需要断开PPP拨号连接 */
    if (gastAtClientTab[ucIndex].Mode == AT_ONLINE_CMD_MODE)
    {
        /* 正在处理PPP断开请求, 直接继承, 设置命令操作类型为AT_CMD_H_PS_SET */
        if (gastAtClientTab[ucIndex].CmdCurrentOpt == AT_CMD_PS_DATA_CALL_END_SET)
        {
            AT_STOP_TIMER_CMD_READY(ucIndex);
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_H_PS_SET;
            ulRslt = AT_WAIT_ASYNC_RETURN;
        }
        /* 正在等待PPP的释放响应, 直接释放, 返回OK */
        else if (gastAtClientTab[ucIndex].CmdCurrentOpt == AT_CMD_WAIT_PPP_PROTOCOL_REL_SET)
        {
            AT_STOP_TIMER_CMD_READY(ucIndex);
            At_SetMode(ucIndex, AT_CMD_MODE, AT_NORMAL_MODE);
            At_FormatResultData(ucIndex, AT_OK);

            if (pstLineCtrl->enDcdMode == AT_UART_DCD_MODE_CONNECT_ON)
            {
                AT_CtrlDCD(ucIndex, AT_IO_LEVEL_LOW);
            }

            ulRslt = AT_SUCCESS;
        }
        else
        {
            (VOS_VOID)TAF_PS_CallEnd(WUEPS_PID_AT,
                                     AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                     0,
                                     gastAtClientTab[ucIndex].ucCid);

            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_H_PS_SET;
            ulRslt = AT_WAIT_ASYNC_RETURN;
        }
    }
    /* 其他模式下, 默认直接返回OK */
    else
    {
        ulRslt = AT_OK;
    }

    return ulRslt;
}


VOS_UINT32 At_SetHPara(VOS_UINT8 ucIndex)
{
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_SUPS_PARAM_STRU             stSupsCmdPara;

    MODEM_ID_ENUM_UINT16                enModemId;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;

    /* 删除通道数传模式标识存在直接返回OK的处理 */

    /*对Modem口进行特殊处理: 收到ATH直接返回OK，
      即使Modem口发起过呼叫也不执行挂断操作*/
    if ((gastAtClientTab[ucIndex].UserType == AT_MODEM_USER)
     && (gastAtClientTab[ucIndex].ucUsed == AT_CLIENT_USED))
    {
        return AT_OK;
    }

    /* 增加通道模式判断:
     * (1) ONLINE-COMMAND模式 - 断开当前通道的PPP拨号连接
     * (2) COMMAND模式        - 直接返回OK
     */
    if (gastAtClientTab[ucIndex].UserType == AT_HSUART_USER)
    {
        return AT_MODEM_HangupCall(ucIndex);
    }

    /* 获取ModemID */
    if (AT_GetModemIdFromClient(ucIndex, &enModemId) != VOS_OK)
    {
        AT_LOG1("At_SetHPara AT_GetModemIdFromClient fail", ucIndex);
        return AT_ERROR;
    }

    /* 获取CC上下文 */
    pstCcCtx = AT_GetModemCcCtxAddrFromModemId(enModemId);

    /* 根据协议27007，如果CVHU设置为1时，不支持ATH挂断语音，所以在这里直接返回OK。如果CVHU为其他值，支持ATH挂断语音 */
    if (pstCcCtx->enCvhuMode == CVHU_MODE_1)
    {
        AT_LOG1("At_SetHPara pstCcCtx->enCvhuMode", pstCcCtx->enCvhuMode);
        return AT_OK;
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stSupsCmdPara, sizeof(stSupsCmdPara), 0x00, sizeof(stSupsCmdPara));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stSupsCmdPara.enCallSupsCmd  = MN_CALL_SUPS_CMD_REL_ALL_CALL;

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stSupsCmdPara,
                              ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                              sizeof(stSupsCmdPara),
                              enModemId) == VOS_OK)
    {
        /* 停止自动接听 */
        if (pstCcCtx->stS0TimeInfo.bTimerStart == VOS_TRUE)
        {
            AT_StopRelTimer(pstCcCtx->stS0TimeInfo.ulTimerName, &(pstCcCtx->stS0TimeInfo.s0Timer));
            pstCcCtx->stS0TimeInfo.bTimerStart = TAF_FALSE;
            pstCcCtx->stS0TimeInfo.ulTimerName = 0;
        }

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_H_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
/*****************************************************************************
 Prototype      : At_SetEPara
 Description    : E[<value>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetEPara(TAF_UINT8 ucIndex)
{
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtEType = (AT_CMD_ECHO_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtEType = AT_E_ECHO_CMD;
    }
    return AT_OK;
}

TAF_UINT32 At_SetVPara(TAF_UINT8 ucIndex)
{
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtVType = (AT_V_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtVType = AT_V_ENTIRE_TYPE;
    }
    return AT_OK;
}

TAF_UINT32 At_SetTPara(TAF_UINT8 ucIndex)
{
    /* 参考Q的实现:This commands will have no effect in our code*/
    return AT_OK;
}

TAF_UINT32 At_SetPPara(TAF_UINT8 ucIndex)
{
    /* 参考Q的实现:This commands will have no effect in our code*/
    return AT_OK;
}

TAF_UINT32 At_SetXPara(TAF_UINT8 ucIndex)
{
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtXType = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtXType = 0;
    }
    return AT_OK;
}

TAF_UINT32 At_SetZPara(TAF_UINT8 ucIndex)
{
    TAF_AT_TZ_STRU                      stTz;
    VOS_CHAR                            acTzStr[AT_SETZ_LEN+1];

    VOS_UINT16                          usLength;
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;
    errno_t                             lMemResult;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();

    memset_s(&stTz, sizeof(stTz), 0x00, sizeof(stTz));

    if ( *pucSystemAppConfig == SYSTEM_APP_WEBUI)
    {
        if (NV_OK == TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_ATSETZ_RET_VALUE, &stTz,
                             AT_SETZ_LEN))
        {
            lMemResult = memcpy_s(acTzStr, sizeof(acTzStr), stTz.acTz, AT_SETZ_LEN);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(acTzStr), AT_SETZ_LEN);
            acTzStr[AT_SETZ_LEN] = 0;
            if ( VOS_StrLen(acTzStr) > 0 )
            {
                usLength  = 0;
                usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                 (VOS_CHAR *)pgucAtSndCodeAddr,
                                                 (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                                 "%s",gaucAtCrLf);
                usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                  (VOS_CHAR *)pgucAtSndCodeAddr,
                                                  (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                                  "%s",acTzStr);
                usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                 (VOS_CHAR *)pgucAtSndCodeAddr,
                                                 (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                                 "%s",gaucAtCrLf);

                At_SendResultData((VOS_UINT8)ucIndex,pgucAtSndCodeAddr,usLength);

                return AT_SUCCESS;
            }
        }
    }

    return AT_OK;
}

TAF_UINT32 At_SetQPara(TAF_UINT8 ucIndex)
{
    if(gastAtParaList[0].usParaLen != 0)
    {
        gucAtQType = (AT_CMD_ECHO_TYPE)gastAtParaList[0].ulParaValue;
    }
    else
    {
        gucAtQType = 0;
    }
    return AT_OK;
}


VOS_UINT32 At_SetAmpCPara(VOS_UINT8 ucIndex)
{
    AT_UART_CTX_STRU                   *pstUartCtx = VOS_NULL_PTR;
    AT_UART_DCD_MODE_ENUM_UINT8         enDcdMode;

    pstUartCtx = AT_GetUartCtxAddr();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        if ((gastAtParaList[0].ulParaValue != 0)
         && (gastAtParaList[0].ulParaValue != 1))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        enDcdMode = (AT_UART_DCD_MODE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* AT&C 等效于 AT&C1 */
        enDcdMode = AT_UART_DEFAULT_DCD_MODE;
    }

    /* 保存DCD Line Mode至上下文 */
    pstUartCtx->stLineCtrl.enDcdMode = enDcdMode;

    /* DCD管脚操作 */
    if(enDcdMode == AT_UART_DCD_MODE_ALWAYS_ON)
    {
        AT_CtrlDCD(ucIndex, AT_IO_LEVEL_HIGH);
    }
    else
    {
        if (gastAtClientTab[ucIndex].Mode == AT_CMD_MODE)
        {
            AT_CtrlDCD(ucIndex, AT_IO_LEVEL_LOW);
        }
    }

    return AT_OK;
}


VOS_UINT32 At_SetAmpDPara(VOS_UINT8 ucIndex)
{
    AT_UART_CTX_STRU                   *pstUartCtx = VOS_NULL_PTR;
    AT_UART_DTR_MODE_ENUM_UINT8         enDtrMode;

    pstUartCtx = AT_GetUartCtxAddr();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        enDtrMode = (AT_UART_DTR_MODE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* AT&D 等效于 AT&D2 */
        enDtrMode = AT_UART_DEFAULT_DTR_MODE;
    }

    /* 保存DTR Line Mode至上下文 */
    pstUartCtx->stLineCtrl.enDtrMode = enDtrMode;

    return AT_OK;
}

#if (FEATURE_AT_HSUART == FEATURE_ON)

VOS_UINT32 At_SetAmpSPara(VOS_UINT8 ucIndex)
{
    AT_UART_CTX_STRU                   *pstUartCtx = VOS_NULL_PTR;
    AT_UART_DSR_MODE_ENUM_UINT8         enDsrMode;
    AT_IO_LEVEL_ENUM_UINT8              enIoLevel;

    pstUartCtx = AT_GetUartCtxAddr();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen != 0)
    {
        enDsrMode = (AT_UART_DSR_MODE_ENUM_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* AT&S 等效于 AT&S0 */
        enDsrMode = AT_UART_DEFAULT_DSR_MODE;
    }

    /* 设置DSR 管脚信号 */
    enIoLevel = (AT_UART_DSR_MODE_ALWAYS_ON == enDsrMode) ? AT_IO_LEVEL_HIGH : AT_IO_LEVEL_LOW;
    AT_CtrlDSR(ucIndex, enIoLevel);

    /* 保存DSR Line Mode至上下文*/
    pstUartCtx->stLineCtrl.enDsrMode = enDsrMode;

    return AT_OK;
}
#endif


VOS_UINT32 AT_SetLPara(VOS_UINT8 ucIndex)
{
    return AT_OK;
}


VOS_UINT32 AT_SetMPara(VOS_UINT8 ucIndex)
{
    return AT_OK;
}




TAF_UINT32 At_SetFPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    /* 被if 0的代码为日本运营商的定制需求，恢复8229和8265两个NV项。但后来要求需求回退，考虑到后面又有可能需要该需求，就用#if 0关闭了。*/

    /*因为MODEN拨号会下发该命令，所以在moden口不进行NV恢复，直接返回OK*/
    if ( (gastAtClientTab[ucIndex].UserType == AT_MODEM_USER)
      || (gastAtClientTab[ucIndex].UserType == AT_HSUART_USER) )
    {
        return AT_OK;
    }
    if ( g_bSetFlg == VOS_TRUE )
    {
        return AT_OK;
    }

    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_NVRESTORE_MANU_DEFAULT_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRet == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_F_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }


}


TAF_UINT32 At_SetS0Para(TAF_UINT8 ucIndex)
{
    TAF_CCA_TELE_PARA_STRU              stTimeInfo;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRslt;

    enModemId = MODEM_ID_0;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 删除通道数传模式标识存在直接返回OK的处理 */

    ulRslt = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRslt != VOS_OK)
    {
        AT_ERR_LOG("At_SetS0Para: Get modem id fail.");
        return AT_ERROR;
    }

    pstCcCtx = AT_GetModemCcCtxAddrFromModemId(enModemId);

    pstCcCtx->stS0TimeInfo.ucS0TimerLen = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    pstCcCtx->stS0TimeInfo.usClientId   = gastAtClientTab[ucIndex].usClientId;

    memset_s(&stTimeInfo, sizeof(stTimeInfo), 0x00, sizeof(stTimeInfo));

    if (TAF_ACORE_NV_READ(enModemId, en_NV_Item_CCA_TelePara, &stTimeInfo, sizeof(TAF_CCA_TELE_PARA_STRU)) == NV_OK)
    {
        if ( stTimeInfo.ucS0TimerLen == pstCcCtx->stS0TimeInfo.ucS0TimerLen )
        {
            AT_INFO_LOG("At_SetS0Para():The content to write is same as NV's");
            return AT_OK;
        }
    }
    stTimeInfo.ucS0TimerLen = pstCcCtx->stS0TimeInfo.ucS0TimerLen;
    if (TAF_ACORE_NV_WRITE(enModemId, en_NV_Item_CCA_TelePara, &stTimeInfo, sizeof(TAF_CCA_TELE_PARA_STRU)) != NV_OK)
    {
        return AT_ERROR;
    }

    return AT_OK;
}
/*****************************************************************************
 Prototype      : At_SetS3Para
 Description    : S3=[<value>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetS3Para(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucAtS3 = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucAtS3 = 13;
    }
    gaucAtCrLf[0] = ucAtS3;
    return AT_OK;
}
/*****************************************************************************
 Prototype      : At_SetS4Para
 Description    : S4=[<value>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetS4Para(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucAtS4 = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucAtS4 = 10;
    }
    gaucAtCrLf[1] = ucAtS4;
    return AT_OK;
}
/*****************************************************************************
 Prototype      : At_SetS5Para
 Description    : S5=[<value>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetS5Para(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucAtS5 = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        ucAtS5 = 8;
    }
    return AT_OK;
}

TAF_UINT32 At_SetS6Para(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        ucAtS6 = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* refer to V.250:
           Recommended default setting
           2       Wait two seconds before blind dialling
         */
        ucAtS6 = 2;
    }
    return AT_OK;
}

TAF_UINT32 At_SetS7Para(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
      refer to V.250:
      S7:Number of seconds in which connection must be established or call will be disconnected
     */
    if(gastAtParaList[0].usParaLen != 0)
    {
        ucAtS7 = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* 参考Q实现，默认值填写为50 */
        ucAtS7 = 50;
    }
    return AT_OK;
}


VOS_VOID AT_SetDefaultRatPrioList(
    MODEM_ID_ENUM_UINT16                enModemId,
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstSysCfgRatOrder,
    VOS_UINT8                           ucUserSptLteFlag,
    VOS_UINT8                           ucUserSptNrFlag
)
{
    VOS_UINT8                           ucUserRatNum;

    ucUserRatNum = 0;

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    /* 当前命令是否支持NR */
    if (ucUserSptNrFlag == VOS_TRUE)
    {
        /* 平台支持NR */
        if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_NR) == VOS_TRUE)
        {
             pstSysCfgRatOrder->aenRatOrder[ucUserRatNum] = TAF_MMA_RAT_NR;

             ucUserRatNum++;
        }
    }
#endif

#if(FEATURE_LTE == FEATURE_ON)
    /* 当前命令是否支持LTE */
    if (ucUserSptLteFlag == VOS_TRUE)
    {
        /* 平台支持LTE */
        if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_LTE) == VOS_TRUE)
        {
             pstSysCfgRatOrder->aenRatOrder[ucUserRatNum] = TAF_MMA_RAT_LTE;

             ucUserRatNum++;
        }
    }
#endif

    /* 平台支持WCDMA */
    if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_WCDMA) == VOS_TRUE)
    {
         pstSysCfgRatOrder->aenRatOrder[ucUserRatNum] = TAF_MMA_RAT_WCDMA;

         ucUserRatNum++;
    }

    /* 平台支持GSM */
    if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_GSM) == VOS_TRUE)
    {
         pstSysCfgRatOrder->aenRatOrder[ucUserRatNum] = TAF_MMA_RAT_GSM;

         ucUserRatNum++;
    }

    pstSysCfgRatOrder->ucRatNum = ucUserRatNum;


    return;
}


VOS_VOID AT_GetGuAccessPrioNvim (
    MODEM_ID_ENUM_UINT16                enModemId,
    AT_SYSCFG_RAT_PRIO_ENUM_UINT8      *penAcqorder
)
{
    NAS_MMA_NVIM_ACCESS_MODE_STRU        stAccessMode;


    memset_s(&stAccessMode, sizeof(stAccessMode), 0x00, sizeof(NAS_MMA_NVIM_ACCESS_MODE_STRU));

    if (NV_OK != TAF_ACORE_NV_READ(enModemId,
                            en_NV_Item_MMA_AccessMode ,
                            &stAccessMode,
                            sizeof(NAS_MMA_NVIM_ACCESS_MODE_STRU)))
    {
        *penAcqorder = AT_SYSCFG_RAT_PRIO_AUTO;
        return ;
    }

    *penAcqorder = stAccessMode.aucAccessMode[1];
}




VOS_UINT32 AT_IsSupportGMode(
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder
)
{
    VOS_UINT32                          i;

    for (i = 0; i < pstRatOrder->ucRatNum; i++)
    {
        if (pstRatOrder->aenRatOrder[i] == TAF_MMA_RAT_GSM)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_IsSupport1XMode(
    TAF_MMA_MULTIMODE_RAT_CFG_STRU             *pstRatOrder
)
{
    VOS_UINT32                          i;
    for (i = 0; i < pstRatOrder->ucRatNum; i++)
    {
        if (pstRatOrder->aenRatOrder[i] == TAF_MMA_RAT_1X)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}



VOS_UINT32 AT_IsSupportHrpdMode(
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder
)
{
    VOS_UINT32                          i;

    for (i = 0; i < pstRatOrder->ucRatNum; i++)
    {
        if (pstRatOrder->aenRatOrder[i] == TAF_MMA_RAT_HRPD)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}
#endif



LOCAL VOS_UINT32 AT_IsSpecRatSupported(
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enRatMode,
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder
)
{
    VOS_UINT32                          i;

    for (i = 0; i < pstRatOrder->ucRatNum; i++)
    {
        if (enRatMode == pstRatOrder->aenRatOrder[i])
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}



VOS_UINT32 AT_IsSupportWMode(
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder
)
{
    VOS_UINT32                          i;

    for (i = 0; i < pstRatOrder->ucRatNum; i++)
    {
        if (pstRatOrder->aenRatOrder[i] == TAF_MMA_RAT_WCDMA)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_ConvertCpamRatOrderPara(
    VOS_UINT8                           ucClientId,
    MN_MMA_CPAM_RAT_TYPE_ENUM_UINT8     enMode,
    MN_MMA_CPAM_RAT_PRIO_ENUM_UINT8     enAcqorder,
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgSetPara,
    AT_SYSCFG_RAT_PRIO_ENUM_UINT8      *penSyscfgRatPrio
)
{
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder = VOS_NULL_PTR;
    AT_SYSCFG_RAT_PRIO_ENUM_UINT8       enNvimRatPrio;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRst;

    enModemId = MODEM_ID_0;
    pstRatOrder = &(pstSysCfgSetPara->stMultiModeRatCfg);

    ulRst = AT_GetModemIdFromClient(ucClientId, &enModemId);
    if (ulRst != VOS_OK)
    {
        AT_ERR_LOG1("AT_ConvertCpamRatOrderPara:Get ModemID From ClientID fail,ClientID=%d", ucClientId);
        return AT_ERROR;
    }

    /* 如果接入优先级不改变则默认从NVIM中获取 */
    /* 由于NVIM中的接入优先级和CPAM的设置的不一样需要转化一下 */
    if ( enAcqorder == MN_MMA_CPAM_RAT_PRIO_NO_CHANGE )
    {
        AT_GetGuAccessPrioNvim(enModemId, &enNvimRatPrio);
        *penSyscfgRatPrio = enNvimRatPrio;
    }
    else if ( enAcqorder == MN_MMA_CPAM_RAT_PRIO_GSM )
    {
        *penSyscfgRatPrio = AT_SYSCFG_RAT_PRIO_GSM;
    }
    else
    {
        *penSyscfgRatPrio = AT_SYSCFG_RAT_PRIO_WCDMA;
    }



    switch (enMode)
    {
        case MN_MMA_CPAM_RAT_TYPE_WCDMA_GSM:
            if (*penSyscfgRatPrio == AT_SYSCFG_RAT_PRIO_GSM)
            {
                /* GSM优先 */
                pstRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
                pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_GSM;
                pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_WCDMA;
                pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
            }
            else
            {
                /* WCDMA优先 */
                pstRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
                pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_WCDMA;
                pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_GSM;
                pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
            }

            break;

        case MN_MMA_CPAM_RAT_TYPE_GSM:
            /* G单模 */
            pstRatOrder->ucRatNum = 1;
            pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_GSM;
            pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
            break;

        case MN_MMA_CPAM_RAT_TYPE_WCDMA:
            /* W单模 */
            pstRatOrder->ucRatNum = 1;
            pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_WCDMA;
            pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
            break;

        case MN_MMA_CPAM_RAT_TYPE_NOCHANGE:
            pstRatOrder->ucRatNum                  = 0;
            pstSysCfgSetPara->enRatCfgNoChangeType = TAF_MMA_RAT_NO_CHANGE_CMD_CPAM;

            break;

        default:
            return AT_CME_INCORRECT_PARAMETERS;

    }

    return AT_OK;

}
#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetCpamPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_SYS_CFG_PARA_STRU           stSysCfgSetPara;

    VOS_UINT32                          ulRst;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    memset_s(&stSysCfgSetPara, sizeof(stSysCfgSetPara), 0x00, sizeof(TAF_MMA_SYS_CFG_PARA_STRU));

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    ulRst = AT_OK;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gastAtParaList[0].usParaLen == 0 )
    {
        gastAtParaList[0].ulParaValue = MN_MMA_CPAM_RAT_TYPE_NOCHANGE;
    }



    if ( gastAtParaList[1].usParaLen == 0 )
    {
        gastAtParaList[1].ulParaValue = MN_MMA_CPAM_RAT_PRIO_NO_CHANGE;
    }





    ulRst = AT_ConvertCpamRatOrderPara(ucIndex,
                                       (VOS_UINT8)gastAtParaList[0].ulParaValue,
                                       (VOS_UINT8)gastAtParaList[1].ulParaValue,
                                       &stSysCfgSetPara,
                                       &stSysCfgSetPara.enUserPrio);

    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* stSysCfgSetPara其他参数赋值 */
    if (pstNetCtx->ucRoamFeature == AT_ROAM_FEATURE_ON)
    {
        stSysCfgSetPara.enRoam = TAF_MMA_ROAM_UNCHANGE;
    }
    else
    {
        stSysCfgSetPara.enRoam = AT_ROAM_FEATURE_OFF_NOCHANGE;
    }
    stSysCfgSetPara.enSrvDomain         = TAF_MMA_SERVICE_DOMAIN_NOCHANGE;
    stSysCfgSetPara.stGuBand.ulBandLow  = TAF_PH_BAND_NO_CHANGE;
    stSysCfgSetPara.stGuBand.ulBandHigh = 0;
    memset_s(&(stSysCfgSetPara.stLBand),
             sizeof(stSysCfgSetPara.stLBand),
             0x00,
             sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU));
    stSysCfgSetPara.stLBand.aulBandInfo[0] = TAF_PH_BAND_NO_CHANGE;


    /* 执行命令操作 */
    if (TAF_MMA_SetSysCfgReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stSysCfgSetPara) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPAM_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif


TAF_UINT32 At_SetStsfPara(TAF_UINT8 ucIndex)
{
    USIMM_STK_CFG_STRU                  ProfileContent;
    TAF_UINT32                          Result;
    errno_t                             lMemResult;
    TAF_UINT16                          Len = sizeof(USIMM_STK_CFG_STRU);
    MODEM_ID_ENUM_UINT16                usModemId;

    if(gastAtParaList[0].usParaLen != 1)        /* check the para */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gucAtParaIndex > 3)                          /* para too many */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    Result = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_TerminalProfile_Set, &ProfileContent, Len);

    if(Result != NV_OK)
    {
        return AT_ERROR;
    }

    if (AT_GetModemIdFromClient(ucIndex, &usModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    ProfileContent.ucFuncEnable = (TAF_UINT8)gastAtParaList[0].aucPara[0]-0x30;       /* change the string to Ascii value */

    if(gastAtParaList[1].usParaLen != 0x00)         /* have the <config> para */
    {
        if(At_AsciiNum2HexString(gastAtParaList[1].aucPara,&gastAtParaList[1].usParaLen) == AT_FAILURE) /* change the string formate */
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if(gastAtParaList[1].usParaLen > 32)        /* according the etsi102.223,the most len or Terminal Profile is 32 */
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (AT_GetUsimInfoCtxFromModemId(usModemId)->enCardType == TAF_MMA_USIMM_CARD_USIM)
        {
            ProfileContent.stUsimProfile.ucProfileLen = (TAF_UINT8)gastAtParaList[1].usParaLen;

            lMemResult = memcpy_s(ProfileContent.stUsimProfile.aucProfile, (VOS_SIZE_T)sizeof(ProfileContent.stUsimProfile.aucProfile), gastAtParaList[1].aucPara, ProfileContent.stUsimProfile.ucProfileLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_SIZE_T)sizeof(ProfileContent.stUsimProfile.aucProfile), ProfileContent.stUsimProfile.ucProfileLen);
        }
        else
        {
            ProfileContent.stSimProfile.ucProfileLen = (TAF_UINT8)gastAtParaList[1].usParaLen;

            lMemResult = memcpy_s(ProfileContent.stSimProfile.aucProfile, (VOS_SIZE_T)sizeof(ProfileContent.stSimProfile.aucProfile), gastAtParaList[1].aucPara, ProfileContent.stSimProfile.ucProfileLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_SIZE_T)sizeof(ProfileContent.stSimProfile.aucProfile), ProfileContent.stSimProfile.ucProfileLen);
        }
    }

    if(gastAtParaList[2].usParaLen != 0x00)     /* ave the <Timer>  para */
    {
        Result = At_Auc2ul(gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen, &gastAtParaList[2].ulParaValue);
        if (Result != AT_SUCCESS)
        {
            AT_WARN_LOG("At_SetStsfPara():Warning: At_Auc2ul convert failed!");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        if((gastAtParaList[2].ulParaValue> 0xFF)||(gastAtParaList[2].ulParaValue == 0))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ProfileContent.ucTimer = (TAF_UINT8)gastAtParaList[2].ulParaValue;
    }

    Result = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_TerminalProfile_Set, &ProfileContent, Len);

    if(Result != NV_OK)
    {
        return AT_ERROR;
    }

    return AT_OK;
}

/*****************************************************************************
 Prototype      : At_ChangeSATCmdType
 Description    : chang the cmdNo to cmdType
 Input          :
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_ChangeSATCmdType(TAF_UINT32 cmdNo, TAF_UINT32 *CmdType)
{
    TAF_UINT32 Result = AT_SUCCESS;

    switch(cmdNo)
    {
        case SI_AT_CMD_DISPLAY_TEXT:
            *CmdType = SI_STK_DISPLAYTET;
            break;
        case SI_AT_CMD_GET_INKEY:
            *CmdType = SI_STK_GETINKEY;
            break;
        case SI_AT_CMD_GET_INPUT:
            *CmdType = SI_STK_GETINPUT;
            break;
        case SI_AT_CMD_SETUP_CALL:
            *CmdType = SI_STK_SETUPCALL;
            break;
        case SI_AT_CMD_PLAY_TONE:
            *CmdType = SI_STK_PLAYTONE;
            break;
        case SI_AT_CMD_SELECT_ITEM:
            *CmdType = SI_STK_SELECTITEM;
            break;
        case SI_AT_CMD_REFRESH:
            *CmdType = SI_STK_REFRESH;
            break;
        case SI_AT_CMD_SEND_SS:
            *CmdType = SI_STK_SENDSS;
            break;
        case SI_AT_CMD_SEND_SMS:
            *CmdType = SI_STK_SENDSMS;
            break;
        case SI_AT_CMD_SEND_USSD:
            *CmdType = SI_STK_SENDUSSD;
            break;
        case SI_AT_CMD_LAUNCH_BROWSER:
            *CmdType = SI_STK_LAUNCHBROWSER;
            break;
        case SI_AT_CMD_SETUP_IDLE_MODE_TEXT:
            *CmdType = SI_STK_SETUPIDLETEXT;
            break;
        case SI_AT_CMD_LANGUAGENOTIFICATION:
            *CmdType = SI_STK_LANGUAGENOTIFICATION;
            break;
        case SI_AT_CMD_SETFRAMES:
            *CmdType = SI_STK_SETFRAMES;
            break;
        case SI_AT_CMD_GETFRAMESSTATUS:
            *CmdType = SI_STK_GETFRAMESSTATUS;
            break;
        default:
            Result = AT_ERROR;
            break;
    }

    return Result;
}

#if ((FEATURE_PHONE_SC == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))
/*****************************************************************************
 Prototype      : At_SetStgiPara
 Description    : ^STGI
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetStgiPara(TAF_UINT8 ucIndex)
{
    TAF_UINT32 Result;
    TAF_UINT32 CmdType;

    if(g_ulSTKFunctionFlag == TAF_FALSE)
    {
        return AT_ERROR;
    }

    if(gastAtParaList[0].usParaLen == 0)        /* check the para */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gucAtParaIndex != 2)                         /* the para number is must be 2 */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].ulParaValue > 0x0C)        /* the <cmdType> is not more the 12 */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].ulParaValue== 0x00)        /* get the main menu content */
    {
        Result = SI_STK_GetMainMenu(gastAtClientTab[ucIndex].usClientId,0);
    }
    else  if(At_ChangeSATCmdType(gastAtParaList[0].ulParaValue, &CmdType) == AT_ERROR)  /* get other SAT content */
    {
        return AT_ERROR;
    }
    else
    {
        Result = SI_STK_GetSTKCommand(gastAtClientTab[ucIndex].usClientId, 0, CmdType);
    }

    if(Result == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_STGI_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 At_SetClvlPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8           aucIntraVolume[] = {AT_CMD_CLVL_LEV_0,AT_CMD_CLVL_LEV_1,
                                            AT_CMD_CLVL_LEV_2,AT_CMD_CLVL_LEV_3,
                                            AT_CMD_CLVL_LEV_4,AT_CMD_CLVL_LEV_5};


    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者错误 */
    if ((gucAtParaIndex != 1) || (gastAtParaList[0].usParaLen != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 这里做了一个转换，目前后台要求的范围是0~5，而我们对应的范围是0~92，
       根据和媒体的确认，设定范围是0~80，线性对应 */

    /* 返回值为AT_SUCCESS改为VOS_OK，对应起来  */
    if (APP_VC_SetVoiceVolume(gastAtClientTab[ucIndex].usClientId, 0, aucIntraVolume[gastAtParaList[0].ulParaValue]) == VOS_OK)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLVL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetVMSETPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                          ucVoiceMode;


    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if((gucAtParaIndex != 1) || (gastAtParaList[0].usParaLen != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucVoiceMode = (VOS_UINT8)gastAtParaList[0].ulParaValue;

#if (2 <= MULTI_MODEM_NUMBER)
    if (APP_VC_SetVoiceMode(gastAtClientTab[ucIndex].usClientId, 0, ucVoiceMode, I1_WUEPS_PID_VC) != VOS_OK)
    {
        return AT_ERROR;
    }

#if (3 == MULTI_MODEM_NUMBER)
    if (APP_VC_SetVoiceMode(gastAtClientTab[ucIndex].usClientId, 0, ucVoiceMode, I2_WUEPS_PID_VC) != VOS_OK)
    {
        return AT_ERROR;
    }
#endif
#endif

    if (APP_VC_SetVoiceMode(gastAtClientTab[ucIndex].usClientId, 0, ucVoiceMode, I0_WUEPS_PID_VC) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VMSET_SET;

    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)
/*****************************************************************************
 Prototype      : At_SetTestPara
 Description    : +TEST=[<n>]
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetTestPara(TAF_UINT8 ucIndex)
{
    return AT_OK;
}

/* ==> x68770 For WAS AutoTest */

TAF_UINT32 At_SetCwasPara(TAF_UINT8 ucIndex)
{
    AT_MTA_WRR_AUTOTEST_QRY_PARA_STRU   stAtCmd;
    VOS_UINT32                          ulRst;


    /* 参数过多 */
    if ((gucAtParaIndex > 4) || (gucAtParaIndex < 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 初始化 */
    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(AT_MTA_WRR_AUTOTEST_QRY_PARA_STRU));
    stAtCmd.ucCmd = (TAF_UINT8)gastAtParaList[0].ulParaValue;

    for ( stAtCmd.ucParaNum = 0;
          stAtCmd.ucParaNum < (gucAtParaIndex-1);
          stAtCmd.ucParaNum++)
    {
        stAtCmd.aulPara[stAtCmd.ucParaNum]
            = gastAtParaList[stAtCmd.ucParaNum+1].ulParaValue;
    }


    /* 发送消息给C核处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_WRR_AUTOTEST_QRY_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_WRR_AUTOTEST_QRY_PARA_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CWAS_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }


}


TAF_UINT32 At_SetCGasPara(TAF_UINT8 ucIndex)
{
    GAS_AT_CMD_STRU                     stAtCmd;
    VOS_UINT32                          ulRst;

    /* 参数过多 */
    if ((gucAtParaIndex > 11) || (gucAtParaIndex < 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*参数长度等于0*/
    if (gastAtParaList[0].usParaLen == 0)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }



    memset_s(&stAtCmd, sizeof(GAS_AT_CMD_STRU), 0x00, sizeof(GAS_AT_CMD_STRU));

    /* 获取命令参数 */
    stAtCmd.ucCmd = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    for (stAtCmd.ucParaNum = 0; stAtCmd.ucParaNum < (gucAtParaIndex-1); stAtCmd.ucParaNum++)
    {
        stAtCmd.aulPara[stAtCmd.ucParaNum] = gastAtParaList[stAtCmd.ucParaNum+1].ulParaValue;
    }

     /* 发送消息给C核处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_GAS_AUTOTEST_QRY_REQ,
                                   &stAtCmd,
                                   sizeof(GAS_AT_CMD_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGAS_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif

VOS_UINT32 At_SetAppDialModePara(VOS_UINT8 ucIndex)
{
     VOS_UINT32                         ulStatus;
     VOS_UINT8                         *pucSystemAppConfig = VOS_NULL_PTR;

     pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    if (*pucSystemAppConfig != SYSTEM_APP_WEBUI)
    {
        return AT_ERROR;
    }

     /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    else
    {
        if (gastAtParaList[0].ulParaValue == 1)
        {
            /*调用底软接口通知应用进行拨号*/
            ulStatus = AT_USB_ENABLE_EVENT;
        }
        else if(gastAtParaList[0].ulParaValue == 0)
        {
            /*调用底软接口通知应用进行断开拨号*/
            ulStatus = AT_USB_SUSPEND_EVENT;
        }
        else
        {
             return AT_CME_INCORRECT_PARAMETERS;
        }

    }

    DRV_AT_SETAPPDAILMODE(ulStatus);

    return AT_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

TAF_UINT32   At_SetCmmPara(TAF_UINT8 ucIndex)
{
    MM_TEST_AT_CMD_STRU                    stAtCmd;

    /* 参数过多 */
    if( gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(MM_TEST_AT_CMD_STRU));

    stAtCmd.ucCmd = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    for (stAtCmd.ucParaNum = 0; stAtCmd.ucParaNum < (gucAtParaIndex-1); stAtCmd.ucParaNum++)
    {
        stAtCmd.aulPara[stAtCmd.ucParaNum]=gastAtParaList[stAtCmd.ucParaNum+1].ulParaValue;
    }

    if(TAF_MMA_SetCmmReq(WUEPS_PID_AT,
                         gastAtClientTab[ucIndex].usClientId,
                         0,
                         &stAtCmd) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MM_TEST_CMD_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif

VOS_VOID AT_ShowCccRst(
    NAS_CC_STATE_INFO_STRU              *pstCcState,
    VOS_UINT16                          *pusLength
)
{
    VOS_UINT16                          usLength;

    usLength = *pusLength;

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (TAF_CHAR *)pgucAtSndCodeAddr,
                                      (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                      "%d,",
                                      pstCcState->ucCallId);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (TAF_CHAR *)pgucAtSndCodeAddr,
                                      (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                      "%d,",
                                      pstCcState->ucTi);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (TAF_CHAR *)pgucAtSndCodeAddr,
                                      (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                      "%d,",
                                      pstCcState->enCallState);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (TAF_CHAR *)pgucAtSndCodeAddr,
                                      (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                      "%d,",
                                      pstCcState->enHoldAuxState);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (TAF_CHAR *)pgucAtSndCodeAddr,
                                      (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                      "%d",
                                      pstCcState->enMptyAuxState);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s",gaucAtCrLf);

    *pusLength = usLength;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32  AT_SetCccPara( TAF_UINT8 ucIndex )
{
    VOS_UINT8                           ucCallId;
    VOS_UINT32                          ulRst;

    if ((gucAtParaIndex > 2) || (gucAtParaIndex == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gastAtParaList[0].ulParaValue == 0 )
    {
        ucCallId = 0;   /* 0表示查询所有call Id */
    }
    else
    {
        /* gastAtParaList[1].ulParaValue取值无则填取默认值,获取CallId = 1的呼叫状态 */
        if ( gastAtParaList[1].usParaLen == 0 )
        {
            ucCallId = 1;
        }
        else
        {
            ucCallId = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        }

    }

    /* 发送消息AT_CC_MSG_STATE_QRY_REQ给CC获取CC协议状态 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   AT_CC_MSG_STATE_QRY_REQ,
                                   &ucCallId,
                                   sizeof(VOS_UINT8),
                                   I0_WUEPS_PID_CC);

    if (ulRst == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CC_STATE_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif


TAF_UINT32   At_SetSPNPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           ucSpnType;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    /* 参数过多 */
    if( gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值错误 */
    ucSpnType = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    if ( ucSpnType > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 记录AT^SPN查询的SPN类型 */
    pstNetCtx->ucSpnType = ucSpnType;

    /* 给MMA发送消息，查询新参数类型TAF_PH_SPN_VALUE_PARA */
    if(TAF_MMA_QrySpnReq(WUEPS_PID_AT,
                         gastAtClientTab[ucIndex].usClientId,
                         0) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SPN_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32   At_SetCardModePara(TAF_UINT8 ucIndex)
{
    TAF_UINT8               ucCardMode = 0;   /* 0: card not exists, 1: SIM card, 2: USIM card */
    TAF_UINT16              usLength = 0;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulGetModemIdRslt;
    AT_USIM_INFO_CTX_STRU              *pstUsimInfoCtx = VOS_NULL_PTR;

    enModemId = MODEM_ID_0;

    /* 参数过多 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulGetModemIdRslt = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulGetModemIdRslt != VOS_OK)
    {
        AT_ERR_LOG("At_SetCardModePara:Get Modem Id fail!");
        return AT_ERROR;
    }

    pstUsimInfoCtx = AT_GetUsimInfoCtxFromModemId(enModemId);

    if (pstUsimInfoCtx->enCardStatus == USIMM_CARDAPP_SERVIC_BUTT)
    {
        AT_ERR_LOG("At_SetCardModePara:Sim card status butt!");
        return AT_CME_SIM_BUSY;
    }

    /* 获取卡模式 */
    if ( pstUsimInfoCtx->enCardStatus != USIMM_CARDAPP_SERVIC_ABSENT)
    {
        if (pstUsimInfoCtx->enCardType == TAF_MMA_USIMM_CARD_SIM)
        {
            ucCardMode = 1;
        }
        else if (pstUsimInfoCtx->enCardType == TAF_MMA_USIMM_CARD_USIM)
        {
            ucCardMode = 2;
        }
        else
        {
            ucCardMode = 0;
        }
    }
    else
    {
        ucCardMode = 0;
    }

    /* 输出结果: ^CARDMODE:cardmode */
    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (TAF_CHAR *)pgucAtSndCodeAddr,
                                       (TAF_CHAR *)pgucAtSndCodeAddr+usLength,
                                       "%s:",
                                       g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (TAF_CHAR *)pgucAtSndCodeAddr,
                                       (TAF_CHAR*)pgucAtSndCodeAddr+usLength,
                                       "%d",
                                       ucCardMode );

    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}




TAF_UINT32   At_SetDialModePara(TAF_UINT8 ucIndex)
{
    /*根据终端对该命令的要求，设置命令均返回ERROR*/
    return AT_ERROR;
}


TAF_UINT32   At_SetPortSelPara(TAF_UINT8 ucIndex)
{
    TAF_UINT8               ucPortSel;   /* 0: PCUI, 1: Modem */

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不正确 */
    if( gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值错误 */
    ucPortSel = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    if ( ucPortSel > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gucAtPortSel = ucPortSel;

    return AT_OK;
}


TAF_UINT32   At_SetCurcPara(TAF_UINT8 ucIndex)
{
    AT_MTA_CURC_SET_NOTIFY_STRU         stAtCmd;
    VOS_UINT32                          ulResult;
    errno_t                             lMemResult;

#if  (FEATURE_LTE == FEATURE_ON)
    L4A_IND_CFG_STRU                    stL4AIndCfgReq;
    MODEM_ID_ENUM_UINT16                enModemId;

    enModemId  = MODEM_ID_0;

    AT_PR_LOGI("Rcv Msg");
#endif

    /* 参数检查 */
    if ( (gucAtParaIndex > 2)
      || (gucAtParaIndex < 1) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enCurcRptType = (AT_MTA_RPT_GENERAL_CTRL_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    /* mode=0时，禁止所有的主动上报 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        memset_s(gastAtParaList[1].aucPara, sizeof(gastAtParaList[1].aucPara), 0x00, sizeof(gastAtParaList[1].aucPara));
    }
    else if (gastAtParaList[0].ulParaValue == 1)
    {
        /* mode=1时，打开所有的主动上报 */
        memset_s(gastAtParaList[1].aucPara, sizeof(gastAtParaList[1].aucPara), 0xFF, sizeof(gastAtParaList[1].aucPara));
    }

    else if (gastAtParaList[0].ulParaValue == 2)
    {
        /* mode=2时，按BIT位控制对应的主动上报,自定义配置主动上报命令需要<report_cfg>参数 */
        if ( (gucAtParaIndex != 2)
          || (gastAtParaList[1].usParaLen != AT_CURC_RPT_CFG_PARA_LEN) )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulResult = At_AsciiNum2HexString(gastAtParaList[1].aucPara, &gastAtParaList[1].usParaLen);

        AT_PR_LOGI("Call interface success!");
        if (ulResult != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(stAtCmd.aucRptCfg, sizeof(stAtCmd.aucRptCfg), gastAtParaList[1].aucPara, (AT_CURC_RPT_CFG_MAX_SIZE));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAtCmd.aucRptCfg), (AT_CURC_RPT_CFG_MAX_SIZE));

    /* 通知MTA此次curc的设置 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_CURC_SET_NOTIFY,
                                   &stAtCmd,
                                   sizeof(AT_MTA_CURC_SET_NOTIFY_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

#if  (FEATURE_LTE == FEATURE_ON)
    ulResult = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulResult != VOS_OK)
    {
        AT_ERR_LOG1("At_SetCurcPara:Get ModemID From ClientID fail,ClientID=%d", ucIndex);
        return AT_ERROR;
    }

    if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_LTE) == VOS_TRUE)
    {
        /* 平台能力支持LTE */
        memset_s(&stL4AIndCfgReq, sizeof(stL4AIndCfgReq), 0x00, sizeof(stL4AIndCfgReq));
        stL4AIndCfgReq.curc_bit_valid  = 1;
        lMemResult = memcpy_s(stL4AIndCfgReq.aucCurcCfgReq, sizeof(stL4AIndCfgReq.aucCurcCfgReq), gastAtParaList[1].aucPara,
                              sizeof(stL4AIndCfgReq.aucCurcCfgReq));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stL4AIndCfgReq.aucCurcCfgReq), sizeof(stL4AIndCfgReq.aucCurcCfgReq));

        /* 通知L此次curc的设置 */
        return AT_SetLIndCfgReq(ucIndex, &stL4AIndCfgReq);
    }
    else
    {
        return AT_OK;
    }
#else
    return AT_OK;
#endif
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

TAF_UINT32   At_SetBOOTPara(TAF_UINT8 ucIndex)
{

    /* 参数过多 */
    if( gucAtParaIndex > 2)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数过少 */
    if( gucAtParaIndex < 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值检查, para2必须为 0 */
    if ( (gastAtParaList[1].usParaLen != 1) || (gastAtParaList[1].aucPara[0]!= '0') )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 假命令，直接返回OK. */
    return AT_OK;
}
#endif


TAF_UINT32 At_SetCellInfoPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulAtCmdCellInfo;
    VOS_UINT32                          ulRst;

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulAtCmdCellInfo = gastAtParaList[0].ulParaValue;


    /* 发送消息ID_AT_MTA_WRR_CELLINFO_QRY_REQ到C核AT AGENT处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_WRR_CELLINFO_QRY_REQ,
                                   &ulAtCmdCellInfo,
                                   sizeof(VOS_UINT32),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CELLINFO_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }


}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

TAF_UINT32 At_DelWCellEntity(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    /* 参数过多 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_DEL_CELLENTITY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DEL_CELLENTITY_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}



TAF_UINT32  At_GetMeanRpt( TAF_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    /* 参数过多 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息ID_AT_MTA_WRR_MEANRPT_QRY_REQ给AT AGENT处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_WRR_MEANRPT_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MEANRPT_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
/*<--W101153 For Was AutoTest*/


TAF_UINT32 At_SetRRCVersion(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           ucRRCVersion;
    VOS_UINT32                          ulRst;

    /* 参数过多返回参数错误 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucRRCVersion = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送消息DRV_AGENT_RRC_VERSION_SET_REQ给AT代理处理 */

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_WRR_RRC_VERSION_SET_REQ,
                                   &ucRRCVersion,
                                   sizeof(VOS_UINT8),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_RRC_VERSION_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif

TAF_UINT32 At_SetCSNR(TAF_UINT8 ucIndex)
{
    /* 参数过多 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

TAF_UINT32 At_SetFreqLock(TAF_UINT8 ucIndex)
{
    MTA_AT_WRR_FREQLOCK_CTRL_STRU       stFreqLock;
    VOS_UINT32                          ulRst;

    /* 参数个数不正确则返回参数错误 */
    if ( (gucAtParaIndex != 1) && (gucAtParaIndex != 2) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果第一个参数是锁频,但第二个参数频率值没有设置或
       设置的值无效则返回错误*/
    if ( (gastAtParaList[0].ulParaValue == 1)
      && (gastAtParaList[1].usParaLen == 0) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 发送消息赋值 */
    memset_s(&stFreqLock, sizeof(stFreqLock), 0x00, sizeof(MTA_AT_WRR_FREQLOCK_CTRL_STRU));
    stFreqLock.ucFreqLockEnable = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stFreqLock.usLockedFreq     = (VOS_UINT16)gastAtParaList[1].ulParaValue;

    /* 发送消息 ID_AT_MTA_WRR_FREQLOCK_SET_REQ 给C核 AT 代理处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_WRR_FREQLOCK_SET_REQ,
                                   &stFreqLock,
                                   sizeof(MTA_AT_WRR_FREQLOCK_CTRL_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_FREQLOCK_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif
#if (FEATURE_PROBE_FREQLOCK == FEATURE_ON)

VOS_UINT32 AT_CheckM2MFreqLockPara(
    VOS_UINT8                           ucClientId
)
{
    /* <enable>参数为0时，参数个数应该为1 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        if (gucAtParaIndex == 1)
        {
            return AT_SUCCESS;
        }
        else
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* <enable>参数为1时，设置命令参数个数应该为6 */
    if ((gastAtParaList[0].ulParaValue == 1) && (gucAtParaIndex != 6))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 转换<MODE>参数为无符号整型 */
    if(At_Auc2ul(gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen,&gastAtParaList[1].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <mode>参数为字符串类型，取值为"01"--"04"，长度为2位 */
    if ((gastAtParaList[1].usParaLen != 2)
        || ((gastAtParaList[1].ulParaValue < AT_MTA_M2M_FREQLOCK_MODE_GSM) || (gastAtParaList[1].ulParaValue > AT_MTA_M2M_FREQLOCK_MODE_LTE)))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <Band>参数仅在GSM制式下有效 */
    if (gastAtParaList[1].ulParaValue == AT_MTA_M2M_FREQLOCK_MODE_GSM)
    {
        /* <band>参数为字符串类型，取值为"00"--"03"，长度为2位 */
        if (gastAtParaList[3].usParaLen != 2)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* <band>参数为字符串类型，带双引号,字符串长度为4 */
        if(At_Auc2ul(gastAtParaList[3].aucPara,gastAtParaList[3].usParaLen,&gastAtParaList[3].ulParaValue) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }


        if (gastAtParaList[3].ulParaValue > AT_MTA_GSM_BAND_1900)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* GSM有效频点范围: 0-1023 */
        if (gastAtParaList[2].ulParaValue > 1023)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        /* 非GSM制式下，<Band>参数须为空 */
        if (gastAtParaList[3].usParaLen != 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* <PSC>参数仅在WCDMA、TDS-CDMA制式下有效 */
    if ((gastAtParaList[4].usParaLen != 0)
        && ((gastAtParaList[1].ulParaValue != AT_MTA_M2M_FREQLOCK_MODE_WCDMA) && (gastAtParaList[1].ulParaValue != AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA)))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PCI>参数仅在LTE制式下有效 */
    if ((gastAtParaList[5].usParaLen != 0)
        && (gastAtParaList[1].ulParaValue != AT_MTA_M2M_FREQLOCK_MODE_LTE))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_GetM2MFreqLockPara(
    VOS_UINT8                           ucClientId,
    AT_MTA_SET_M2M_FREQLOCK_REQ_STRU   *pstFreqLockInfo
)
{
    if (gastAtParaList[0].ulParaValue == 0)
    {
        /* 锁频功能关闭 */
        pstFreqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_OFF;
        return AT_SUCCESS;
    }
    else
    {
        /* GSM模式时，<band>参数为必选项，第5个参数无意义；WCDMA模式时，<band>参数无意义，根据<psc>是否为空，区分W锁频类型:锁频、锁频+扰码 */
        switch (gastAtParaList[1].ulParaValue)
        {
            case AT_MTA_M2M_FREQLOCK_MODE_GSM:
                if (gastAtParaList[3].usParaLen == 0)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                else
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_GSM;
                    pstFreqLockInfo->stGFreqPara.usFreq         = (VOS_UINT16)gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                    pstFreqLockInfo->stGFreqPara.enBand         = (VOS_UINT16)gastAtParaList[3].ulParaValue;                        /* <band>频段参数 */
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_WCDMA:
                if (gastAtParaList[4].usParaLen == 0)
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_WCDMA;
                    pstFreqLockInfo->stWFreqPara.ucFreqType     = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;              /* FREQ_ONLY类型 */
                    pstFreqLockInfo->stWFreqPara.usFreq         = (VOS_UINT16)gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                }
                else
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_WCDMA;
                    pstFreqLockInfo->stWFreqPara.ucFreqType     = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;          /* FREQ + PSC类型 */
                    pstFreqLockInfo->stWFreqPara.usFreq         = (VOS_UINT16)gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                    pstFreqLockInfo->stWFreqPara.usPsc          = (VOS_UINT16)gastAtParaList[4].ulParaValue;                        /* 主扰码参数 */
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA:
                if (gastAtParaList[4].usParaLen == 0)
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA;
                    pstFreqLockInfo->stTDFreqPara.ucFreqType    = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;              /* FREQ_ONLY类型 */
                    pstFreqLockInfo->stTDFreqPara.usFreq        = (VOS_UINT16)gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                }
                else
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA;
                    pstFreqLockInfo->stTDFreqPara.ucFreqType    = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;          /* FREQ + SC类型 */
                    pstFreqLockInfo->stTDFreqPara.usFreq        = (VOS_UINT16)gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                    pstFreqLockInfo->stTDFreqPara.usSc          = (VOS_UINT16)gastAtParaList[4].ulParaValue;                        /* 主扰码参数 */
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_LTE:
                if (gastAtParaList[5].usParaLen == 0)
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_LTE;
                    pstFreqLockInfo->stLFreqPara.ucFreqType     = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;              /* FREQ_ONLY类型 */
                    pstFreqLockInfo->stLFreqPara.ulFreq         = gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                }
                else
                {
                    pstFreqLockInfo->enableFlag                 = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    pstFreqLockInfo->ucMode                     = AT_MTA_M2M_FREQLOCK_MODE_LTE;
                    pstFreqLockInfo->stLFreqPara.ucFreqType     = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;          /* FREQ + PCI类型 */
                    pstFreqLockInfo->stLFreqPara.ulFreq         = gastAtParaList[2].ulParaValue;                        /* <freq>频点参数 */
                    pstFreqLockInfo->stLFreqPara.usPci          = (VOS_UINT16)gastAtParaList[5].ulParaValue;                        /* 物理小区ID参数 */
                }
                break;

            default:
                return AT_CME_INCORRECT_PARAMETERS;
        }

        return AT_SUCCESS;
    }
}



TAF_UINT32 At_SetM2MFreqLock(TAF_UINT8 ucIndex)
{
    AT_MTA_SET_M2M_FREQLOCK_REQ_STRU    stFreqLockInfo;

    VOS_UINT32                          ulRst;

    /* 初始化 */
    memset_s(&stFreqLockInfo, sizeof(stFreqLockInfo), 0x00, sizeof(AT_MTA_SET_M2M_FREQLOCK_REQ_STRU));

    /* 命令类型检查*/
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数有效性检查 */
    ulRst = AT_CheckM2MFreqLockPara(ucIndex);

    if (ulRst != AT_SUCCESS)
    {
        return ulRst;
    }

    /* 获取用户锁频配置信息 */
    ulRst = AT_GetM2MFreqLockPara(ucIndex,&stFreqLockInfo);

    if (ulRst != AT_SUCCESS)
    {
        return ulRst;
    }

    /* 发送消息 ID_AT_MTA_FREQLOCK_SET_REQ 给C核 AT 代理处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_SET_M2M_FREQLOCK_REQ,
                                   &stFreqLockInfo,
                                   sizeof(AT_MTA_SET_M2M_FREQLOCK_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_M2M_FREQLOCK_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
#endif/*MBB_WPG_FREQLOCK == FEATURE_ON*/



TAF_UINT32 At_SetParaCmd(TAF_UINT8 ucIndex)
{
    AT_RRETURN_CODE_ENUM_UINT32         ulResult = AT_FAILURE;

    /*
    vts这样的命令需要注意，它在参数表中的参数定义为TAF_NULL_PTR，而实际设置参数时，取出设置的参数
    而对于其它无参数命令，需要判断，如果有效参数个数不为0，则返回错误
    */

    if(g_stParseContext[ucIndex].pstCmdElement->pfnSetProc != TAF_NULL_PTR)
    {
        ulResult = (AT_RRETURN_CODE_ENUM_UINT32)g_stParseContext[ucIndex].pstCmdElement->pfnSetProc(ucIndex);

        if(ulResult == AT_WAIT_ASYNC_RETURN)
        {
            g_stParseContext[ucIndex].ucClientStatus = AT_FW_CLIENT_STATUS_PEND;

            /* 开定时器 */
            if(At_StartTimer(g_stParseContext[ucIndex].pstCmdElement->ulSetTimeOut,ucIndex) != AT_SUCCESS)
            {
                AT_ERR_LOG("At_SetParaCmd:ERROR:Start Timer");
                return AT_ERROR;
            }
        }
        return ulResult;
    }
    else
    {
        return AT_ERROR;
    }
}

#if ((FEATURE_PHONE_SC == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))

TAF_UINT32 At_StgrSelMenu(TAF_UINT8 ucIndex)
{
    SI_STK_MENU_SELECTION_STRU *pMenu = VOS_NULL_PTR;
    SI_STK_ENVELOPE_STRU        stENStru;
    VOS_UINT32                  ulRslt;

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stENStru.enEnvelopeType     = SI_STK_ENVELOPE_MENUSEL;
    stENStru.DeviceId.ucSDId    = SI_DEVICE_KEYPAD;
    stENStru.DeviceId.ucDDId    = SI_DEVICE_UICC;

    pMenu = &stENStru.uEnvelope.MenuSelect;
    memset_s(pMenu, sizeof(SI_STK_MENU_SELECTION_STRU), 0x00, sizeof(SI_STK_MENU_SELECTION_STRU));

    if(gastAtParaList[2].ulParaValue == SI_AT_RESULT_HELP_REQUIRED)
    {
        pMenu->OP_Help        = 1;
        pMenu->Help.aucRsv[0] = 1;
    }

    /*select item*/
    if(gastAtParaList[3].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    else
    {
        ulRslt = At_Auc2ul(gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen, &gastAtParaList[3].ulParaValue);
        if (ulRslt != AT_SUCCESS)
        {
            AT_WARN_LOG("At_StgiSelectItem():Warning: At_Auc2ul convert failed!");
            return AT_ERROR;
        }

        pMenu->OP_ItemIp       = 1;
        pMenu->ItemId.ucItemId = (TAF_UINT8)gastAtParaList[3].ulParaValue;
    }

    /* 执行命令操作 */
    if(SI_STK_MenuSelection(gastAtClientTab[ucIndex].usClientId, 0,&stENStru) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_STGR_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;    /* 返回命令处理挂起状态 */
    }
}
#endif

/*****************************************************************************
 Prototype      : At_ChangeCmdResult
 Description    :
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_ChangeCmdResult(TAF_UINT32 resultNo,TAF_UINT8 *cmdResult)
{
    TAF_UINT32 ulResult;

    ulResult = AT_SUCCESS;

    switch(resultNo)
    {
        case SI_AT_RESULT_END_SESSION:
            *cmdResult = PROACTIVE_UICC_SESSION_TERMINATED_BY_THE_USER;
            break;
        case SI_AT_RESULT_PERFORM_SUCC:
            *cmdResult = COMMAND_PERFORMED_SUCCESSFULLY;
            break;
        case SI_AT_RESULT_HELP_REQUIRED:
            *cmdResult = HELP_INFORMATION_REQUIRED_BY_USER;
            break;
        case SI_AT_RESULT_BACKWARD_MOVE:
            *cmdResult = BACKWARD_MOVE_IN_THE_PROACTIVE_UICC_SESSION_REQUESTED_BY_USER;
            break;
        case SI_AT_RESULT_ME_NOT_SUPPORT:
            *cmdResult = COMMAND_BEYOND_TERMINALS_CAPABILITIES;
            break;
        case SI_AT_RESULT_ME_BROWSER_BUSY:
            *cmdResult = TERMINAL_CURRENTLY_UNABLE_TO_PROCESS_COMMAND;
            break;
        case SI_AT_RESULT_ME_SS_BUSY:
            *cmdResult = TERMINAL_CURRENTLY_UNABLE_TO_PROCESS_COMMAND;
            break;
        default:
            ulResult= AT_ERROR;
    }

    return ulResult;
}

/*****************************************************************************
 Prototype      : At_StgiGetKey
 Description    :
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_StgiGetKey(TAF_UINT8 ucIndex, SI_STK_TERMINAL_RSP_STRU *pRsp)
{
    TAF_UINT8                           cmdResult;
    TAF_UINT8                           InputKey[AT_PARA_MAX_LEN + 1];
    errno_t                             lMemResult;

    if(At_ChangeCmdResult(gastAtParaList[2].ulParaValue, &cmdResult) == AT_ERROR)
    {
        return AT_ERROR;
    }

    pRsp->Result.Result = cmdResult;

    if(cmdResult == COMMAND_PERFORMED_SUCCESSFULLY)
    {
        if ( (gucAtParaIndex != 4) || (((VOS_SIZE_T)sizeof(InputKey) <= gastAtParaList[3].usParaLen)
          || (gastAtParaList[3].usParaLen < 2)) )
        {
            AT_WARN_LOG("At_StgiGetKey: 4th para error!");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 专有参数 */
        pRsp->uResp.GetInkeyRsp.TextStr.pucText = pRsp->aucData;

        memset_s(InputKey, (VOS_SIZE_T)sizeof(InputKey), 0x00, AT_PARA_MAX_LEN + 1);
        lMemResult = memcpy_s(InputKey, (VOS_SIZE_T)sizeof(InputKey), gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_SIZE_T)sizeof(InputKey), gastAtParaList[3].usParaLen);

        /*由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，
        解析时需要将引号去除，长度减2*/
        if(At_AsciiString2HexText(&pRsp->uResp.GetInkeyRsp.TextStr,\
                                      InputKey+1, gastAtParaList[3].usParaLen-2) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pRsp->uResp.GetInkeyRsp.OP_TextStr = 1;

        if((gucSTKCmdQualify&0x02)== 0x00)
        {
            pRsp->uResp.GetInkeyRsp.TextStr.ucDCS = 0x04;
        }
        else
        {
            pRsp->uResp.GetInkeyRsp.TextStr.ucDCS = 0x08;
        }

        if((gucSTKCmdQualify&0x04)== 0x04)
        {
            *pRsp->uResp.GetInkeyRsp.TextStr.pucText -=0x30;
        }
    }

    return AT_SUCCESS;
}
/*****************************************************************************
 Prototype      : At_StgiGetInput
 Description    :
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_StgiGetInput(TAF_UINT8 ucIndex,SI_STK_TERMINAL_RSP_STRU *pRsp)
{
    errno_t                             lMemResult;
    TAF_UINT8                           cmdResult;
    TAF_UINT8                           InputString[AT_PARA_MAX_LEN + 1];
    VOS_UINT32                          ulLength;

    ulLength = (VOS_SIZE_T)sizeof(InputString);

    if(At_ChangeCmdResult(gastAtParaList[2].ulParaValue, &cmdResult) == AT_ERROR)
    {
        return AT_ERROR;
    }

    pRsp->Result.Result = cmdResult;

    if(cmdResult == COMMAND_PERFORMED_SUCCESSFULLY)
    {
        /* 专有参数 */
        if(gastAtParaList[3].usParaLen < 0x03)
        {
            pRsp->uResp.GetInkeyRsp.TextStr.pucText = TAF_NULL_PTR;

            pRsp->uResp.GetInkeyRsp.TextStr.ucLen = 0;
        }
        else if (ulLength > gastAtParaList[3].usParaLen)
        {
            pRsp->uResp.GetInkeyRsp.TextStr.pucText = pRsp->aucData;

            lMemResult = memset_s(InputString, sizeof(InputString), 0x00, AT_PARA_MAX_LEN + 1);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(InputString), AT_PARA_MAX_LEN + 1);
            lMemResult = memcpy_s(InputString, sizeof(InputString), gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(InputString), gastAtParaList[3].usParaLen);

            /*由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，解析时需要将引号去除，长度减2*/
            if(At_AsciiString2HexText(&pRsp->uResp.GetInputRsp.TextStr,\
                                          InputString+1, gastAtParaList[3].usParaLen-2) == AT_FAILURE)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
        else
        {
            AT_WARN_LOG1("At_StgiGetInput: 4th para error!", gastAtParaList[3].usParaLen);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pRsp->uResp.GetInputRsp.OP_TextStr = 1;

        if((gucSTKCmdQualify&0x02)== 0x00)
        {
            if((gucSTKCmdQualify&0x08)== 0x00)
            {
                pRsp->uResp.GetInkeyRsp.TextStr.ucDCS = 0x04;
            }
            else
            {
                pRsp->uResp.GetInkeyRsp.TextStr.ucDCS = 0x00;
            }
        }
        else
        {
            pRsp->uResp.GetInkeyRsp.TextStr.ucDCS = 0x08;
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_StgiSelectItem(TAF_UINT8 ucIndex,SI_STK_TERMINAL_RSP_STRU *pRsp)
{
    TAF_UINT8       cmdResult;
    VOS_UINT32      ulRslt;

    if(At_ChangeCmdResult(gastAtParaList[2].ulParaValue, &cmdResult) == AT_ERROR)
    {
        return AT_ERROR;
    }

    pRsp->Result.Result = cmdResult;

    if(cmdResult == COMMAND_PERFORMED_SUCCESSFULLY)
    {
        ulRslt = At_Auc2ul(gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen, &gastAtParaList[3].ulParaValue);
        if (ulRslt != AT_SUCCESS)
        {
            AT_WARN_LOG("At_StgiSelectItem():Warning: At_Auc2ul convert failed!");
            return AT_ERROR;
        }

        /* 专有参数 */
        pRsp->uResp.SelectItemRsp.ItemId.ucItemId = (TAF_UINT8)gastAtParaList[3].ulParaValue;
        pRsp->uResp.SelectItemRsp.OP_ItemID       = 1;
    }

    return AT_SUCCESS;
}

#if ((FEATURE_PHONE_SC == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))
/*****************************************************************************
 Prototype      : At_SetStgrPara
 Description    : ^STGR=<cmdnum>,<cmdtype>,<result>,<data>
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetStgrPara(TAF_UINT8 ucIndex)
{
    SI_STK_TERMINAL_RSP_STRU Rsponse;
    TAF_UINT32 Result = 0;

#if ( VOS_WIN32 != VOS_OS_VER )
    if(g_ulSTKFunctionFlag == TAF_FALSE)
    {
        return AT_ERROR;
    }
#endif

    if((gucAtParaIndex > 4)||(gucAtParaIndex < 3))          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[0].usParaLen == 0)||(gastAtParaList[1].usParaLen == 0))  /* the para1 and para2 is must be inputed */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    Rsponse.DeviceId.ucSDId = SI_DEVICE_KEYPAD;
    Rsponse.DeviceId.ucDDId = SI_DEVICE_UICC;

    if(gastAtParaList[0].ulParaValue == 0x00)
    {
        if((gastAtParaList[2].ulParaValue== 1)||(gastAtParaList[2].ulParaValue == 2))   /* menu selection or need the help infomation */
        {
            return At_StgrSelMenu(ucIndex);
        }
        else
        {
            return AT_OK;
        }
    }

    memset_s(&Rsponse, sizeof(Rsponse), 0x00, sizeof(SI_STK_TERMINAL_RSP_STRU));

    if(gastAtParaList[0].ulParaValue == SI_AT_CMD_END_SESSION)
    {
        Rsponse.Result.Result = PROACTIVE_UICC_SESSION_TERMINATED_BY_THE_USER;
    }
    else if(At_ChangeSATCmdType(gastAtParaList[0].ulParaValue, &Rsponse.CmdType) != AT_SUCCESS)
    {
        return AT_ERROR;
    }
    else
    {

    }

    switch(gastAtParaList[0].ulParaValue)
    {
        case SI_AT_CMD_GET_INKEY:
            Result = At_StgiGetKey(ucIndex, &Rsponse);       /* change the GetInkey response content */
            break;
        case SI_AT_CMD_GET_INPUT:
            Result = At_StgiGetInput(ucIndex, &Rsponse);     /* change the GetInput response content */
            break;
        case SI_AT_CMD_SELECT_ITEM:
            Result = At_StgiSelectItem(ucIndex, &Rsponse);   /* change the SelectItem response content */
            break;
        default:
            Result = At_ChangeCmdResult(gastAtParaList[2].ulParaValue, &Rsponse.Result.Result);
            break;
    }

    if(Result != AT_SUCCESS)
    {
        return Result;    /* return the error */
    }

    if(SI_STK_TerminalResponse(gastAtClientTab[ucIndex].usClientId, 0,&Rsponse) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_STGR_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
#endif

/*****************************************************************************
 Prototype      : At_SetCstrPara
 Description    : ^STGR=<Len>,<data>
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCstrPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           aucData[256];
    VOS_UINT8                           ucDataLen;
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();



    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID)
    {
        return AT_ERROR;
    }
    if (gucAtParaIndex != 2)          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)||(gastAtParaList[1].usParaLen == 0))  /* the para1 and para2 is must be inputed */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the value of para1 and the len of para2 must be equal */
    if (gastAtParaList[0].ulParaValue != gastAtParaList[1].usParaLen)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiString2HexSimple(aucData, gastAtParaList[1].aucPara, (VOS_UINT16)gastAtParaList[0].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucDataLen = (TAF_UINT8)(gastAtParaList[0].ulParaValue/2);

    if (SI_STK_DataSendSimple(gastAtClientTab[ucIndex].usClientId, 0, SI_STK_TRSEND, ucDataLen, aucData) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSTR_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


/*****************************************************************************
 Prototype      : At_SetCsinPara
 Description    : ^CSIN命令处理函数
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2012-05-17
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCsinPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 非ANDROID系统不支持 */
    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID)
    {
        return AT_ERROR;
    }

    /* 获取最后一次收到的主动命令，不将命令类型传入 */
    if (SI_STK_GetSTKCommand(gastAtClientTab[ucIndex].usClientId, 0, 0) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

/*****************************************************************************
 Prototype      : At_SetCstrPara
 Description    : ^STGR=<Len>,<data>
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCsenPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                           aucData[256];
    VOS_UINT8                           ucDataLen;
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();



    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID)
    {
        return AT_ERROR;
    }

    if (gucAtParaIndex != 2)          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)||(gastAtParaList[1].usParaLen == 0))  /* the para1 and para2 is must be inputed */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the value of para1 and the len of para2 must be equal */
    if (gastAtParaList[0].ulParaValue != gastAtParaList[1].usParaLen)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiString2HexSimple(aucData, gastAtParaList[1].aucPara, (VOS_UINT16)gastAtParaList[0].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucDataLen = (TAF_UINT8)(gastAtParaList[0].ulParaValue/2);

    if (SI_STK_DataSendSimple(gastAtClientTab[ucIndex].usClientId, 0, SI_STK_ENVELOPESEND, ucDataLen, aucData) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

/*****************************************************************************
 Prototype      : At_SetCsmnPara
 Description    : ^CSMN
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCsmnPara(TAF_UINT8 ucIndex)
{
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    pucSystemAppConfig                  = AT_GetSystemAppConfigAddr();



    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID)
    {
        return AT_ERROR;
    }

    if (gucAtParaIndex != 0)          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STK_GetMainMenu(gastAtClientTab[ucIndex].usClientId, 0) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCstcPara(TAF_UINT8 ucIndex)
{
    if (gucAtParaIndex != 1)          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STK_SetUpCallConfirm(gastAtClientTab[ucIndex].usClientId, gastAtParaList[0].ulParaValue) == AT_SUCCESS)
    {
        return AT_OK;
    }

    return AT_ERROR;
}


/*****************************************************************************
 Prototype      : At_SetImsichgPara
 Description    : ^STGR=<cmdnum>,<cmdtype>,<result>,<data>
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2010-02-11
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetImsichgPara(TAF_UINT8 ucIndex)
{
    if (SI_STKIsDualImsiSupport() == VOS_FALSE)
    {
        return AT_CMD_NOT_SUPPORT;
    }

    if (gucAtParaIndex != 1)          /* the para munber is too many or too few */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].usParaLen == 0)  /* the para1 must be inputed */
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STKDualIMSIChangeReq(gastAtClientTab[ucIndex].usClientId, 0) == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IMSICHG_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32  AT_PhyNumIsNull(
    MODEM_ID_ENUM_UINT16                enModemId,
    AT_PHYNUM_TYPE_ENUM_UINT32          enSetType,
    VOS_BOOL                           *pbPhyNumIsNull
)
{
    VOS_UINT32                          ulRet;
    VOS_UINT32                          ulLoop;
    VOS_UINT32                          ulTotalNum;
    IMEI_STRU                           stImei;
    TAF_SVN_DATA_STRU                   stSvnData;
    VOS_UINT8                          *pucCheckNum = VOS_NULL_PTR;
    VOS_UINT8                           aucMac[AT_PHYNUM_MAC_LEN + 1]; /* MAC地址*/


    memset_s(&stSvnData, sizeof(stSvnData), 0x00, sizeof(stSvnData));


    /* 从获取NV中IMEI或SVN物理号，获取操作失败，则返回AT_ERROR */
    if (enSetType == AT_PHYNUM_TYPE_IMEI)
    {
        ulRet = TAF_ACORE_NV_READ(enModemId, en_NV_Item_IMEI, &stImei, NV_ITEM_IMEI_SIZE);
        if (ulRet != NV_OK)
        {
            AT_WARN_LOG("AT_PhyNumIsNull: Fail to read en_NV_Item_IMEI");
            return AT_ERROR;
        }

        /*NV项en_NV_Item_IMEI中仅15位是UE的IMEI号，最后一位是无效位不作比较*/
        ulTotalNum  = TAF_IMEI_DATA_LENGTH;
        pucCheckNum = stImei.aucImei;
    }
    else if (enSetType == AT_PHYNUM_TYPE_SVN)
    {
        ulRet = TAF_ACORE_NV_READ(enModemId, en_NV_Item_Imei_Svn, &stSvnData, sizeof(stSvnData));
        if (ulRet != NV_OK)
        {
            AT_WARN_LOG("AT_PhyNumIsNull: Fail to read en_Nv_Item_Imei_Svn");
            return AT_ERROR;
        }

        /* SVN未激活按物理号为空处理 */
        if (stSvnData.ucActiveFlag != NV_ITEM_ACTIVE)
        {
            *pbPhyNumIsNull = VOS_TRUE;
            return AT_OK;
        }

        ulTotalNum  = TAF_SVN_DATA_LENGTH;
        pucCheckNum = stSvnData.aucSvn;
    }
    else if (enSetType == AT_PHYNUM_TYPE_MAC)
    {
        /* 输出当前MAC地址是否为空状态 */
        AT_GetPhynumMac(aucMac);
        ulTotalNum  = AT_PHYNUM_MAC_LEN;
        pucCheckNum = aucMac;
    }
    else
    {
        AT_WARN_LOG("AT_PhyNumIsNull: the type of physical is error.");
        return AT_ERROR;
    }

    /* NV中IMEI或SVN物理号为全0认为物理号为空；否则，非空 */
    for (ulLoop = 0; ulLoop < ulTotalNum; ulLoop++)
    {
        if (*pucCheckNum != 0)
        {
            *pbPhyNumIsNull = VOS_FALSE;
            return AT_OK;
        }

        pucCheckNum++;
    }

    *pbPhyNumIsNull = VOS_TRUE;

    return AT_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_UpdateImei(
    MODEM_ID_ENUM_UINT16                enModemId,
    VOS_UINT8                           aucImei[],
    VOS_UINT16                          usImeiLength
)
{
    VOS_UINT8                           aucBcdNum[TAF_PH_IMEI_LEN];
    VOS_UINT8                           ucCheckData;
    VOS_UINT32                          i;

    /* IMEI 长度检查: 用户输入的IMEI长度应为14位的IMEI和1位的CHECK NUM，共15位 */
    if (usImeiLength != (TAF_PH_IMEI_LEN - 1))
    {
        AT_NORM_LOG1("AT_UpdateImei: the length of imei is error ", (VOS_INT32)usImeiLength);
        return AT_PHYNUM_LENGTH_ERR;
    }

    /* IMEI 号码检查: 确认<imei>为数字字符串, 并将ASCII码转换成BCD码 */
    if (At_AsciiNum2Num(aucBcdNum, aucImei, usImeiLength) != AT_SUCCESS)
    {
        AT_NORM_LOG("AT_UpdateImei: the number of imei is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }
    aucBcdNum[TAF_PH_IMEI_LEN - 1] = 0;

    /* IMEI 校验检查: IMEI信息由IMEI(TAC8位,SNR6位)和校验位两部分组成
       参考协议: 3GPP 23003 B.2 Computation of CD for an IMEI和B.3 Example of computation */
    ucCheckData = 0;
    for (i = 0; i < (TAF_IMEI_DATA_LENGTH - 1); i += 2)
    {
        ucCheckData += aucBcdNum[i]
                       + ((aucBcdNum[i + 1UL] + aucBcdNum[i + 1UL]) / 10)
                       + ((aucBcdNum[i + 1UL] + aucBcdNum[i + 1UL]) % 10);
    }
    ucCheckData = (10 - (ucCheckData % 10)) % 10;

    if (ucCheckData != aucBcdNum[TAF_PH_IMEI_LEN - 2])
    {
        AT_NORM_LOG("AT_UpdateImei: the checkdata of imei is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    if (TAF_ACORE_NV_WRITE(enModemId, en_NV_Item_IMEI, aucBcdNum, TAF_PH_IMEI_LEN) != NV_OK)
    {
         AT_WARN_LOG("AT_UpdateImei: Fail to write NV.");
         return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetImeiPara(TAF_UINT8 ucIndex)
{
    VOS_BOOL                            bPhyNumIsNull;
    VOS_UINT32                          ulRet;
    MODEM_ID_ENUM_UINT16                enModemId;

    enModemId = MODEM_ID_0;

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        AT_NORM_LOG1("At_SetImeiPara: the number of parameter is error ",
                     (VOS_INT32)gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("At_SetImeiPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 物理号不为空，数据保护未解锁，直接返回错误，错误码为1物理号不合法。 */
    if (AT_PhyNumIsNull(enModemId, AT_PHYNUM_TYPE_IMEI, &bPhyNumIsNull) != AT_OK)
    {
        return AT_ERROR;
    }

    if ((bPhyNumIsNull == VOS_FALSE) && (g_bAtDataLocked == VOS_TRUE))
    {
        AT_NORM_LOG("At_SetImeiPara: physical number is not null and data locked.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* 更新数据到NV项en_NV_Item_IMEI并返回更新结果 */
    ulRet = AT_UpdateImei(enModemId, gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);

    return ulRet;
}
#endif

TAF_UINT32 At_SetFPlmnPara(TAF_UINT8 ucIndex)
{
    TAF_PH_FPLMN_OPERATE_STRU stFplmnOperate;


    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if( gucAtParaIndex > 2 )

    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gucAtParaIndex == 1 )
    {
        if ( gastAtParaList[0].ulParaValue != 0 )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        else
        {
            stFplmnOperate.stPlmn.Mcc = 0;
            stFplmnOperate.stPlmn.Mnc = 0;
            stFplmnOperate.ulCmdType = TAF_PH_FPLMN_DEL_ALL;
        }
    }
    else if ( gucAtParaIndex == 2 )
    {
        if ((gastAtParaList[1].usParaLen > 6)
         || (gastAtParaList[1].usParaLen < 5))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mcc */
        if(At_String2Hex(gastAtParaList[1].aucPara,3,&stFplmnOperate.stPlmn.Mcc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mnc */
        if(At_String2Hex(&gastAtParaList[1].aucPara[3],
                         gastAtParaList[1].usParaLen-3,
                         &stFplmnOperate.stPlmn.Mnc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        stFplmnOperate.stPlmn.Mcc &= 0x0FFF;

        if (gastAtParaList[1].usParaLen == 5)
        {
            stFplmnOperate.stPlmn.Mnc |= 0x0F00;
        }

        stFplmnOperate.stPlmn.Mnc &= 0x0FFF;

        if ( gastAtParaList[0].ulParaValue == 0)
        {
            stFplmnOperate.ulCmdType = TAF_PH_FPLMN_DEL_ONE;
        }
        else if ( gastAtParaList[0].ulParaValue == 1)
        {
            stFplmnOperate.ulCmdType = TAF_PH_FPLMN_ADD_ONE;
        }
        else
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetFPlmnInfo(WUEPS_PID_AT,
                             gastAtClientTab[ucIndex].usClientId,
                             0,
                             &stFplmnOperate) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CFPLMN_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}

TAF_UINT32 At_SetQuickStart(TAF_UINT8 ucIndex)
{

    AT_PR_LOGI("Rcv Msg");
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_ERROR;
    }

    if (gastAtParaList[0].ulParaValue > 1)
    {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetQuickStartReq(WUEPS_PID_AT,
                                 gastAtClientTab[ucIndex].usClientId,
                                 0,
                                 gastAtParaList[0].ulParaValue) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CQST_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}

TAF_UINT32 At_SetAutoAttach(TAF_UINT8 ucIndex)
{
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {                                                                           /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_SetAutoAttachReq(WUEPS_PID_AT,
                                 gastAtClientTab[ucIndex].usClientId,
                                 0,
                                 gastAtParaList[0].ulParaValue) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CAATT_SET;
        return AT_WAIT_ASYNC_RETURN;                                            /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetSystemInfo(TAF_UINT8 ucIndex)
{
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(TAF_MMA_QrySystemInfoReq(WUEPS_PID_AT,
                                gastAtClientTab[ucIndex].usClientId,
                                0,
                                VOS_FALSE) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SYSINFO_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
#endif



TAF_UINT32 At_GetBandPara(TAF_UINT8 *nptr,TAF_UINT16 usLen,TAF_USER_SET_PREF_BAND64 * pStBand)
{
    const TAF_UINT8 ucHexLenOfUlongType = 8;
    TAF_UINT32  ulAtRslt1 = AT_SUCCESS;
    TAF_UINT32  ulAtRslt2 = AT_SUCCESS;

    pStBand->ulBandHigh = 0;
    pStBand->ulBandLow = 0;

    /* 频段项的设置  */
    if (usLen <= ucHexLenOfUlongType)
    {
         ulAtRslt1 = At_String2Hex(nptr,usLen,&(pStBand->ulBandLow));
    }
    else
    {
        ulAtRslt1 = At_String2Hex(nptr,usLen-ucHexLenOfUlongType,&(pStBand->ulBandHigh));
        ulAtRslt2 = At_String2Hex(nptr+(usLen-ucHexLenOfUlongType),ucHexLenOfUlongType,&(pStBand->ulBandLow));
    }

    if ( ( ulAtRslt1 == AT_FAILURE ) || (  ulAtRslt2 == AT_FAILURE))
    {
        return  AT_FAILURE;
    }

    return AT_SUCCESS;

}



VOS_VOID At_ConvertSysCfgExRat(
    VOS_UINT8                           ucClientId,
    AT_SYSCFGEX_RAT_ORDER_STRU         *pstSysCfgExRatOrder,
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
)
{
    VOS_UINT32                          i;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRst;
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder = VOS_NULL_PTR;

    enModemId = MODEM_ID_0;
    pstRatOrder = &(pstSysCfgExSetPara->stMultiModeRatCfg);

    /* 获取ModemID*/
    ulRst = AT_GetModemIdFromClient(ucClientId, &enModemId);
    if (ulRst != VOS_OK)
    {
        AT_ERR_LOG1("At_ConvertSysCfgExRat:Get ModemID From ClientID fail,ClientID=%d", ucClientId);
        return;
    }

    /* 组合原因值00的接入技术转换 */
    if ( (pstSysCfgExRatOrder->ucRatOrderNum == 1)
      && (pstSysCfgExRatOrder->aenRatOrder[0] == AT_SYSCFGEX_RAT_AUTO))
    {
        AT_SetDefaultRatPrioList(enModemId, pstRatOrder, VOS_TRUE, VOS_TRUE);
        return ;
    }

    /* 组合原因值99的接入技术转换 */
    if ( (pstSysCfgExRatOrder->ucRatOrderNum == 1)
      && (pstSysCfgExRatOrder->aenRatOrder[0] == AT_SYSCFGEX_RAT_NO_CHANGE) )
    {
        pstRatOrder->ucRatNum             = 0;
        pstSysCfgExSetPara->enRatCfgNoChangeType = TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFGEX;
        return ;
    }

    /* 非组合原因值的接入技术转换 */
    pstRatOrder->ucRatNum = pstSysCfgExRatOrder->ucRatOrderNum;

    for (i = 0; i < pstSysCfgExRatOrder->ucRatOrderNum; i++)
    {
        switch ( pstSysCfgExRatOrder->aenRatOrder[i] )
        {
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
            case AT_SYSCFGEX_RAT_NR:
                pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_NR;
                break;
#endif

#if (FEATURE_LTE == FEATURE_ON)
            case AT_SYSCFGEX_RAT_LTE:
                pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_LTE;
                break;
#endif

            case AT_SYSCFGEX_RAT_WCDMA:
                pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_WCDMA;
                break;

            case AT_SYSCFGEX_RAT_GSM:
                pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_GSM;
                break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
            case AT_SYSCFGEX_RAT_1X:
               pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_1X;
               break;

           case AT_SYSCFGEX_RAT_DO:
               pstRatOrder->aenRatOrder[i] = TAF_MMA_RAT_HRPD;
               break;
#endif

            default:
                AT_ERR_LOG("At_ConvertSysCfgExRat");
                break;
        }

    }
}


TAF_MMA_SERVICE_DOMAIN_ENUM_UINT8 At_ConvertDetachTypeToServiceDomain(
    VOS_UINT32                          ulCgcattMode
)
{
    switch ( ulCgcattMode )
    {
        case AT_CGCATT_MODE_PS :
            return TAF_MMA_SERVICE_DOMAIN_PS;

        case AT_CGCATT_MODE_CS :
            return TAF_MMA_SERVICE_DOMAIN_CS;

        case AT_CGCATT_MODE_CS_PS :
            return TAF_MMA_SERVICE_DOMAIN_CS_PS;

        default:
            AT_ERR_LOG("At_ConvertDetachTypeToServiceDomain Detach Type ERROR");
            return TAF_MMA_SERVICE_DOMAIN_CS_PS;
    }
}




TAF_MMA_ATTACH_TYPE_ENUM_UINT8 At_ConvertCgcattModeToAttachType(
    VOS_UINT32                          ulCgcattMode
)
{
    switch ( ulCgcattMode )
    {
        case AT_CGCATT_MODE_PS :
            return TAF_MMA_ATTACH_TYPE_GPRS;

        case AT_CGCATT_MODE_CS :
            return TAF_MMA_ATTACH_TYPE_IMSI;

        case AT_CGCATT_MODE_CS_PS :
            return TAF_MMA_ATTACH_TYPE_GPRS_IMSI;

        default:
            AT_ERR_LOG("At_ConvertCgcattModeToAttachType Attach Oper ERROR");
            return TAF_MMA_ATTACH_TYPE_GPRS_IMSI;
    }
}




VOS_VOID AT_ReadRoamCfgInfoNvim(
    VOS_UINT8                           ucIndex
)
{
    NAS_NVIM_ROAM_CFG_INFO_STRU          stRoamFeature;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRst;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    enModemId = MODEM_ID_0;

    /* 获取ModemId */
    ulRst = AT_GetModemIdFromClient(ucIndex, &enModemId);
    if (ulRst != VOS_OK)
    {
        AT_ERR_LOG1("AT_ReadRoamCfgInfoNvim:Get ModemID From ClientID fail,ucIndex=%d", ucIndex);
        return;
    }


    stRoamFeature.ucRoamFeatureFlg = NV_ITEM_ACTIVE;
    stRoamFeature.ucRoamCapability = 0;

    if (NV_OK != TAF_ACORE_NV_READ(enModemId, en_NV_Item_Roam_Capa,
                         &stRoamFeature, sizeof(NAS_NVIM_ROAM_CFG_INFO_STRU)))
    {
        AT_WARN_LOG("AT_ReadRoamCfgInfoNvim():WARNING: en_NV_Item_Roam_Capa Error");

        return;
    }

    if ((stRoamFeature.ucRoamFeatureFlg != NV_ITEM_ACTIVE)
     && (stRoamFeature.ucRoamFeatureFlg != NV_ITEM_DEACTIVE))
    {
        return;
    }

    pstNetCtx                = AT_GetModemNetCtxAddrFromModemId(enModemId);
    pstNetCtx->ucRoamFeature = stRoamFeature.ucRoamFeatureFlg;
    return;
}


VOS_UINT32 AT_ConvertSysCfgExRatOrderPara(
    VOS_UINT8                           ucClientId,
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
)
{
    VOS_UINT32                          ulRst;
    VOS_UINT32                          i;
    VOS_UINT32                          ulRatOrder;
    VOS_UINT8                           ucIndex;
    VOS_UINT32                          ulRatAutoNoChangeExistFlag;
    AT_SYSCFGEX_RAT_ORDER_STRU          stSyscfgExRatOrder;

    ucIndex                    = 0;
    ulRatAutoNoChangeExistFlag = VOS_FALSE;

    /* acqorder字符串长度为奇数 */
    if ((gastAtParaList[0].usParaLen % 2) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* acqorder字符串含非数字 */
    ulRst = At_CheckNumString(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    if (ulRst != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* acqorder字符串长度是偶数但大于12也非法 */
    if ((gastAtParaList[0].usParaLen / 2) > TAF_PH_MAX_SUPPORT_RAT_NUM)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < gastAtParaList[0].usParaLen; i += AT_SYSCFGEX_RAT_MODE_STR_LEN)
    {
        ulRst = At_String2Hex(&gastAtParaList[0].aucPara[i], AT_SYSCFGEX_RAT_MODE_STR_LEN, (VOS_UINT32 *)&ulRatOrder);
        if (ulRst != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果ulRatOrder是0x99十六进制数，需要转换为十进制的99 */
        if (ulRatOrder == AT_SYSCFGEX_RAT_NO_CHANGE_HEX_VALUE)
        {
            ulRatOrder = AT_SYSCFGEX_RAT_NO_CHANGE;
        }

        /* acqorder字符串含非00/01/02/03/04/07/08/99的组合 */
        if ( At_CheckSysCfgExRatTypeValid((AT_SYSCFGEX_RAT_TYPE_ENUM_UINT8)ulRatOrder) == VOS_FALSE )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (((AT_SYSCFGEX_RAT_TYPE_ENUM_UINT8)ulRatOrder == AT_SYSCFGEX_RAT_AUTO)
         || ((AT_SYSCFGEX_RAT_TYPE_ENUM_UINT8)ulRatOrder == AT_SYSCFGEX_RAT_NO_CHANGE))
        {
            ulRatAutoNoChangeExistFlag = VOS_TRUE;
        }

        stSyscfgExRatOrder.aenRatOrder[ucIndex++] = (AT_SYSCFGEX_RAT_TYPE_ENUM_UINT8)ulRatOrder;

    }

    stSyscfgExRatOrder.ucRatOrderNum = ucIndex;

    /* acqorder字符串是00，99和其他值的组合 */
    if ((ulRatAutoNoChangeExistFlag == VOS_TRUE)
     && (stSyscfgExRatOrder.ucRatOrderNum > 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* acqorder字符串模式设置有重复 */
    if ( At_CheckRepeatedRatOrder(&stSyscfgExRatOrder) == VOS_TRUE )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将SYSCFGEX的接入技术形式转换为TAF_MMA_RAT_ORDER_STRU结构格式 */
    At_ConvertSysCfgExRat(ucClientId, &stSyscfgExRatOrder, pstSysCfgExSetPara);

    return AT_OK;
}


VOS_UINT32 At_CheckRepeatedRatOrder(
    AT_SYSCFGEX_RAT_ORDER_STRU         *pstSyscfgExRatOrder
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          j;

    for (i = 0; i < pstSyscfgExRatOrder->ucRatOrderNum; i++)
    {
        for (j = i + 1; j < pstSyscfgExRatOrder->ucRatOrderNum; j++)
        {
            if (pstSyscfgExRatOrder->aenRatOrder[i] == pstSyscfgExRatOrder->aenRatOrder[j])
            {
                return VOS_TRUE;
            }
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 At_CheckSysCfgExRatTypeValid(
    VOS_UINT8                           ucRatOrder
)
{
    switch ( ucRatOrder )
    {
        case AT_SYSCFGEX_RAT_AUTO:
        case AT_SYSCFGEX_RAT_NO_CHANGE:
        case AT_SYSCFGEX_RAT_LTE:
        case AT_SYSCFGEX_RAT_WCDMA:
        case AT_SYSCFGEX_RAT_GSM:
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case AT_SYSCFGEX_RAT_1X:
        case AT_SYSCFGEX_RAT_DO:
#endif
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        case AT_SYSCFGEX_RAT_NR:
#endif
            return VOS_TRUE;

        default:
            return VOS_FALSE;
    }

}



VOS_UINT32 AT_ConvertSysCfgExGuBandPara(
    VOS_UINT8                          *pucPara,
    VOS_UINT16                          usLen,
    TAF_USER_SET_PREF_BAND64           *pstPrefBandPara
)
{
    VOS_UINT32                          ulRslt;

    pstPrefBandPara->ulBandHigh = 0;
    pstPrefBandPara->ulBandLow  = 0;

    /* 如果频段为空，返回失败*/
    if (usLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 频段值小于32位时 */
    if (usLen <= AT_HEX_LEN_OF_ULONG_TYPE)
    {
        ulRslt = At_String2Hex(pucPara, usLen, &(pstPrefBandPara->ulBandLow));
    }
    else
    {
        /* 64位频段的高32位字符串转换为16进制数，转换失败返回 */
        ulRslt = At_String2Hex(pucPara, (usLen - AT_HEX_LEN_OF_ULONG_TYPE),
                               &(pstPrefBandPara->ulBandHigh));
        if (ulRslt == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 64位频段的低32位字符串转换为16进制数，转换失败返回  */
        ulRslt = At_String2Hex(pucPara + (usLen - AT_HEX_LEN_OF_ULONG_TYPE),
                               AT_HEX_LEN_OF_ULONG_TYPE, &(pstPrefBandPara->ulBandLow));
    }

    if (ulRslt == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;

}


VOS_UINT32 AT_ConvertSysCfgExLteBandPara(
    VOS_UINT8                                               *pucPara,
    VOS_UINT16                                               usLen,
    TAF_USER_SET_LTE_PREF_BAND_INFO_STRU                    *pstPrefBandPara
)
{
    TAF_USER_SET_LTE_PREF_BAND_INFO_STRU    stAllBand;
    VOS_UINT32                              ulRslt;
    VOS_UINT32                              ulLoop;
    VOS_UINT16                              usConvertCnt;

    ulRslt       = AT_SUCCESS;
    usConvertCnt = usLen / AT_HEX_LEN_OF_ULONG_TYPE;
    memset_s(&stAllBand, sizeof(stAllBand), 0xFF, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU));
    memset_s(pstPrefBandPara, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU), 0x00, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU));

    /* 参数过长，返回错误 */
    if ((usLen > TAF_MMA_LTE_BAND_MAX_LENGTH * AT_HEX_LEN_OF_ULONG_TYPE))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AP侧新需求，如果频段为空，认为频段不变 */
    if (usLen == 0)
    {
        pstPrefBandPara->aulBandInfo[0] = TAF_PH_BAND_NO_CHANGE;

        return AT_OK;
    }

    for (ulLoop = 0; ulLoop < usConvertCnt; ulLoop++)
    {
        ulRslt |= At_String2Hex(pucPara + (VOS_UINT16)((usLen - (ulLoop + 1) * AT_HEX_LEN_OF_ULONG_TYPE)),
                                AT_HEX_LEN_OF_ULONG_TYPE, &(pstPrefBandPara->aulBandInfo[ulLoop]));
    }

    if ((usLen % AT_HEX_LEN_OF_ULONG_TYPE) != 0)
    {
        ulRslt |= At_String2Hex(pucPara, usLen - (VOS_UINT16)(usConvertCnt * AT_HEX_LEN_OF_ULONG_TYPE),
                                &(pstPrefBandPara->aulBandInfo[usConvertCnt]));
    }

    if (ulRslt != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AP侧需求，全部设置为F时，认为是全频段 */
    if (VOS_MemCmp(pstPrefBandPara, &stAllBand, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU)) == 0)
    {
        memset_s(pstPrefBandPara, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU), 0x00, sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU));
        pstPrefBandPara->aulBandInfo[0] = MN_MMA_LTE_LOW_BAND_ANY;
        pstPrefBandPara->aulBandInfo[1] = MN_MMA_LTE_HIGH_BAND_ANY;
    }

    return AT_OK;
}


TAF_MMA_USER_SET_PRIO_RAT_ENUM_U8 AT_GetSysCfgPrioRat(
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
)
{
    TAF_MMA_USER_SET_PRIO_RAT_ENUM_U8   enUserPrio;
    VOS_UINT8                           i;

    enUserPrio = TAF_MMA_USER_SET_PRIO_NOCHANGE;

    if (AT_IsSpecRatSupported(TAF_MMA_RAT_LTE, &pstSysCfgExSetPara->stMultiModeRatCfg) == VOS_TRUE)
    {
        return enUserPrio;
    }


#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    if (AT_IsSpecRatSupported(TAF_MMA_RAT_NR, &pstSysCfgExSetPara->stMultiModeRatCfg) == VOS_TRUE)
    {
        return enUserPrio;
    }
#endif
    for (i = 0; i < AT_MIN(TAF_MMA_RAT_BUTT, pstSysCfgExSetPara->stMultiModeRatCfg.ucRatNum); i++ )
    {
        if (pstSysCfgExSetPara->stMultiModeRatCfg.aenRatOrder[i] == TAF_MMA_RAT_GSM)
        {
            enUserPrio = TAF_MMA_USER_SET_PRIO_GSM_PREFER;
            break;
        }

        if (pstSysCfgExSetPara->stMultiModeRatCfg.aenRatOrder[i] == TAF_MMA_RAT_WCDMA)
        {
            enUserPrio = TAF_MMA_USER_SET_PRIO_WCDMA_PREFER;
            break;
        }

    }

    return enUserPrio;
}


LOCAL VOS_UINT32 AT_IsModeConflictingDomain(
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
)
{
    /* 如果设置的模式里有L 或者 NR,且服务域是cs only，返回VOS_TRUE */
    if((gastAtParaList[3].ulParaValue == TAF_MMA_SERVICE_DOMAIN_CS)
    || (gastAtParaList[3].ulParaValue == TAF_MMA_SERVICE_DOMAIN_ANY))
    {
        if (AT_IsSpecRatSupported(TAF_MMA_RAT_LTE, &pstSysCfgExSetPara->stMultiModeRatCfg) == VOS_TRUE)
        {
            return VOS_TRUE;
        }
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        if (AT_IsSpecRatSupported(TAF_MMA_RAT_NR, &pstSysCfgExSetPara->stMultiModeRatCfg) == VOS_TRUE)
        {
            return VOS_TRUE;
        }
#endif
    }
    return VOS_FALSE;
}



VOS_UINT32 AT_CheckSysCfgExPara(
    VOS_UINT8                           ucClientId,
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgExSetPara
)
{
    VOS_UINT32                          ulRst;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucClientId);

    /* 检查参数个数,如果不为7个，返回AT_CME_INCORRECT_PARAMETERS*/
    if ( gucAtParaIndex != AT_SYSCFGEX_PARA_NUM )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查acqorder参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败*/
    ulRst = AT_ConvertSysCfgExRatOrderPara(ucClientId, pstSysCfgExSetPara);

    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (pstSysCfgExSetPara->enRatCfgNoChangeType != TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFGEX)
    {
        pstSysCfgExSetPara->enUserPrio = AT_GetSysCfgPrioRat(pstSysCfgExSetPara);
    }

    /* 如果设置的模式里有L,且服务域是cs only，返回失败 */

    if (AT_IsModeConflictingDomain(pstSysCfgExSetPara) == VOS_TRUE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查band参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败*/
    ulRst = AT_ConvertSysCfgExGuBandPara(gastAtParaList[1].aucPara,
                                       gastAtParaList[1].usParaLen,
                                       &pstSysCfgExSetPara->stGuBand);

    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 漫游特性未激活,漫游能力取值范围0-2; 漫游特性激活,漫游能力取值范围0-3 */
    AT_ReadRoamCfgInfoNvim(ucClientId);
    if (((pstNetCtx->ucRoamFeature == AT_ROAM_FEATURE_OFF) && (gastAtParaList[2].ulParaValue > AT_ROAM_FEATURE_OFF_NOCHANGE))
     || ((pstNetCtx->ucRoamFeature == AT_ROAM_FEATURE_ON) && (gastAtParaList[2].ulParaValue > TAF_MMA_ROAM_NATIONAL_OFF_INTERNATIONAL_OFF)))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    pstSysCfgExSetPara->enRoam = (VOS_UINT8)gastAtParaList[2].ulParaValue;

    /* 检查lteband参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败*/
    ulRst = AT_ConvertSysCfgExLteBandPara(gastAtParaList[4].aucPara,
                                       gastAtParaList[4].usParaLen,
                                       &pstSysCfgExSetPara->stLBand);
    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    pstSysCfgExSetPara->enSrvDomain = (VOS_UINT8)gastAtParaList[3].ulParaValue;

    return ulRst;

}



VOS_UINT32 AT_SetSysCfgExPara(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_SYS_CFG_PARA_STRU           stSysCfgExSetPara;

    VOS_UINT32                          ulRst;

    AT_PR_LOGI("Rcv Msg");

    memset_s(&stSysCfgExSetPara, sizeof(stSysCfgExSetPara), 0x00, sizeof(stSysCfgExSetPara));


    /* 参数个数和合法性检查,不合法直接返回失败 */
    ulRst = AT_CheckSysCfgExPara(ucIndex, &stSysCfgExSetPara);

    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    ulRst = TAF_MMA_SetSysCfgReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stSysCfgExSetPara);
    AT_PR_LOGI("Call interface success!");

    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SYSCFG_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32 AT_GetValidNetScanPowerParam(
    VOS_INT16                          *psCellPower
)
{
    VOS_UINT32                          ulCellPower;

    ulCellPower = 0;

    /* power长度大于4或小于3表示无效参数 */
    if ( (gastAtParaList[1].usParaLen > AT_NETSCAN_POWER_PARA_MAX_LEN)
      || (gastAtParaList[1].usParaLen < AT_NETSCAN_POWER_PARA_MIN_LEN) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串第一个参数不为'-'，即为无效参数 */
    if ( gastAtParaList[1].aucPara[0] != '-' )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* POWER首字符为'-',获取后面的值 */
    if ( atAuc2ul( &gastAtParaList[1].aucPara[1],
                   gastAtParaList[1].usParaLen - 1,
                   &ulCellPower) != AT_SUCCESS )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 由于POWER值为负，所以转换下 */
    *psCellPower = -(VOS_INT16)ulCellPower;

    /* GU Power取值判断[-110,-47]；LTE/NR Power取值判断[-125,-47] */
    if (*psCellPower > AT_NETSCAN_POWER_MAX_VALUE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
     || gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE_NRDC
     || gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_NR
#endif
     )
    {
        if (*psCellPower < AT_NETSCAN_LTE_POWER_MIN_VALUE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else
    {
        if (*psCellPower < AT_NETSCAN_POWER_MIN_VALUE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_GetValidNetScanBandPara(
    TAF_MMA_BAND_SET_STRU              *pstBandSet
)
{
    VOS_UINT8                          *pucPara             = VOS_NULL_PTR;
    VOS_UINT16                          usLen;
    VOS_UINT16                          usTmpLen;
    VOS_UINT8                           ucIndex;
    VOS_UINT8                           ucIsNullBand;

    pucPara         = gastAtParaList[3].aucPara;
    usLen           = gastAtParaList[3].usParaLen;
    ucIsNullBand    = VOS_TRUE;
    memset_s(pstBandSet, sizeof(TAF_MMA_BAND_SET_STRU), 0,sizeof(TAF_MMA_BAND_SET_STRU));

    /* 如果频段为空，则认为是全频段搜索 */
    if (usLen == 0)
    {
        if ((gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_GSM)
         || (gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_UMTS))
        {
            pstBandSet->aulBand[0]   = AT_ALL_GU_BAND;
        }
        else if (gastAtParaList[2].ulParaValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE)
        {
            pstBandSet->aulBand[0]   = MN_MMA_LTE_LOW_BAND_ANY;
            pstBandSet->aulBand[1]   = MN_MMA_LTE_HIGH_BAND_ANY;
        }
        else
        {
            AT_NORM_LOG1("AT_GetValidNetScanBandPara: <mode>", gastAtParaList[2].ulParaValue);
        }
        return AT_OK;
    }

    /* 转换频段 */
    for (ucIndex = 0; ucIndex < TAF_MMA_BAND_MAX_LEN; ucIndex++)
    {
        usTmpLen = (usLen < AT_HEX_LEN_OF_ULONG_TYPE) ? usLen : AT_HEX_LEN_OF_ULONG_TYPE;

        if (At_String2Hex(pucPara + gastAtParaList[3].usParaLen - (ucIndex * AT_HEX_LEN_OF_ULONG_TYPE) - usTmpLen,
                          usTmpLen,
                          &(pstBandSet->aulBand[ucIndex])) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (pstBandSet->aulBand[ucIndex] != 0)
        {
            ucIsNullBand = VOS_FALSE;
        }

        if (usLen <= AT_HEX_LEN_OF_ULONG_TYPE)
        {
            break;
        }

        usLen -= AT_HEX_LEN_OF_ULONG_TYPE;
    }

    /* 不允许扫描空BAND */
    if (ucIsNullBand == VOS_TRUE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}



VOS_UINT32 AT_GetValidNetScanPara(
    TAF_MMA_NET_SCAN_SET_PARA_STRU_STRU                    *pstNetScanSetPara
)
{
    /* 检查参数个数,如果超过4个，返回AT_CME_INCORRECT_PARAMETERS*/
    if ( (gucAtParaIndex > AT_NETSCAN_PARA_MAX_NUM)
      || (gucAtParaIndex < AT_NETSCAN_PARA_MIN_NUM) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数校验 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置CellNum */
    pstNetScanSetPara->usCellNum = (VOS_UINT16)gastAtParaList[0].ulParaValue;

    /* 设置CellPow */
    if (AT_GetValidNetScanPowerParam(&(pstNetScanSetPara->sCellPow)) != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 缺省<mode>参数，但不缺省<band>参数，则认为参数错误 */
    if ((gucAtParaIndex == AT_NETSCAN_PARA_MAX_NUM)
     && (gastAtParaList[2].usParaLen == 0)
     && (gastAtParaList[3].usParaLen != 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果用户没输入接入技术，该gastAtParaList[2].ulParaValue就是0 */
    if ( gastAtParaList[2].usParaLen == 0 )
    {
        pstNetScanSetPara->enRat     = TAF_MMA_NET_SCAN_RAT_MODE_GSM;
    }
    else
    {
        pstNetScanSetPara->enRat     = (TAF_MMA_NET_SCAN_RAT_MODE_ENUM_UINT8)gastAtParaList[2].ulParaValue;
    }

    /* 检查band参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败*/
    return AT_GetValidNetScanBandPara(&pstNetScanSetPara->stBand);
}



VOS_UINT32 AT_SetNetScanPara(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulRst;
    TAF_MMA_NET_SCAN_SET_PARA_STRU_STRU stNetScanSetPara;

    memset_s(&stNetScanSetPara, sizeof(stNetScanSetPara), 0x00, sizeof(stNetScanSetPara));

    ulRst = AT_GetValidNetScanPara(&stNetScanSetPara);
    if (ulRst != AT_OK)
    {
        TAF_LOG(WUEPS_PID_AT, VOS_NULL, PS_LOG_LEVEL_ERROR, "AT_SetNetScanPara:ERROR: AT_GetValidNetScanPara returns FAILURE");
        return ulRst;
    }

    ulRst = TAF_MMA_NetScanReq(WUEPS_PID_AT,
                               gastAtClientTab[ucIndex].usClientId,
                               0,
                               &stNetScanSetPara);
    if (ulRst == VOS_TRUE)
    {
        /* 指示当前用户的命令操作类型为设置命令 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NETSCAN_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_AbortNetScanPara(
    VOS_UINT8                           ucIndex
)
{
    /* 当前只能处理NETSCAN设置的打断, 其它命令则不进行打断操作 */
    if ( gastAtClientTab[ucIndex].CmdCurrentOpt == AT_CMD_NETSCAN_SET )
    {
        /* AT向MMA发送打断NETSCAN的请求 */
        if ( TAF_MMA_NetScanAbortReq(WUEPS_PID_AT,
                                     gastAtClientTab[ucIndex].usClientId,
                                     0) == VOS_TRUE)
        {
            /* 停止NETSCANAT的保护定时器 */
            AT_StopRelTimer(ucIndex, &gastAtClientTab[ucIndex].hTimer);

            /* 更新当前操作类型 */
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NETSCAN_ABORT;

            return AT_WAIT_ASYNC_RETURN;
        }

        /* AT向MMA发送打断NETSCAN的请求失败，返回失败 */
        return AT_FAILURE;
    }

    /* 当前非设置命令，返回失败 */
    return AT_FAILURE;
}




VOS_VOID AT_ChangeSysCfgRatPrio(
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstRatOrder,
    AT_SYSCFG_RAT_PRIO_ENUM_UINT8       enAcqorder
)
{
    if (pstRatOrder->ucRatNum == TAF_PH_MAX_GU_RAT_NUM)
    {
        if (((enAcqorder == AT_SYSCFG_RAT_PRIO_AUTO)
         || (enAcqorder == AT_SYSCFG_RAT_PRIO_WCDMA)))
        {
            pstRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
            pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_WCDMA;
            pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_GSM;
            pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
        }
        else if (enAcqorder == AT_SYSCFG_RAT_PRIO_GSM)
        {
            pstRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
            pstRatOrder->aenRatOrder[0] = TAF_MMA_RAT_GSM;
            pstRatOrder->aenRatOrder[1] = TAF_MMA_RAT_WCDMA;
            pstRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;
        }
        else
        {
        }

    }
    else
    {
        /* 原单模无需考虑接入优先级 */
    }

}


VOS_UINT32 AT_ConvertSysCfgRatOrderPara(
    VOS_UINT8                           ucClientId,
    AT_SYSCFG_RAT_TYPE_ENUM_UINT8       enRatMode,
    AT_SYSCFG_RAT_PRIO_ENUM_UINT8       enAcqorder,
    TAF_MMA_SYS_CFG_PARA_STRU          *pstSysCfgPara
)
{
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRst;
    TAF_MMA_MULTIMODE_RAT_CFG_STRU     *pstSysCfgRatOrder =  VOS_NULL_PTR;

    enModemId = MODEM_ID_0;
    pstSysCfgRatOrder = &(pstSysCfgPara->stMultiModeRatCfg);
    /* 获取ModemId */
    ulRst = AT_GetModemIdFromClient(ucClientId, &enModemId);

    if (ulRst != VOS_OK)
    {
        AT_ERR_LOG1("AT_ConvertSysCfgRatOrderPara:Get ModemID From ClientID fail,ClientID:", ucClientId);
        return AT_ERROR;
    }
    switch (enRatMode)
    {
        case AT_SYSCFG_RAT_AUTO:
            /* 如果接入优先级不改变则默认从NVIM中获取 */
            if ( enAcqorder == AT_SYSCFG_RAT_PRIO_NO_CHANGE )
            {
                AT_GetGuAccessPrioNvim(enModemId, &enAcqorder);
            }


            /* ucAcqorder为0自动或先WCDMA后GSM*/

            if (enAcqorder == AT_SYSCFG_RAT_PRIO_AUTO)
            {
                AT_SetDefaultRatPrioList(enModemId, pstSysCfgRatOrder, VOS_FALSE, VOS_FALSE);
            }
            else if (enAcqorder == AT_SYSCFG_RAT_PRIO_WCDMA)
            {
                pstSysCfgRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
                pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_WCDMA;
                pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_GSM;
                pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            }
            else if (enAcqorder == AT_SYSCFG_RAT_PRIO_GSM)
            {
                pstSysCfgRatOrder->ucRatNum  = TAF_PH_MAX_GU_RAT_NUM;
                pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_GSM;
                pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_WCDMA;
                pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            }
            else
            {

            }

            break;

        case AT_SYSCFG_RAT_GSM:
            /* G单模 */
            pstSysCfgRatOrder->ucRatNum  = 1;
            pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_GSM;
            pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_WCDMA:
            /* W单模*/
            pstSysCfgRatOrder->ucRatNum  = 1;
            pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_WCDMA;
            pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case AT_SYSCFG_RAT_1X:
            /* 1X单模 */
            pstSysCfgRatOrder->ucRatNum  = 1;
            pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_1X;
            pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_HRPD:
            /* HRPD单模*/
            pstSysCfgRatOrder->ucRatNum  = 1;
            pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_HRPD;
            pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_BUTT;
            pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_1X_AND_HRPD:
            /* 1X&HRPD混合模式 */
            pstSysCfgRatOrder->ucRatNum  = 2;
            pstSysCfgRatOrder->aenRatOrder[0] = TAF_MMA_RAT_1X;
            pstSysCfgRatOrder->aenRatOrder[1] = TAF_MMA_RAT_HRPD;
            pstSysCfgRatOrder->aenRatOrder[2] = TAF_MMA_RAT_BUTT;

            break;
#endif

        case AT_SYSCFG_RAT_NO_CHANGE:
            pstSysCfgRatOrder->ucRatNum             = 0;
            pstSysCfgPara->enRatCfgNoChangeType     = TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFG;
            break;

        default:
            return AT_CME_INCORRECT_PARAMETERS;

    }


    /*返回成功*/
    return AT_OK;
}


#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetSysCfgPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_SYS_CFG_PARA_STRU           stSysCfgPara;

    VOS_UINT32                          ulRst;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    AT_PR_LOGI("Rcv Msg");

    memset_s(&stSysCfgPara, sizeof(stSysCfgPara), 0x00, sizeof(TAF_MMA_SYS_CFG_PARA_STRU));

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    if ( gucAtParaIndex != 5 )
    {                                                                           /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0)
     || (gastAtParaList[2].usParaLen == 0)
     || (gastAtParaList[3].usParaLen == 0)
     || (gastAtParaList[4].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }




    ulRst = AT_ConvertSysCfgRatOrderPara(ucIndex, (VOS_UINT8)gastAtParaList[0].ulParaValue,
                                         (VOS_UINT8)gastAtParaList[1].ulParaValue,
                                         &stSysCfgPara);

    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }



    ulRst = AT_ConvertSysCfgExGuBandPara(gastAtParaList[2].aucPara,
                                       gastAtParaList[2].usParaLen,
                                       &stSysCfgPara.stGuBand);
    if (ulRst != AT_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要将L的频段设置为不改变 */
    stSysCfgPara.enUserPrio         = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    memset_s(&(stSysCfgPara.stLBand),
             sizeof(stSysCfgPara.stLBand),
             0x00,
             sizeof(TAF_USER_SET_LTE_PREF_BAND_INFO_STRU));
    stSysCfgPara.stLBand.aulBandInfo[0] = TAF_PH_BAND_NO_CHANGE;

    AT_ReadRoamCfgInfoNvim(ucIndex);

    if (((pstNetCtx->ucRoamFeature == AT_ROAM_FEATURE_OFF) && (gastAtParaList[3].ulParaValue > 2))
     || ((pstNetCtx->ucRoamFeature == AT_ROAM_FEATURE_ON) && (gastAtParaList[3].ulParaValue > 3)))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    stSysCfgPara.enRoam       = (VOS_UINT8) gastAtParaList[3].ulParaValue;
    stSysCfgPara.enSrvDomain  = (VOS_UINT8) gastAtParaList[4].ulParaValue;




    /* 执行命令操作 */
    if (TAF_MMA_SetSysCfgReq(WUEPS_PID_AT,gastAtClientTab[ucIndex].usClientId, 0, &stSysCfgPara) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SYSCFG_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}
#endif


TAF_UINT32 At_CheckDataState(TAF_UINT8 ucDataMode)
{
    TAF_UINT8 ucIndex = 0;

    for(ucIndex = 0; ucIndex < AT_MAX_CLIENT_NUM; ucIndex++)
    {
        if( (gastAtClientTab[ucIndex].ucUsed == AT_CLIENT_USED)
         && (gastAtClientTab[ucIndex].Mode == AT_DATA_MODE)
         && (ucDataMode == gastAtClientTab[ucIndex].DataMode))
        {
            return AT_SUCCESS;
        }
    }

    return AT_FAILURE;
}


/*****************************************************************************
 Prototype      : At_SetCcinPara
 Description    :
 Input          : ucIndex --- 用户索引
 Output         :
 Return Value   : AT_XXX  --- ATC返回码
 Calls          : ---
 Called By      : ---

 History        : ---
  1.Date        : 2005-04-19
    Author      : ---
    Modification: Created function
*****************************************************************************/
TAF_UINT32 At_SetCcinPara(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果 参数是配置为启动主动上报模式；
       返回OK，并切换当前用户为主动上报模式；
       如果 参数是配置为停止主动上报模式；
       返回OK，并切换当前用户为普通命令模式；*/

    gastAtClientTab[ucIndex].IndMode = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    return AT_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

TAF_UINT32 At_SetTrigPara (TAF_UINT8 ucIndex)
{
    TAF_UINT8                           i;
    TAF_GPRS_DATA_STRU                  stGprsDataInfo;


    memset_s(&stGprsDataInfo, sizeof(stGprsDataInfo), 0x00, sizeof(stGprsDataInfo));


    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 5)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    for(i=0;i<5;i++)
    {
        if (gastAtParaList[i].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    stGprsDataInfo.ucMode = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    if ((stGprsDataInfo.ucMode!=0) && (stGprsDataInfo.ucMode!=1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if((gastAtParaList[1].ulParaValue >= 5) && (gastAtParaList[1].ulParaValue <= 15))
    {
        stGprsDataInfo.ucNsapi = (TAF_UINT8)gastAtParaList[1].ulParaValue;
    }
    else
    {
        return AT_ERROR;
    }

    stGprsDataInfo.ulLength      = (TAF_UINT32)gastAtParaList[2].ulParaValue;
    stGprsDataInfo.ucTimes       = (TAF_UINT8)gastAtParaList[3].ulParaValue;
    stGprsDataInfo.ulMillisecond = (TAF_UINT32)gastAtParaList[4].ulParaValue;

    /* 执行命令操作 */
    if ( TAF_PS_TrigGprsData(WUEPS_PID_AT,
                             AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                             gastAtClientTab[ucIndex].opId,
                             &stGprsDataInfo) )
    {
        return AT_ERROR;
    }
    /* Modified by A00165503for AT Project，2011-10-17, end */

    return AT_OK;
}


TAF_UINT32 At_SetGcfIndPara (TAF_UINT8 ucIndex)
{
    VOS_UINT8                           ucGctTestFlag;
    VOS_UINT32                          ulRst;

    ucGctTestFlag = 0;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucGctTestFlag = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    if ((ucGctTestFlag != 0) && (ucGctTestFlag != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_GCF_IND,
                                   &ucGctTestFlag,
                                   sizeof(VOS_UINT8),
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif


VOS_UINT32 At_SetGcapPara(TAF_UINT8 ucIndex)
{
    TAF_UINT16           usLength = 0;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gucAtParaIndex != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s: %s",g_stParseContext[ucIndex].pstCmdElement->pszCmdName,"+CGSM,+DS,+ES");

    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}


VOS_UINT32 At_SetMsIdInfo(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_MSID_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MSID_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}


TAF_UINT32 AT_SetDsFlowClrPara(TAF_UINT8 ucIndex)
{
    TAF_DSFLOW_CLEAR_CONFIG_STRU        stClearConfigInfo;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stClearConfigInfo, sizeof(stClearConfigInfo), 0x00, sizeof(TAF_DSFLOW_CLEAR_CONFIG_STRU));

    /* 设置参数 */
    stClearConfigInfo.enClearMode       = TAF_DSFLOW_CLEAR_TOTAL;

    /* 执行命令操作 */
    if ( TAF_PS_ClearDsFlowInfo(WUEPS_PID_AT,
                                AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                0, &stClearConfigInfo) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_DSFLOWCLR_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetDsFlowQryPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if ( TAF_PS_GetDsFlowInfo(WUEPS_PID_AT,
                              AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                              0) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_DSFLOWQRY_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetDsFlowRptPara(TAF_UINT8 ucIndex)
{
    TAF_DSFLOW_REPORT_CONFIG_STRU       stReportConfigInfo;

    /* 初始化 */
    memset_s(&stReportConfigInfo, sizeof(stReportConfigInfo), 0x00, sizeof(TAF_DSFLOW_REPORT_CONFIG_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    stReportConfigInfo.ulRptEnabled         = gastAtParaList[0].ulParaValue;


    if ( stReportConfigInfo.ulRptEnabled == VOS_TRUE )
    {
        /* 设置流量上报周期时长 */
        stReportConfigInfo.ulTimerLength    = 2000;
    }


    /* 执行命令操作 */
    if ( TAF_PS_ConfigDsFlowRpt(WUEPS_PID_AT,
                                AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                0, &stReportConfigInfo) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_DSFLOWRPT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetVTFlowRptPara(TAF_UINT8 ucIndex)
{
    TAF_VTFLOW_REPORT_CONFIG_STRU       stReportConfigInfo;

    /* 初始化 */
    memset_s(&stReportConfigInfo, sizeof(stReportConfigInfo), 0x00, sizeof(TAF_VTFLOW_REPORT_CONFIG_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    stReportConfigInfo.ucRptEnabled         = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    if ( TAF_PS_ConfigVTFlowRpt(WUEPS_PID_AT,
                                AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                0, &stReportConfigInfo) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_VTFLOWRPT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetSrvstPara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_SRVST_RPT_TYPE;
    stAtCmd.u.ucSrvstRptFlg = 0;

    if (gastAtParaList[0].usParaLen != 0)
    {
        stAtCmd.u.ucSrvstRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    /* 给MTA发送^srvst设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetRssiPara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_RSSI_RPT_TYPE;
    stAtCmd.u.ucRssiRptFlg  = AT_RSSI_RESULT_CODE_NOT_REPORT_TYPE;

    if (gastAtParaList[0].usParaLen != 0)
    {
        stAtCmd.u.ucRssiRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    /* 给MTA发送^rssi设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    /* AT不需要发给L4A，由MMC发给LMM,再由LMM通知LRRC */

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;

}



VOS_UINT32 At_SetCerssiPara(VOS_UINT8 ucIndex)
{
    TAF_START_INFO_IND_STRU             stStartInfoInd;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;


    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);


    memset_s(&stStartInfoInd, sizeof(stStartInfoInd), 0x00, sizeof(stStartInfoInd));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gucAtParaIndex > 2)
     || (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }




    if (gucAtParaIndex == 1)
    {
        pstNetCtx->ucCerssiReportType        = 0;
        pstNetCtx->ucCerssiMinTimerInterval  = 0;
        stStartInfoInd.ucMinRptTimerInterval = 0;
    }

    if (gucAtParaIndex == 2)
    {
        pstNetCtx->ucCerssiMinTimerInterval  = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        stStartInfoInd.ucMinRptTimerInterval = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    }

    if (gastAtParaList[0].ulParaValue != 0)
    {
        pstNetCtx->ucCerssiReportType  = (VOS_UINT8)gastAtParaList[0].ulParaValue;
        stStartInfoInd.ucActionType    = TAF_START_EVENT_INFO_FOREVER;
        stStartInfoInd.ucSignThreshold = (VOS_UINT8)gastAtParaList[0].ulParaValue;
        stStartInfoInd.ucRrcMsgType    = TAF_EVENT_INFO_CELL_SIGN;
    }
    else
    {
        /* 由于+creg/+cgreg/+csq/^rssi都是通过RRMM_AT_MSG_REQ或GRRMM_AT_MSG_REQ通知接入层主动上报，
           所以不能通知接入层停止，设置成默认rssi 5db改变上报，AT_GetModemNetCtxAddrFromClientId(ucIndex)->ucCerssiReportType全局变量控制^cerssi是否上报 */
        stStartInfoInd.ucActionType     = TAF_START_EVENT_INFO_FOREVER;
        stStartInfoInd.ucRrcMsgType     = TAF_EVENT_INFO_CELL_SIGN;
        stStartInfoInd.ucSignThreshold  = 0;
        pstNetCtx->ucCerssiReportType   = AT_CERSSI_REPORT_TYPE_NOT_REPORT;
        pstNetCtx->ucCerssiMinTimerInterval  = 0;
        stStartInfoInd.ucMinRptTimerInterval = 0;
    }

    if (TAF_MMA_SetCerssiReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stStartInfoInd) == VOS_TRUE)
    {
        /* Set at cmd type */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CERSSI_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

    /* AT不需要发给L4A，由MMC发给LMM,再由LMM通知LRRC */

}



VOS_UINT32 At_SetCnmrPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_QRY_NMR_REQ_STRU             stQryNmrReq;

    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    /* 查询4g的nmr数据直接返回失败 */
    if (gastAtParaList[0].ulParaValue == AT_CNMR_QRY_LTE_NMR_DATA)
    {
        return AT_ERROR;
    }

    /* 发送消息DRV_AGENT_AS_QRY_NMR_REQ给C核处理 */
    memset_s(&stQryNmrReq, sizeof(stQryNmrReq), 0x00, sizeof(stQryNmrReq));

    if (gastAtParaList[0].ulParaValue == AT_CNMR_QRY_WAS_NMR_DATA)
    {
        stQryNmrReq.ucRatType = 0;
    }
    else
    {
        stQryNmrReq.ucRatType = 1;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   ID_AT_MTA_QRY_NMR_REQ,
                                   &stQryNmrReq,
                                   sizeof(stQryNmrReq),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CNMR_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}





TAF_UINT32  At_SetTimePara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].ulParaValue > 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_TIME_RPT_TYPE;
    stAtCmd.u.ucTimeRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^time设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;

}


TAF_UINT32  At_SetCtzrPara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数范围扩展 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].ulParaValue > 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_CTZR_RPT_TYPE;
    stAtCmd.u.ucCtzrRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^ctzr设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;

}


TAF_UINT32 At_SetModePara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;
 #if (FEATURE_LTE == FEATURE_ON)
    L4A_IND_CFG_STRU                        stL4AIndCfgReq;
    MODEM_ID_ENUM_UINT16                    enModemId;

    enModemId  = MODEM_ID_0;
#endif

    /* AT命令参数合法性检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_MODE_RPT_TYPE;
    stAtCmd.u.ucModeRptFlg  = AT_MODE_RESULT_CODE_NOT_REPORT_TYPE;

    if (gastAtParaList[0].usParaLen != 0)
    {
        stAtCmd.u.ucModeRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    /* 给MTA发送^mode设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

#if  (FEATURE_LTE == FEATURE_ON)
    ulResult = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulResult != VOS_OK)
    {
        AT_ERR_LOG1("At_SetModePara:Get ModemID From ClientID fail,ClientID=%d", ucIndex);
        return AT_ERROR;
    }

    if (AT_IsModemSupportRat(enModemId, TAF_MMA_RAT_LTE) == VOS_TRUE)
    {
        memset_s(&stL4AIndCfgReq, sizeof(stL4AIndCfgReq), 0x00, sizeof(stL4AIndCfgReq));
        stL4AIndCfgReq.mode_bit_valid  = 1;
        stL4AIndCfgReq.mode_bit        = gastAtParaList[0].ulParaValue;

        /* 通知L此次mode的设置 */
        AT_SetLIndCfgReq(ucIndex, &stL4AIndCfgReq);
    }
#endif

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;

}

VOS_UINT32 At_SetSimstPara(TAF_UINT8 ucIndex)
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_SIMST_RPT_TYPE;
    stAtCmd.u.ucSimstRptFlg = AT_SIMST_ENABLE_TYPE;

    if (gastAtParaList[0].usParaLen != 0)
    {
        stAtCmd.u.ucSimstRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

TAF_UINT32 At_SetHSPara(TAF_UINT8 ucIndex)
{
    TAF_UINT8                           aucBuf[5];
    errno_t                             lMemResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen != 0)
    {
        lMemResult = memcpy_s(aucBuf, sizeof(aucBuf), &gastAtParaList[0].ulParaValue, sizeof(TAF_UINT32));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucBuf), sizeof(TAF_UINT32));
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[1].usParaLen != 0)
    {
        aucBuf[4] = (TAF_UINT8)gastAtParaList[1].ulParaValue;
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作，这些参数可以不用发送到MMA */
    if(TAF_MMA_QryHandShakeReq(WUEPS_PID_AT,
                               gastAtClientTab[ucIndex].usClientId,
                               0) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_HS_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_UpdateSvn(
    MODEM_ID_ENUM_UINT16                enModemId,
    VOS_UINT8                           aucSvn[],
    VOS_UINT16                          usSvnLength
)
{
    TAF_SVN_DATA_STRU                   stSvn;


    memset_s(&stSvn, sizeof(stSvn), 0x00, sizeof(stSvn));


    /* SVN 长度检查: 用户输入的SVN固定长度应为2位 */
    if (usSvnLength != TAF_SVN_DATA_LENGTH)
    {
        AT_NORM_LOG("AT_UpdateSvn: the length of SVN is error.");
        return AT_PHYNUM_LENGTH_ERR;
    }

    /* SVN 字符串检查1: 确认<SVN>为数字字符串, 并将ASCII码转换成BCD码 */
    if (At_AsciiNum2Num(stSvn.aucSvn, aucSvn, usSvnLength) != AT_SUCCESS)
    {
        AT_NORM_LOG("AT_UpdateSvn: the number of SVN is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    /* SVN 字符串检查2: 99是SVN的保留数值，返回AT_PHYNUM_NUMBER_ERR物理号错误
       参考协议: 3GPP 23003 6.3 Allocation principles SVN value 99 is reserved for future use. */
    if ((stSvn.aucSvn[0] == 9) && (stSvn.aucSvn[1] == 9))
    {
        AT_NORM_LOG("AT_UpdateSvn: the number of SVN is reserved.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    /* 设置SVN的NV项激活标志为激活，此标志默认为未激活； */
    stSvn.ucActiveFlag = NV_ITEM_ACTIVE;

    /* 清空无效的末位字节 */
    stSvn.aucReserve[0] = 0;

    if (TAF_ACORE_NV_WRITE(enModemId, en_NV_Item_Imei_Svn, &stSvn, sizeof(stSvn)) != NV_OK)
    {
         AT_WARN_LOG("AT_UpdateSvn: Fail to write NV.");
         return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_CheckPhyNumPara(AT_PHYNUM_TYPE_ENUM_UINT32 *penSetType)
{
    VOS_UINT32                          ulTimes;
    VOS_UINT32                          ulRet;

    /* <type>参数检查: BALONG仅支持输入物理号为IMEI或SVN，
       否则，直接返回错误，< err_code > 错误码为1物理号不合法 */
    /* 全部格式化为大写字符 */
    if(At_UpString(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    if (VOS_StrCmp((VOS_CHAR *)gastAtParaList[0].aucPara, "IMEI") == 0)
    {
        *penSetType = AT_PHYNUM_TYPE_IMEI;
    }
    else if (VOS_StrCmp((VOS_CHAR *)gastAtParaList[0].aucPara, "SVN") == 0)
    {
        *penSetType = AT_PHYNUM_TYPE_SVN;
    }
    else if (VOS_StrCmp((VOS_CHAR *)gastAtParaList[0].aucPara, "MACWLAN") == 0)
    {
        *penSetType = AT_PHYNUM_TYPE_MAC;
    }
    else
    {
        AT_NORM_LOG("AT_CheckPhyNumPara: the type of physical is error.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* < times >参数检查: 输入< times >范围为0-1，否则返回AT_ERROR */
    if (gastAtParaList[2].usParaLen != 0)
    {
        /* TIMES的取值范围是0－1 */
        ulRet = At_Auc2ul(gastAtParaList[2].aucPara,
                          gastAtParaList[2].usParaLen,
                          &ulTimes);
        if ((ulRet != AT_SUCCESS) || (ulTimes > 1))
        {
            AT_NORM_LOG("AT_CheckPhyNumPara: times error.");
            return AT_ERROR;
        }
    }

    return AT_OK;
}


VOS_UINT32  AT_SetPhyNumPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    AT_PHYNUM_TYPE_ENUM_UINT32          enSetType;
    VOS_BOOL                            bPhyNumIsNull;
    MODEM_ID_ENUM_UINT16                enModemId;

    enModemId = MODEM_ID_0;

    /* 参数个数有效性检查: 参数至少包括<type>,<number>两部分，
       最多可以再包含< times > ，参数个数错误，返回AT_ERROR */
    if ((gucAtParaIndex != 2) && (gucAtParaIndex != 3))
    {
        AT_NORM_LOG("AT_SetPhyNumPara: the number of parameter is error.");
        return AT_ERROR;
    }

    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("AT_SetPhyNumPara: Get modem id fail.");
        return AT_ERROR;
    }

    ulRet = AT_CheckPhyNumPara(&enSetType);
    if (ulRet != AT_OK)
    {
        return ulRet;
    }

    /* 物理号不为空，且数据保护未解锁，直接返回错误，< err_code > 错误码为1物理号不合法。 */
    if (AT_PhyNumIsNull(enModemId, enSetType, &bPhyNumIsNull) != AT_OK)
    {
        return AT_ERROR;
    }

    if ((bPhyNumIsNull == VOS_FALSE) && (g_bAtDataLocked == VOS_TRUE))
    {
        AT_NORM_LOG("AT_SetPhyNumPara: physical number is not null and data locked.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* 若当前用户设置的物理号为IMEI，则修改en_NV_Item_IMEI中的数据 */
    /* 若当前用户设置的物理号为SVN，则修改en_Nv_Item_Imei_Svn中的数据 */
    /* 若当前用户设置的物理号为MAC，则修改MAC地址对应的NV项(新增数据卡MAC地址的NV项)中的数据 */
    if (enSetType == AT_PHYNUM_TYPE_IMEI)
    {
#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)
        ulRet = AT_UpdateImei(enModemId, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
#else
        ulRet = AT_OK;
#endif

    }
    else if (enSetType == AT_PHYNUM_TYPE_SVN)
    {
        ulRet = AT_UpdateSvn(enModemId, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    }
    else
    {
        /*更新MAC地址到NV*/
        ulRet = AT_UpdateMacPara(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    }

    return ulRet;
}


VOS_UINT32 AT_SetGTimerPara(VOS_UINT8 ucIndex)
{

    /* 参数个数错误，返回AT_DEVICE_OTHER_ERROR，上报CME ERROR:1 */
    if (gucAtParaIndex != 1)
    {
        AT_NORM_LOG("AT_SetGTimerPara: the number of parameter is error.");
        return AT_ERROR;
    }

    /* 数据保护未解锁，返回AT_DATA_UNLOCK_ERROR，上报CME ERROR:0 */
    if (g_bAtDataLocked != VOS_FALSE)
    {
        AT_NORM_LOG("AT_SetGTimerPara: data locked.");
        return AT_ERROR;
    }

    if (NV_OK !=  TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_GPRS_ActiveTimerLength,
                           &gastAtParaList[0].ulParaValue,
                           sizeof(gastAtParaList[0].ulParaValue)))
    {
         AT_WARN_LOG("AT_SetGTimerPara: Fail to write en_NV_Item_GPRS_ActiveTimerLength.");
         return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetQcdmgPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 该命令无输入参数 */
    if(gucAtParaIndex != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* ucIndex所对应的AT通道不是PCUI/UART通道 */
    if ((gastAtClientTab[ucIndex].ucPortNo != AT_USB_COM_PORT_NO)
     && (gastAtClientTab[ucIndex].ucPortNo != AT_UART_PORT_NO))
    {
        return AT_ERROR;
    }

    /*检查是否已有处于DIAG模式的通道*/
    if(At_CheckDataState(AT_DIAG_DATA_MODE) == AT_SUCCESS)
    {
        return AT_ERROR;
    }

    /*记录AT/DIAG通道所对应的索引号*/
    gucOmDiagIndex = ucIndex;

    /* 通知OAM切换至DIAG模式，OAM已经没有 */

    /*将通道模式设置为DIAG模式*/
    At_SetMode(gucOmDiagIndex, AT_DATA_MODE, AT_DIAG_DATA_MODE);

    return AT_OK;
}



TAF_UINT32 At_SetU2DiagPara(TAF_UINT8 ucIndex)
{
    AT_USB_ENUM_STATUS_STRU             stUsbEnumStatus;

    nv_pid_enable_type                  stPidEnableType;


    memset_s(&stUsbEnumStatus, sizeof(stUsbEnumStatus), 0x00, sizeof(stUsbEnumStatus));

    stPidEnableType.ulPidEnabled = VOS_FALSE;

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_PID_Enable_Type,
                        &stPidEnableType,
                        sizeof(nv_pid_enable_type)))
    {
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若使能，返回ERROR */
    if (stPidEnableType.ulPidEnabled != VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 参数有效性检查 */
    if (DRV_U2DIAG_VALUE_CHECK(gastAtParaList[0].ulParaValue) != VOS_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充stUsbEnumStatus结构体 */
    memset_s(&stUsbEnumStatus, sizeof(stUsbEnumStatus), 0x00, sizeof(AT_USB_ENUM_STATUS_STRU));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_USB_Enum_Status, &stUsbEnumStatus, sizeof(AT_USB_ENUM_STATUS_STRU)) == NV_OK)
    {
        if ( (gastAtParaList[0].ulParaValue == stUsbEnumStatus.ulValue)
            && (stUsbEnumStatus.ulStatus == 1))
        {
            AT_INFO_LOG("At_SetU2DiagPara():The content to write is same as NV's");
            return AT_OK;
        }
    }

    stUsbEnumStatus.ulStatus = 1;
    stUsbEnumStatus.ulValue  = gastAtParaList[0].ulParaValue;

    /* 写入NVIM */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_USB_Enum_Status,
                           &stUsbEnumStatus,
                           sizeof(AT_USB_ENUM_STATUS_STRU)))
    {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_BOOL At_FistScanSetPortPara(
    VOS_UINT16                          *pusSemiIndex,
    VOS_UINT8                           *pucInputString,
    VOS_UINT16                          usInputLen
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          j;
    VOS_UINT8                           ucSemiCount;
    VOS_UINT8                           aAvailableChar[] = {'0','1', '2', '3', '4',
                                                            '5', '6', '7', 'A',
                                                            'B', 'D', 'E', 'F',
                                                            ',', ';'};

    ucSemiCount = 0;

    for (i = 0; i < usInputLen; i++)
    {
        for (j = 0; j < (sizeof(aAvailableChar)/sizeof(VOS_UINT8)); j++)
        {
            if (*(pucInputString + i) == aAvailableChar[j])
            {
                if (*(pucInputString + i) == ';')
                {
                    ucSemiCount++;
                    *pusSemiIndex = (VOS_UINT16)i;

                    /* 有且只能有一个分号 */
                    if (ucSemiCount > 1)
                    {
                        AT_ERR_LOG("At_FistScanSetPortPara:The num of semi can only be one!");
                        return VOS_FALSE;
                    }
                }
                break;
            }
        }

        /* 不是合法字符 */
        if ((sizeof(aAvailableChar)/sizeof(VOS_UINT8)) == j)
        {
            AT_ERR_LOG("At_FistScanSetPortPara:Invalid character!");
            return VOS_FALSE;
        }
    }

    /* 有且只能有一个分号并且不是第一个字符也不是最后一个字符 */
    if (( *pusSemiIndex == 0 ) || ((usInputLen - 1) == *pusSemiIndex))
    {
        AT_ERR_LOG("At_FistScanSetPortPara:The position of semi isn't suitable!");
        return VOS_FALSE;
    }

    /* 第一个和最后一个字符为逗号 */
    if ((*pucInputString == ',') || (pucInputString[usInputLen - 1] == ','))
    {
        return VOS_FALSE;
    }

    return VOS_TRUE;
}


VOS_BOOL At_SecScanSetPortFirstPara(
    VOS_UINT16                          usSemiIndex,
    VOS_UINT8                           *pucFirstParaCount,
    VOS_UINT8                           *pucInputString,
    VOS_UINT16                          usInputLen
)
{
    VOS_UINT32                          i;
    VOS_UINT8                           ucCharCount;

    ucCharCount = 0;

    for (i = 0; i <= usSemiIndex; i++)
    {
        /* 逗号或者第一个参数的结尾 */
        if ((*(pucInputString + i) == ',') || (*(pucInputString + i) == ';'))
        {
            /* 参数之间多个逗号的情况A1,,,,A2;1,2 返回ERROR */
            /* 必须是两个字符A1,A2,FF */
            if (ucCharCount != 2)
            {
                AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid first parameter!");
                return VOS_FALSE;
            }

            /* LINT ERROR: ucCharCount = 2, i >= 2 */
            if ((i >= 2)
                && !(((pucInputString[i - 2] == 'A') && (pucInputString[i - 1] == '1'))
                    || ((pucInputString[i - 2] == 'A') && (pucInputString[i - 1] == '2'))
                    || ((pucInputString[i - 2] == 'F') && (pucInputString[i - 1] == 'F'))))

            {
                AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid first parameter!");
                return VOS_FALSE;
            }

            (*pucFirstParaCount)++;

            ucCharCount = 0;
        }
        else
        {
            ucCharCount++;
        }

        if (ucCharCount > 2)
        {
            AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid character!");
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}


VOS_BOOL At_SecScanSetPortSecPara(
    VOS_UINT16                          usSemiIndex,
    VOS_UINT8                           *pucSecParaCount,
    VOS_UINT8                           aucSecPara[AT_SETPORT_PARA_MAX_LEN][3],
    VOS_UINT8                           *pucInputString,
    VOS_UINT16                          usInputLen
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          i;
    VOS_UINT8                           ucCharCount;
    VOS_UINT8                           aucTmpInputString[AT_SETPORT_PARA_MAX_CHAR_LEN];
    VOS_UINT16                          usTmpInputStringLen;

    ucCharCount = 0;

    if (usInputLen > AT_SETPORT_PARA_MAX_CHAR_LEN)
    {
        return VOS_FALSE;
    }

    /*第二个参数结尾加上逗号便于以下参数检查*/
    usTmpInputStringLen = usInputLen - usSemiIndex;
    lMemResult = memcpy_s(aucTmpInputString, sizeof(aucTmpInputString), pucInputString + usSemiIndex + 1, (VOS_SIZE_T)(usTmpInputStringLen - 1));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucTmpInputString), (VOS_SIZE_T)(usTmpInputStringLen - 1));
    aucTmpInputString[usTmpInputStringLen - 1] = ',';

    for (i = 0; i < usTmpInputStringLen; i++)
    {
        if (*(aucTmpInputString + i) == ',')
        {
            /*参数之间多个逗号的情况A1,A2;1,,,2返回eror*/
            if (ucCharCount == 0)
            {
                AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
                return VOS_FALSE;
            }

            /* 如果是两个字符必须为A1,A2或16 */
            if (ucCharCount == 2)
            {
                /* LINT ERROR: ucCharCount = 2, i >= 2 */
                if ((i >= 2)
                    && !(((aucTmpInputString[i - 2] == 'A') && (aucTmpInputString[i - 1] == '1'))
                      || ((aucTmpInputString[i - 2] == 'A') && (aucTmpInputString[i - 1] == '2'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '6'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '0'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '1'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '2'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '3'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '4'))
                      || ((aucTmpInputString[i - 2] == '1') && (aucTmpInputString[i - 1] == '5'))
                 ))
                {
                    AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
                    return VOS_FALSE;
                }
            }

            /* 保存合法的参数 */
            if ((*pucSecParaCount) >= AT_SETPORT_PARA_MAX_LEN)
            {
                return VOS_FALSE;
            }

            lMemResult = memcpy_s(aucSecPara[*pucSecParaCount],
                                  ucCharCount,
                                  (aucTmpInputString + i) - ucCharCount,
                                  ucCharCount);
            TAF_MEM_CHK_RTN_VAL(lMemResult, ucCharCount, ucCharCount);

            (*pucSecParaCount)++;

            ucCharCount = 0;
        }
        else
        {
            ucCharCount++;
        }

        if (ucCharCount > 2)
        {
            AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}



VOS_BOOL At_SaveSetPortFirstPara(
    VOS_UINT8                           ucFirstParaCount,
    VOS_UINT8                           *pucFirstPort,
    VOS_UINT8                           *pucInputString
)
{
    /* 参数个数不符合要求 */
    if ((ucFirstParaCount != 1) && (ucFirstParaCount != 2))
    {
        return VOS_FALSE;
    }

    /* 只有一个参数: FF或者A1 */
    if (ucFirstParaCount == 1)
    {
        if ((*pucInputString == 'F') && (*(pucInputString + 1) == 'F'))
        {
            *pucFirstPort = 0xFF;
        }
        else if ((*pucInputString == 'A') && (*(pucInputString + 1) == '1'))
        {
            *pucFirstPort = 0xA1;
        }
        else
        {
            AT_ERR_LOG("At_SaveSetPortFirstPara:Invalid first parameter!");
            return VOS_FALSE;
        }
    }
    /* 两个参数: A1,A2 */
    else
    {
        if ((*pucInputString == 'A') && (pucInputString[1] == '1')
         && (pucInputString[3] == 'A') && (pucInputString[4] == '2'))
        {
            *pucFirstPort       = 0xA1;
            *(pucFirstPort + 1) = 0xA2;
        }
        else
        {
            AT_ERR_LOG("At_SaveSetPortFirstPara:Invalid first parameter!");
            return VOS_FALSE;
        }
    }
    return VOS_TRUE;
}



VOS_BOOL At_SaveSetPortSecPara(
    VOS_UINT8                           ucSecParaCount,
    VOS_UINT8                           *pucSecPort,
    VOS_UINT8                           aucSecPara[AT_SETPORT_PARA_MAX_LEN][3]
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          j;

    /* 参数个数不符合要求 */
    if ((ucSecParaCount == 0) || (ucSecParaCount > AT_SETPORT_PARA_MAX_LEN))
    {
        AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
        return VOS_FALSE;
    }

    /* 参数不能重复 */
    for (i = 0; i < (VOS_UINT8)(ucSecParaCount - 1); i++)
    {
        for (j = i + 1; j < ucSecParaCount; j++)
        {
            if (!VOS_MemCmp(aucSecPara[i], aucSecPara[j], 3))
            {
                AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
                return VOS_FALSE;
            }
        }
    }

    for (i = 0; i < ucSecParaCount; i++)
    {
        for (j = 0; j < AT_SETPORT_DEV_LEN; j++)
        {
            if (!VOS_MemCmp(aucSecPara[i], g_astSetPortParaMap[j].aucAtSetPara, 3))
            {
                pucSecPort[i] = g_astSetPortParaMap[j].ucDrvPara;
                break;
            }
        }

        /* 说明不是合法的设备形态，返回错误 */
        if (j >= AT_SETPORT_DEV_LEN)
        {
            AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
            return VOS_FALSE;
        }
    }
    return VOS_TRUE;
}


VOS_UINT32 AT_CheckPortTypePara(
    VOS_UINT8                           ucFirstParaCount,
    VOS_UINT8                          *pucFirstPort,
    VOS_UINT8                           ucSecParaCount,
    VOS_UINT8                          *pucSecPort
)
{
    VOS_UINT32                          ulRet;

    /* 切换前端口有效性检查:
    端口配置第一位必须为A1(CDROM),否则返回ERROR；
    第二位如果有，仅允许有A2(SD),否则返回ERROR；
    如果是直接上报多端口状态，分号前就直接是FF,否则返回ERROR。
    */
    if (ucFirstParaCount == 2)
    {
        if ((*(pucFirstPort) != AT_DEV_CDROM)
        || (*(pucFirstPort + 1) != AT_DEV_SD))
        {
            return VOS_FALSE;
        }

    }
    else if (ucFirstParaCount == 1)
    {
        if ((*(pucFirstPort) != AT_DEV_CDROM)
        && (*(pucFirstPort) != AT_DEV_NONE))
        {
            return VOS_FALSE;
        }

    }
    else
    {
        return VOS_FALSE;
    }

    /*
    切换后端口有效性检查:
        1.端口形态中必须有2(PCUI),否则返回ERROR；
        2.切换后端口必须是测试命令中输出的支持的端口，否则返回ERROR；
        3.不能设置有重复的端口，否则返回ERROR；
        4.MASS 不能设置到其他端口的前面，否则返回ERROR
        5.端口个数不能超过规定的个数,否则返回ERROR；
    */
    ulRet = (VOS_UINT32)DRV_USB_PORT_TYPE_VALID_CHECK(pucSecPort, ucSecParaCount);
    if (ulRet != VOS_OK)
    {
        return VOS_FALSE;
    }

    return VOS_TRUE;
}


VOS_BOOL At_IsAvailableSetPortPara(
    VOS_UINT8                           *pucInputString,
    VOS_UINT16                          usInputLen,
    VOS_UINT8                           *pucFirstPort,
    VOS_UINT8                           *pucSecPort
)
{
    /* 分号的位置 */
    VOS_UINT16                          usSemiIndex;
    VOS_UINT8                           ucFirstParaCount;
    VOS_UINT8                           ucSecParaCount;
    VOS_UINT8                           aucSecPara[AT_SETPORT_PARA_MAX_LEN][3];
    VOS_BOOL                            bScanResult;
    VOS_UINT32                          ulRet;
    errno_t                             lMemResult;

    usSemiIndex         = 0;
    ucFirstParaCount    = 0;
    ucSecParaCount      = 0;

    lMemResult = memset_s(aucSecPara, sizeof(aucSecPara), 0x00, AT_SETPORT_PARA_MAX_LEN * 3);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucSecPara), AT_SETPORT_PARA_MAX_LEN * 3);

    /* 第一轮扫描:是否有非法字符 */
    bScanResult = At_FistScanSetPortPara(&usSemiIndex, pucInputString, usInputLen);

    if (bScanResult != VOS_TRUE)
    {
        AT_ERR_LOG("At_IsAvailableSetPortPara:First parameter is invalid!");
        return VOS_FALSE;
    }

    /* 第二轮扫描:每个参数必须是A1,A2,FF,A,B,D,E,1,2,3,4,5,6,7 */
    /* 第一个参数 */
    bScanResult = At_SecScanSetPortFirstPara(usSemiIndex,
                                        &ucFirstParaCount,
                                        pucInputString,
                                        usInputLen);

    if (bScanResult != VOS_TRUE)
    {
        AT_ERR_LOG("At_IsAvailableSetPortPara:First parameter is invalid!");
        return VOS_FALSE;
    }

    /*第二个参数*/
    bScanResult = At_SecScanSetPortSecPara(usSemiIndex,
                                        &ucSecParaCount,
                                        aucSecPara,
                                        pucInputString,
                                        usInputLen);

    if (bScanResult != VOS_TRUE)
    {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Second parameter is invalid!");
        return VOS_FALSE;
    }

    /*保存第一个参数*/
    bScanResult = At_SaveSetPortFirstPara(ucFirstParaCount, pucFirstPort, pucInputString);

    if (bScanResult != VOS_TRUE)
    {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Save first parameter fail!");
        return VOS_FALSE;
    }

    /*保存第二个参数*/
    bScanResult = At_SaveSetPortSecPara(ucSecParaCount, pucSecPort, aucSecPara);

    if (bScanResult != VOS_TRUE)
    {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Save second parameter fail!");
        return VOS_FALSE;
    }

    ulRet = AT_CheckPortTypePara(ucFirstParaCount, pucFirstPort, ucSecParaCount, pucSecPort);

    return  ulRet;
}



VOS_UINT32 At_SetPort(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_BOOL                            bValidPara;
    VOS_UINT8                           aucFirstPort[AT_SETPORT_PARA_MAX_LEN];
    VOS_UINT8                           aucSecPort[AT_SETPORT_PARA_MAX_LEN];
    AT_DYNAMIC_PID_TYPE_STRU            stDynamicPidType;
    nv_pid_enable_type                  stPidEnableType;


    stPidEnableType.ulPidEnabled = VOS_FALSE;


    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    memset_s(aucFirstPort, sizeof(aucFirstPort), 0x00, AT_SETPORT_PARA_MAX_LEN);
    memset_s(aucSecPort, sizeof(aucSecPort), 0x00, AT_SETPORT_PARA_MAX_LEN);
    memset_s(&stDynamicPidType, sizeof(stDynamicPidType), 0x00, sizeof(AT_DYNAMIC_PID_TYPE_STRU));

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_PID_Enable_Type,
                         &stPidEnableType,
                         sizeof(nv_pid_enable_type)))
    {
        AT_ERR_LOG("At_SetPort:Read NV failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回ERROR */
    if (stPidEnableType.ulPidEnabled != VOS_TRUE)
    {
        AT_WARN_LOG("At_SetPort:PID is not enabled");
        return AT_ERROR;
    }

    /* 1.参数为空
       2.参数超过最大长度
       参数最大长度: 两个参数的长度加一个分号 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[0].usParaLen > ((AT_SETPORT_PARA_MAX_CHAR_LEN * 2) + 1)))
    {
        return AT_ERROR;
    }

    /* 该AT命令支持用户输入大小写，先将小写转成大写，再进行字符串的解析 */
    At_UpString(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);

    /* 参数解析 */
    bValidPara = At_IsAvailableSetPortPara(gastAtParaList[0].aucPara,
                                        gastAtParaList[0].usParaLen,
                                        aucFirstPort,
                                        aucSecPort);
    if (bValidPara == VOS_FALSE)
    {
        AT_WARN_LOG("At_SetPort:Parameter is invalid");
        return AT_ERROR;
    }

    /* 读NV失败，直接返回ERROR */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                        &stDynamicPidType,
                        sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_ERR_LOG("At_SetPort:Read NV fail!");
        return AT_ERROR;
    }

    /* 读NV成功，判断该NV的使能状态，若不使能，直接返回ERROR */
    if (stDynamicPidType.ulNvStatus == VOS_TRUE)
    {
        /* 判断要写入内容是否与NV中内容相同，如果相同不再写操作，直接返回OK */
        if(!(VOS_MemCmp(stDynamicPidType.aucFirstPortStyle, aucFirstPort, AT_SETPORT_PARA_MAX_LEN)))
        {
            if(!(VOS_MemCmp(stDynamicPidType.aucRewindPortStyle, aucSecPort, AT_SETPORT_PARA_MAX_LEN)))
            {
                AT_INFO_LOG("At_SetPort:Same, not need write");
                return AT_OK;
            }
        }
    }
    else
    {
        return AT_ERROR;
    }

    /* 此处增加DIAG口密码保护    */
    if (AT_CheckSetPortRight(stDynamicPidType.aucRewindPortStyle,
                             aucSecPort) != AT_OK)
    {
        return AT_ERROR;
    }

    lMemResult = memcpy_s(stDynamicPidType.aucFirstPortStyle, sizeof(stDynamicPidType.aucFirstPortStyle), aucFirstPort, AT_SETPORT_PARA_MAX_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stDynamicPidType.aucFirstPortStyle), AT_SETPORT_PARA_MAX_LEN);
    lMemResult = memcpy_s(stDynamicPidType.aucRewindPortStyle, sizeof(stDynamicPidType.aucRewindPortStyle), aucSecPort, AT_SETPORT_PARA_MAX_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stDynamicPidType.aucRewindPortStyle), AT_SETPORT_PARA_MAX_LEN);

    /* 写入NV */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                        &stDynamicPidType,
                        sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_ERR_LOG("At_SetPort:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}


VOS_UINT32 AT_OpenSpecificPort(VOS_UINT8 ucPort)
{
    AT_DYNAMIC_PID_TYPE_STRU            stDynamicPidType;
    VOS_UINT32                          ulPortPos;
    VOS_UINT32                          ulPortNum;


    memset_s(&stDynamicPidType, sizeof(stDynamicPidType), 0x00, sizeof(stDynamicPidType));

    ulPortPos = AT_DEV_NONE;


    /* 读NV项en_NV_Item_Huawei_Dynamic_PID_Type获取当前的端口状态 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                        &stDynamicPidType,
                        sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_WARN_LOG("AT_OpenSpecificPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断端口是否已经打开: 已经打开则直接返回AT_OK */
    if (stDynamicPidType.ulNvStatus == VOS_TRUE)
    {
        /* 查询NV项en_NV_Item_Huawei_Dynamic_PID_Type中是否已经存在该端口 */
        AT_GetSpecificPort(ucPort,
                           stDynamicPidType.aucRewindPortStyle,
                           &ulPortPos,
                           &ulPortNum);

        if (ulPortPos != AT_DEV_NONE)
        {
            return AT_OK;
        }

    }
    else
    {
        AT_WARN_LOG("AT_OpenSpecificPort: en_NV_Item_Huawei_Dynamic_PID_Type is inactive!");
        return AT_ERROR;
    }

    /* 当前不能再增加端口 */
    if (ulPortNum >= AT_SETPORT_PARA_MAX_LEN)
    {
        return AT_ERROR;
    }

    stDynamicPidType.aucRewindPortStyle[ulPortNum] = ucPort;

    /* 更新端口集合数据到NV项en_NV_Item_Huawei_Dynamic_PID_Type */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                        &stDynamicPidType,
                        sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_ERR_LOG("AT_OpenSpecificPort: Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}


VOS_UINT32 AT_CloseSpecificPort(VOS_UINT8 ucPort)
{
    AT_DYNAMIC_PID_TYPE_STRU            stDynamicPidType;
    VOS_UINT32                          ulPortPos;
    VOS_UINT32                          ulPortNum;
    VOS_UINT32                          ulLoop;


    memset_s(&stDynamicPidType, sizeof(stDynamicPidType), 0x00, sizeof(stDynamicPidType));

    ulPortPos = AT_DEV_NONE;


    /* 读NV项en_NV_Item_Huawei_Dynamic_PID_Type获取当前的端口状态 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                          &stDynamicPidType,
                          sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_ERR_LOG("AT_CloseSpecificPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断该端口是否已经关闭: 已经关闭则直接返回AT_OK */
    if (stDynamicPidType.ulNvStatus == VOS_TRUE)
    {
        /* 查询NV项en_NV_Item_Huawei_Dynamic_PID_Type中是否已经存在该端口 */
        AT_GetSpecificPort(ucPort,
                           stDynamicPidType.aucRewindPortStyle,
                           &ulPortPos,
                           &ulPortNum);

        if (ulPortPos == AT_DEV_NONE)
        {
            return AT_OK;
        }
    }
    else
    {
        return AT_ERROR;
    }

    /* 删除NV项中的指定端口 */
    stDynamicPidType.aucRewindPortStyle[ulPortPos] = 0;
    ulPortNum--;

    for (ulLoop = ulPortPos; ulLoop < ulPortNum; ulLoop++)
    {
        stDynamicPidType.aucRewindPortStyle[ulLoop] = stDynamicPidType.aucRewindPortStyle[ulLoop + 1UL];
    }

    stDynamicPidType.aucRewindPortStyle[ulPortNum] = 0;

    /* 端口异常数据保护: 切换后的设备形态中，第一个设备不能为MASS设备(0xa1,0xa2) */
    if (ulPortNum != 0)
    {
        if ((stDynamicPidType.aucRewindPortStyle[0] == AT_DEV_CDROM)
         || (stDynamicPidType.aucRewindPortStyle[0] == AT_DEV_SD))
        {
            return AT_ERROR;
        }
    }

    /* 更新端口集合数据到NV项en_NV_Item_Huawei_Dynamic_PID_Type */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Huawei_Dynamic_PID_Type,
                          &stDynamicPidType,
                          sizeof(AT_DYNAMIC_PID_TYPE_STRU)))
    {
        AT_ERR_LOG("AT_CloseSpecificPort: Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}


TAF_UINT32 At_SetPcscInfo(TAF_UINT8 ucIndex)
{
    AT_DYNAMIC_PID_TYPE_STRU            stDynamicPidType;
    nv_pid_enable_type                  stPidEnableType;


    stPidEnableType.ulPidEnabled = VOS_FALSE;


    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    memset_s(&stDynamicPidType, sizeof(stDynamicPidType), 0x00, sizeof(AT_DYNAMIC_PID_TYPE_STRU));

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_PID_Enable_Type,
                         &stPidEnableType,
                         sizeof(nv_pid_enable_type)))
    {
        AT_ERR_LOG("At_SetPcscInfo:Read NV31 failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回ERROR */
    if (stPidEnableType.ulPidEnabled != VOS_TRUE)
    {
        AT_WARN_LOG("At_SetPcscInfo:PID is not enabled!");
        return AT_ERROR;
    }

    /*  打开PCSC口*/
    if ( gastAtParaList[0].ulParaValue == VOS_TRUE )
    {
        return AT_OpenSpecificPort(AT_DEV_PCSC);
    }
    /* 关闭PCSC口 */
    else
    {
        return AT_CloseSpecificPort(AT_DEV_PCSC);
    }
}


VOS_UINT32 At_SetCellSearch(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    VOS_UINT8                           ucCellSrh;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    ucCellSrh = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送消息 ID_AT_MTA_WRR_CELLSRH_SET_REQ 给 AT AGENT 处理，该消息带参数(VOS_UINT8)gastAtParaList[0].ulParaValue */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   ID_AT_MTA_WRR_CELLSRH_SET_REQ,
                                   (VOS_VOID*)&ucCellSrh,
                                   sizeof(ucCellSrh),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_WAS_MNTN_SET_CELLSRH;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}



TAF_UINT32 At_SetGetportmodePara (TAF_UINT8 ucIndex)
{
    TAF_PH_PORT_STRU     stPortInfo;
    TAF_PH_FMR_ID_STRU   stFmrID;
    TAF_UINT16           usDataLen;
    TAF_UINT32           ulRslt;
    TAF_UINT32           ulPortInfoLen;
    errno_t              lMemResult;

     /* 参数检查 */
    if ((g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (gastAtParaList[0].usParaLen == 0))
    {
        return AT_ERROR;
    }

    memset_s(&stPortInfo, sizeof(stPortInfo), 0x00, sizeof(TAF_PH_PORT_STRU));

    VOS_StrNCpy_s((VOS_CHAR *)stPortInfo.ProductName.aucProductName,
                 sizeof(stPortInfo.ProductName.aucProductName),
                 PRODUCTION_CARD_TYPE,
                 PRODUCTION_CARD_TYPE_MAX_LEN);

    memset_s(&stFmrID, sizeof(stFmrID), 0x00, sizeof(TAF_PH_FMR_ID_STRU));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_FMRID, &stFmrID, sizeof(TAF_PH_FMR_ID_STRU)) != NV_OK)
    {
        AT_WARN_LOG("At_SetMsIdInfo:WARNING:NVIM Read en_NV_Item_FMRID falied!");
        return AT_ERROR;
    }
    else
    {
        lMemResult = memcpy_s(stPortInfo.FmrId.aucMfrId, sizeof(stPortInfo.FmrId.aucMfrId), &stFmrID, sizeof(TAF_PH_FMR_ID_STRU));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPortInfo.FmrId.aucMfrId), sizeof(TAF_PH_FMR_ID_STRU));
    }

    ulPortInfoLen = TAF_MAX_PORT_INFO_LEN + 1;

    ulRslt = (VOS_UINT32)(DRV_GET_PORT_MODE((char *)stPortInfo.PortId.aucPortInfo, &ulPortInfoLen));
    if( ulRslt != VOS_OK )
    {
        AT_WARN_LOG("At_SetGetportmodePara:DRV_GET_PORT_MODE Info fail.");
        return AT_ERROR;
    }

    usDataLen =  (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR*)pgucAtSndCodeAddr, "%s: ",g_stParseContext[ucIndex].pstCmdElement->pszCmdName);
    usDataLen += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usDataLen, "%s: %s", "TYPE", stPortInfo.ProductName.aucProductName);
    usDataLen += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usDataLen, ": %s,",  stPortInfo.FmrId.aucMfrId);
    usDataLen += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usDataLen, "%s",  stPortInfo.PortId.aucPortInfo);

    gstAtSendData.usBufLen = usDataLen;
    return AT_OK;
}


VOS_UINT32   At_SetCvoicePara (VOS_UINT8 ucIndex)
{
    APP_VC_VOICE_MODE_ENUM_U16          usVoiceMode;


    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }


    /* 参数过多 */
    if(gucAtParaIndex != 1)
    {
        return AT_ERROR;
    }

    /* 目前只支持PC VOICE模式 */
    usVoiceMode = (APP_VC_VOICE_MODE_ENUM_U16)gastAtParaList[0].ulParaValue;

    if (usVoiceMode != APP_VC_VOICE_MODE_PCVOICE)
    {
        return AT_ERROR;
    }

    /* 返回值为AT_SUCCESS改为VOS_OK，对应起来  */
    if (APP_VC_SetVoiceMode(gastAtClientTab[ucIndex].usClientId,
                            0,
                            (VOS_UINT8)APP_VC_AppVcVoiceMode2VcPhyVoiceMode(usVoiceMode),
                            I0_WUEPS_PID_VC) == VOS_OK)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CVOICE_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }


}


VOS_UINT32 At_SetDdsetexPara (VOS_UINT8 ucIndex)
{
    APP_VC_VOICE_PORT_ENUM_U8           ucVoicePort;


    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 目前只支持DIAG */
    ucVoicePort = (APP_VC_VOICE_PORT_ENUM_U8)gastAtParaList[0].ulParaValue;

    if (ucVoicePort != APP_VC_VOICE_PORT_DIAG)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (APP_VC_SetVoicePort(gastAtClientTab[ucIndex].usClientId,
                            0,
                            ucVoicePort) == VOS_OK)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DDSETEX_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}


TAF_UINT32 At_SetCmsrPara (TAF_UINT8 ucIndex)
{
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].ulParaValue != 0)&&( gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数设置 */
    pstSmsCtx->ucParaCmsr = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    return AT_OK;
}


TAF_UINT32 At_SetCmgiPara (TAF_UINT8 ucIndex)
{
    MN_MSG_STATUS_TYPE_ENUM_U8          enMsgStatus;
    MN_MSG_LIST_PARM_STRU               stListPara;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    memset_s(&stListPara, sizeof(MN_MSG_LIST_PARM_STRU), 0x00, sizeof(MN_MSG_LIST_PARM_STRU));

    /* 参数检查 */
    if (gucAtParaIndex > 1)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<stat> */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }
    else
    {
        enMsgStatus = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    stListPara.bChangeFlag = VOS_FALSE;
    stListPara.enMemStore  = pstSmsCtx->stCpmsInfo.enMemReadorDelete;
    stListPara.enStatus    = enMsgStatus;
    memset_s(stListPara.aucReserve1, sizeof(stListPara.aucReserve1), 0x00, sizeof(stListPara.aucReserve1));

    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_Delete_Test(gastAtClientTab[ucIndex].usClientId,
                           gastAtClientTab[ucIndex].opId,
                           &stListPara) == MN_ERR_NO_ERROR)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMGI_SET;
        g_stParseContext[ucIndex].ucClientStatus = AT_FW_CLIENT_STATUS_PEND;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCmmtPara (TAF_UINT8 ucIndex)
{
    MN_MSG_MODIFY_STATUS_PARM_STRU               stModifyParm;
    AT_MODEM_SMS_CTX_STRU              *pstSmsCtx = VOS_NULL_PTR;

    pstSmsCtx = AT_GetModemSmsCtxAddrFromClientId(ucIndex);

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
          return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数检查 */
    if ((g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&stModifyParm, sizeof(stModifyParm), 0x00, sizeof(stModifyParm));

    stModifyParm.ulIndex = gastAtParaList[0].ulParaValue;

    /* 设置<stat> */
    if (gastAtParaList[1].ulParaValue == 0)
    {
        stModifyParm.enStatus = MN_MSG_STATUS_MT_NOT_READ;
    }
    else
    {
        stModifyParm.enStatus = MN_MSG_STATUS_MT_READ;
    }

    /* 设置读取存储器 */
    stModifyParm.enMemStore = pstSmsCtx->stCpmsInfo.enMemReadorDelete;

     /* 执行命令操作 */
    gastAtClientTab[ucIndex].opId = At_GetOpId();
    if (MN_MSG_ModifyStatus(gastAtClientTab[ucIndex].usClientId,
                            gastAtClientTab[ucIndex].opId,
                            &stModifyParm) == MN_ERR_NO_ERROR)

    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMMT_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetUssdModePara(TAF_UINT8 ucIndex)
{
    USSD_TRANS_MODE_STRU                stUssdTranMode;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值检查, 必须为 0/1 */
    if ((gastAtParaList[0].ulParaValue != 1) && (gastAtParaList[0].ulParaValue != 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新全局变量 */
    pstSsCtx                        = AT_GetModemSsCtxAddrFromClientId(ucIndex);
    pstSsCtx->usUssdTransMode       = (VOS_UINT16)gastAtParaList[0].ulParaValue;

    stUssdTranMode.ucStatus         = VOS_TRUE;
    stUssdTranMode.ucUssdTransMode  = (VOS_UINT8)pstSsCtx->usUssdTransMode;

    /* 设置完拨号模式后，给C核发送消息 */
    if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               gastAtClientTab[ucIndex].opId,
                               TAF_MSG_SET_USSDMODE_MSG,
                               &stUssdTranMode,
                               sizeof(USSD_TRANS_MODE_STRU),
                               I0_WUEPS_PID_TAF) != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetAdcTempPara(TAF_UINT8 ucIndex)
{
    SPY_TEMP_THRESHOLD_PARA_STRU stTempPara;
    VOS_UINT32                   ulChangeFlag = AT_SPY_TEMP_THRESHOLD_PARA_UNCHANGE;
    VOS_UINT32                   ulRet;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 4)
    {
        return AT_TOO_MANY_PARA;
    }

    /*全设为无效值*/
    memset_s(&stTempPara, sizeof(stTempPara), 0xFF, sizeof(stTempPara));


    if(gastAtParaList[0].usParaLen != 0)
    {
        stTempPara.ulIsEnable   = gastAtParaList[0].ulParaValue;
        ulChangeFlag = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if(gastAtParaList[1].usParaLen != 0)
    {
        stTempPara.lCloseAdcThreshold = (VOS_INT)gastAtParaList[1].ulParaValue;
        ulChangeFlag = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if(gastAtParaList[2].usParaLen != 0)
    {
        stTempPara.lAlarmAdcThreshold = (VOS_INT)gastAtParaList[2].ulParaValue;
        ulChangeFlag = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if(gastAtParaList[3].usParaLen != 0)
    {
        stTempPara.lResumeAdcThreshold = (VOS_INT)gastAtParaList[3].ulParaValue;
        ulChangeFlag = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if(ulChangeFlag == AT_SPY_TEMP_THRESHOLD_PARA_CHANGE)
    {
        /*调用接口设置门限值*/
        /* 发消息到C核设置 热保护温度状态  */
        ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                       gastAtClientTab[ucIndex].opId,
                                       DRV_AGENT_ADC_SET_REQ,
                                       &stTempPara,
                                       sizeof(stTempPara),
                                       I0_WUEPS_PID_DRV_AGENT);
        if (ulRet != TAF_SUCCESS)
        {
            AT_WARN_LOG("At_SetAdcTempPara: AT_FillAndSndAppReqMsg fail.");
            return AT_ERROR;
        }

        /* 设置AT模块实体的状态为等待异步返回 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ADC_SET;
        return AT_WAIT_ASYNC_RETURN;

    }

    return AT_OK;
}


TAF_UINT32 AT_SetDwinsPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulEnabled;
    WINS_CONFIG_STRU                    stWins;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    ulEnabled = gastAtParaList[0].ulParaValue;
    /* 填充stWins结构体 */
    memset_s(&stWins, sizeof(stWins), 0x00, sizeof(WINS_CONFIG_STRU));

    if ( TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WINS_Config, &stWins, sizeof(WINS_CONFIG_STRU)) == NV_OK )
    {
        if ( (stWins.ucStatus == 1) && (ulEnabled == stWins.ucWins) )
        {
            AT_INFO_LOG("AT_SetDwinsPara():The content to write is same as NV's");

            /* 更新PPP的WINS设置 */
            PPP_UpdateWinsConfig((VOS_UINT8)gastAtParaList[0].ulParaValue);

            /* 更新APS的WINS设置 */
            TAF_PS_ConfigNbnsFunction(WUEPS_PID_AT,
                                      AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                      0,
                                      ulEnabled);

            return AT_OK;
        }
    }

    stWins.ucStatus = 1;
    stWins.ucWins   = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 写入NVIM */
    if ( TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_WINS_Config, &stWins, sizeof(WINS_CONFIG_STRU)) != NV_OK )
    {
        return AT_ERROR;
    }
    else
    {
        /* 更新PPP的WINS设置 */
        PPP_UpdateWinsConfig((VOS_UINT8)gastAtParaList[0].ulParaValue);

        /* 更新APS的WINS设置 */
        TAF_PS_ConfigNbnsFunction(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  0,
                                  ulEnabled);

        return AT_OK;
    }
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

LOCAL TAF_UINT32 At_ProcCommDebugParaActUsimCard(VOS_VOID)
{
    USIMM_ACTIVECARD_REQ_STRU          *pstMsg       = VOS_NULL_PTR;

    pstMsg = (USIMM_ACTIVECARD_REQ_STRU *)VOS_AllocMsg(WUEPS_PID_AT, sizeof(USIMM_ACTIVECARD_REQ_STRU) - VOS_MSG_HEAD_LENGTH);

    if(pstMsg == VOS_NULL_PTR)
    {
        LogPrint("At_ProcCommDebugParaActUsimCard:AllocMsg Failed.");

        return VOS_ERR;
    }

    pstMsg->stMsgHeader.ulReceiverPid      = WUEPS_PID_USIM;
    pstMsg->stMsgHeader.enMsgName          = USIMM_ACTIVECARD_REQ;

    if (VOS_SendMsg(WUEPS_PID_AT, pstMsg) != VOS_OK)
    {
        LogPrint("At_ProcCommDebugParaActUsimCard:sndmsg Failed.");
    }

    return AT_OK;
}



TAF_UINT32 At_SetCommDebugPara(TAF_UINT8 ucIndex)
{
    SPY_TEMP_THRESHOLD_PARA_STRU        stTempPara;
    TAF_AT_NVIM_COMMDEGBUG_CFG_STRU     stDebugFlag;
    VOS_UINT16                          usFlag;

#if ( VOS_WIN32 == VOS_OS_VER )
    VOS_UINT8                           aucFilelist[]={0x6f,0x43};
#endif

    stDebugFlag.ulCommDebugFlag = VOS_FALSE;

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /*全设为无效值*/
    memset_s(&stTempPara, sizeof(stTempPara), 0xFF, sizeof(stTempPara));


    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch(gastAtParaList[0].ulParaValue)
    {
        case 0x00:
            /*去激活所有Debug功能*/
            if(TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG, &(stDebugFlag.ulCommDebugFlag), sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
            {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag0 Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if(stDebugFlag.ulCommDebugFlag != 0x00)
            {
                stDebugFlag.ulCommDebugFlag = 0x00;

                if(TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG,&(stDebugFlag.ulCommDebugFlag),sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
                {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag0 Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }

            }

            break;
        case 0x01:
            /*使能DRX定位信息上报功能*/
            if(TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG, &(stDebugFlag.ulCommDebugFlag), sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
            {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if((stDebugFlag.ulCommDebugFlag&0x01) != 0x01)
            {
                stDebugFlag.ulCommDebugFlag |= 0x01;

                if(TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG,&(stDebugFlag.ulCommDebugFlag),sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
                {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }

            }

            break;
        case 0x03:
            /*使能USIMM初始化信息记录功能*/
            if(TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG, &(stDebugFlag.ulCommDebugFlag), sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
            {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag2 Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if((stDebugFlag.ulCommDebugFlag&0x02) != 0x02)
            {
                stDebugFlag.ulCommDebugFlag |= 0x02;

                if(TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_COMMDEGBUG_CFG,&(stDebugFlag.ulCommDebugFlag),sizeof(TAF_AT_NVIM_COMMDEGBUG_CFG_STRU)) != NV_OK)
                {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag2 Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }

            }

            break;

        case 0x05:

            usFlag = 1;

            if(TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Usim_Debug_Mode_Set, &usFlag, sizeof(VOS_UINT16)) != NV_OK)
            {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Usim Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            break;

        case 0x06:

            usFlag = 0;

            if(TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Usim_Debug_Mode_Set, &usFlag, sizeof(VOS_UINT16)) != NV_OK)
            {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Usim Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            break;

        case 0x07:
            /* 拆圈 */
            return At_ProcCommDebugParaActUsimCard();


        default:
            break;
    }

    return AT_OK;
}


TAF_UINT32 At_SetYjcxPara (TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_YJCX_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if(ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_YJCX_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetPhyInitPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_PHY_INIT_REQ_STRU            stPhyInit;

    /* 结构体重置 */
    memset_s(&stPhyInit, sizeof(stPhyInit), 0x00, sizeof(AT_MTA_PHY_INIT_REQ_STRU));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 0)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 向MTA发送消息通知物理层初始化 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   ID_AT_MTA_PHY_INIT_REQ,
                                   (VOS_VOID*)(&stPhyInit),
                                   sizeof(stPhyInit),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PHYINIT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32 AT_SetDockPara (VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucClientIndex;
    VOS_UINT16                          usLength;

    usLength = 0;

    if (gastAtClientTab[ucIndex].UserType != AT_APP_USER )
    {
        return AT_FAILURE;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_FAILURE;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_FAILURE;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_FAILURE;
    }

    memset_s(gastAtParaList[0].aucPara + gastAtParaList[0].usParaLen,
             (VOS_SIZE_T)(AT_PARA_MAX_LEN - gastAtParaList[0].usParaLen),
             0x00,
             (VOS_SIZE_T)(AT_PARA_MAX_LEN - gastAtParaList[0].usParaLen));

    for (ucClientIndex = 0 ; ucClientIndex < AT_MAX_CLIENT_NUM; ucClientIndex++)
    {
        if (gastAtClientTab[ucClientIndex].UserType == AT_USBCOM_USER)
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                        (VOS_CHAR *)pgucAtSndCodeAddr,
                                        (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                        "%s%s%s",
                                        gaucAtCrLf,
                                        gastAtParaList[0].aucPara,
                                        gaucAtCrLf);
            At_SendResultData(ucClientIndex, pgucAtSndCodeAddr, usLength);
            break;
        }
    }

    return AT_SUCCESS;
}
#endif


TAF_UINT32 At_SetAt2OmPara(TAF_UINT8 ucIndex)
{
    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 该命令无输入参数 */
    if(gucAtParaIndex != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*ucIndex所对应的AT通道不是AT/OM通道*/
    if ( (gastAtClientTab[ucIndex].ucPortNo != AT_USB_COM_PORT_NO)
      && (gastAtClientTab[ucIndex].ucPortNo != AT_UART_PORT_NO)
      && (gastAtClientTab[ucIndex].ucPortNo != AT_CTR_PORT_NO)
      && (gastAtClientTab[ucIndex].ucPortNo != AT_PCUI2_PORT_NO)
      && (gastAtClientTab[ucIndex].ucPortNo != AT_HSUART_PORT_NO))
    {
        return AT_ERROR;
    }

    /*检查是否已有处于OM模式的AT通道*/
    if(At_CheckDataState(AT_OM_DATA_MODE) == AT_SUCCESS)
    {
        return AT_ERROR;
    }

    /*记录AT/OM通道所对应的索引号*/
    gucAtOmIndex = ucIndex;

    /* 通知OAM切换至OM模式 */
    if (gastAtClientTab[ucIndex].ucPortNo == AT_USB_COM_PORT_NO)
    {
        CBTCPM_NotifyChangePort(AT_PCUI_PORT);
    }
    else if (gastAtClientTab[ucIndex].ucPortNo == AT_UART_PORT_NO)
    {
        CBTCPM_NotifyChangePort(AT_UART_PORT);
    }

    else if (gastAtClientTab[ucIndex].ucPortNo == AT_HSUART_PORT_NO)
    {
        CBTCPM_NotifyChangePort(AT_HSUART_PORT);
    }
    else
    {
    }

    /*将通道模式设置为OM模式*/
    At_SetMode(gucAtOmIndex, AT_DATA_MODE, AT_OM_DATA_MODE);

    return AT_OK;
}


TAF_UINT32 AT_ResumeOm2AtMode(TAF_VOID)
{
    /*检查是否已有处于OM模式的通道*/
    if(At_CheckDataState(AT_OM_DATA_MODE) != AT_SUCCESS)
    {
        return VOS_ERR;
    }

    At_SetMode(gucAtOmIndex,AT_CMD_MODE,AT_NORMAL_MODE);   /* 返回命令模式 */
    return VOS_OK;
}

VOS_UINT32 AT_GetOperatorNameFromParam(
    VOS_UINT16                         *usOperNameLen,
    VOS_CHAR                           *pucOperName,
    VOS_UINT16                          usBufSize,
    VOS_UINT32                          ulFormatType
)
{
    errno_t                             lMemResult;
    if ((ulFormatType == AT_COPS_LONG_ALPH_TYPE)
     && (usBufSize > gastAtParaList[2].usParaLen)
     && (gastAtParaList[2].usParaLen != 0))
    {
        lMemResult = memcpy_s((VOS_CHAR*)pucOperName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_PH_OPER_NAME_LONG, gastAtParaList[2].usParaLen);
        pucOperName[gastAtParaList[2].usParaLen] = 0;
        *usOperNameLen = gastAtParaList[2].usParaLen;

        return AT_OK;
    }
    else if ((ulFormatType == AT_COPS_SHORT_ALPH_TYPE)
          && (usBufSize > gastAtParaList[2].usParaLen)
          && (gastAtParaList[2].usParaLen != 0))
    {
        lMemResult = memcpy_s((VOS_CHAR*)pucOperName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_PH_OPER_NAME_LONG, gastAtParaList[2].usParaLen);
        pucOperName[gastAtParaList[2].usParaLen] = 0;
        *usOperNameLen = gastAtParaList[2].usParaLen;

        return AT_OK;
    }
    else if ((usBufSize > gastAtParaList[2].usParaLen)
          && ((gastAtParaList[2].usParaLen == 5)
           || (gastAtParaList[2].usParaLen == 6)))
    {
        lMemResult = memcpy_s((VOS_CHAR*)pucOperName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR*)gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_PH_OPER_NAME_LONG, gastAtParaList[2].usParaLen);
        pucOperName[gastAtParaList[2].usParaLen] = 0;
        *usOperNameLen = gastAtParaList[2].usParaLen;

        return AT_OK;
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
}

VOS_UINT32 At_SetCpolPara(VOS_UINT8 ucIndex)
{
    TAF_PH_SET_PREFPLMN_STRU            stPrefPlmn;
    VOS_UINT32                          ulRst;
    AT_MODEM_NET_CTX_STRU              *pstNetCtx = VOS_NULL_PTR;

    pstNetCtx = AT_GetModemNetCtxAddrFromClientId(ucIndex);

    memset_s(&stPrefPlmn,sizeof(stPrefPlmn), 0x00,sizeof(stPrefPlmn));

    /* 参数过多 */
#if (FEATURE_UE_MODE_NR == FEATURE_ON) && (FEATURE_LTE == FEATURE_ON)
    if ( gucAtParaIndex > 8 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#elif (FEATURE_LTE == FEATURE_ON) || (FEATURE_UE_MODE_NR == FEATURE_ON)
    if ( gucAtParaIndex > 7 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#else
    if ( gucAtParaIndex > 6 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    if ( (gucAtParaIndex == 2)
      && (gastAtParaList[0].usParaLen == 0)
      && (gastAtParaList[1].usParaLen != 0))
    {
        /* 当前只存在<format>，如果当前对应的<oper>能够获取，则读取命令中<oper>
           的format需要改变 */
        pstNetCtx->ucCpolFormatType = (AT_COPS_FORMAT_TYPE)gastAtParaList[1].ulParaValue;
        return AT_OK;
    }

    if (pstNetCtx->enPrefPlmnType > MN_PH_PREF_PLMN_HPLMN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*保存参数到结构中，发送给MMA进行处理*/
    stPrefPlmn.enPrefPlmnType           = pstNetCtx->enPrefPlmnType;
    stPrefPlmn.ucAtParaIndex            = gucAtParaIndex;
    stPrefPlmn.usIndexLen               = gastAtParaList[0].usParaLen;
    stPrefPlmn.usIndex                  = gastAtParaList[0].ulParaValue;
    stPrefPlmn.usFormatLen              = gastAtParaList[1].usParaLen;
    stPrefPlmn.usFormat                 = gastAtParaList[1].ulParaValue;
    stPrefPlmn.usGsmRatLen              = gastAtParaList[3].usParaLen;
    stPrefPlmn.usGsmRat                 = gastAtParaList[3].ulParaValue;
    stPrefPlmn.usGsmCompactRatLen       = gastAtParaList[4].usParaLen;
    stPrefPlmn.usGsmCompactRat          = gastAtParaList[4].ulParaValue;
    stPrefPlmn.usUtrnLen                = gastAtParaList[5].usParaLen;
    stPrefPlmn.usUtrn                   = gastAtParaList[5].ulParaValue;

#if (FEATURE_UE_MODE_NR == FEATURE_ON) && (FEATURE_LTE == FEATURE_ON)
    stPrefPlmn.usEutrnLen               = gastAtParaList[6].usParaLen;
    stPrefPlmn.usEutrn                  = gastAtParaList[6].ulParaValue;
    stPrefPlmn.usNrRatLen               = gastAtParaList[7].usParaLen;
    stPrefPlmn.ulNrRat                  = gastAtParaList[7].ulParaValue;
#elif (FEATURE_LTE == FEATURE_ON)
    /* LTE的接入技术以及长度 */
    stPrefPlmn.usEutrnLen               = gastAtParaList[6].usParaLen;
    stPrefPlmn.usEutrn                  = gastAtParaList[6].ulParaValue;
#elif (FEATURE_UE_MODE_NR == FEATURE_ON)
    stPrefPlmn.usNrRatLen               = gastAtParaList[6].usParaLen;
    stPrefPlmn.ulNrRat                  = gastAtParaList[6].ulParaValue;
#else
#endif

    if (stPrefPlmn.usFormatLen == 0)
    {
        stPrefPlmn.usFormatLen = 1;
        stPrefPlmn.usFormat = AT_COPS_NUMERIC_TYPE;
    }

    pstNetCtx->ucCpolFormatType = (AT_COPS_FORMAT_TYPE)stPrefPlmn.usFormat;

    if (gastAtParaList[2].usParaLen != 0)
    {
        ulRst = AT_GetOperatorNameFromParam(&stPrefPlmn.usOperNameLen,
                                             stPrefPlmn.ucOperName,
                                             sizeof(stPrefPlmn.ucOperName),
                                             stPrefPlmn.usFormat);
        if (ulRst != AT_OK)
        {
            return ulRst;
        }
    }

    if (TAF_MMA_SetCpolReq(WUEPS_PID_AT,
                           gastAtClientTab[ucIndex].usClientId,
                           0,
                           &stPrefPlmn) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPOL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}

VOS_UINT32 At_SetCplsPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                           ulRst;
    MN_PH_PREF_PLMN_TYPE_ENUM_U8         enPrefPlmnType;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        enPrefPlmnType = (MN_PH_PREF_PLMN_TYPE_ENUM_U8)gastAtParaList[0].ulParaValue;
    }
    else
    {
        enPrefPlmnType = MN_PH_PREF_PLMN_UPLMN;
    }

    if (enPrefPlmnType > MN_PH_PREF_PLMN_HPLMN)
    {
        return AT_CME_OPERATION_NOT_SUPPORTED;
    }

    /* 发送消息 ID_TAF_MMA_PREF_PLMN_TYPE_SET_REQ 给 MMA 处理 */
    ulRst = TAF_MMA_SetPrefPlmnTypeReq(WUEPS_PID_AT,
                                       gastAtClientTab[ucIndex].usClientId,
                                       gastAtClientTab[ucIndex].opId,
                                       &enPrefPlmnType); /*要求设置的优先网络类型*/

    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MMA_SET_PREF_PLMN_TYPE;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}

TAF_UINT32 At_SetpidPara(TAF_UINT8 ucIndex)
{
    TAF_UINT32           ulRslt;
    TAF_UINT8            diagValue;

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值检查, 必须为 0/1 */
    if ((gastAtParaList[0].ulParaValue != 1) && (gastAtParaList[0].ulParaValue != 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    diagValue = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    ulRslt = (VOS_UINT32)(DRV_SET_PID(diagValue));
    if( ulRslt != VOS_OK )
    {
        AT_WARN_LOG("At_SetpidPara:Setpid fail.");
        return AT_ERROR;
    }

    return AT_OK;

  }


VOS_UINT32 AT_SetOpwordParaForApModem ( VOS_UINT8  ucIndex )
{
    return AT_OK;
}


VOS_UINT32 AT_SetOpwordPara ( VOS_UINT8  ucIndex )
{
    VOS_UINT32                              ulCheckRlst = VOS_FALSE;
    VOS_UINT8                              *pucSystemAppConfig = VOS_NULL_PTR;
    VOS_UINT32                              ulResult;

    /* 读取NV项中当前产品形态 */
    pucSystemAppConfig = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /* 已经具有权限  直接返回OK */
    if (g_enATE5RightFlag == AT_E5_RIGHT_FLAG_YES)
    {
        return AT_OK;
    }

    /* 若当前设备的形态为AP-MODEM */
    if ( *pucSystemAppConfig == SYSTEM_APP_ANDROID)
    {
        ulResult = AT_SetOpwordParaForApModem(ucIndex);
        return ulResult;
    }

    /* 输入密码超长 */
    if ( gastAtParaList[0].usParaLen > AT_DISLOG_PWD_LEN )
    {
        return AT_ERROR;
    }

    /* 密码比较 */
    if (VOS_StrLen((VOS_CHAR *)g_acATOpwordPwd) == 0)
    {
        /* NV中密码为空则输入任何密码都能获取权限 */
        ulCheckRlst = VOS_TRUE;
    }
    else
    {
        if (VOS_StrCmp((VOS_CHAR*)g_acATOpwordPwd, (VOS_CHAR*)gastAtParaList[0].aucPara) == 0)
        {
            ulCheckRlst = VOS_TRUE;
        }
    }

    if ( ulCheckRlst == VOS_FALSE )
    {
        return AT_ERROR;
    }

    /* 密码比对成功  获取权限 */
    g_enATE5RightFlag = AT_E5_RIGHT_FLAG_YES;

    /* 按D25的做法  不保存权限标志 */

    return AT_OK;
}


VOS_UINT32 AT_SetCpwordPara ( VOS_UINT8  ucIndex )
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*已经不具有权限*/
    if (g_enATE5RightFlag == AT_E5_RIGHT_FLAG_NO )
    {
        return AT_OK;
    }

    /* 释放权限 */
    g_enATE5RightFlag = AT_E5_RIGHT_FLAG_NO;

    /* 按D25的做法  不保存权限标志 */

    return AT_OK;
}


VOS_UINT32 AT_SetDislogPara ( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRet;
    nv_pid_enable_type                  stPidEnableType;

#if (FEATURE_LTE == FEATURE_ON)
    VOS_UINT32                          ulRetDiag;
    VOS_UINT32                          ulRet3GDiag;
    VOS_UINT32                          ulRetGps;
#endif


    stPidEnableType.ulPidEnabled = VOS_FALSE;


    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) || (gucAtParaIndex > 1))
    {
        return AT_ERROR;
    }

    /* 切换PCUI口到DIAG服务 */
    if ( gastAtParaList[0].ulParaValue == AT_DISLOG_PCUI_TO_DIAG )
    {
        /* ucIndex所对应的AT通道不是PCUI/UART通道 */
        if ((gastAtClientTab[ucIndex].ucPortNo != AT_USB_COM_PORT_NO)
         && (gastAtClientTab[ucIndex].ucPortNo != AT_UART_PORT_NO))
        {
            return AT_ERROR;
        }

        /*检查是否已有处于DIAG模式的通道*/
        if(At_CheckDataState(AT_DIAG_DATA_MODE) == AT_SUCCESS)
        {
            return AT_ERROR;
        }

        /*记录AT/DIAG通道所对应的索引号*/
        gucOmDiagIndex = ucIndex;

        /* 通知OAM切换至DIAG模式，OAM已经没有DIAG，代码注释掉 */

        /*将通道模式设置为DIAG模式*/
        At_SetMode(gucOmDiagIndex, AT_DATA_MODE, AT_DIAG_DATA_MODE);

        return AT_OK;
    }

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_PID_Enable_Type,
                        &stPidEnableType,
                        sizeof(nv_pid_enable_type)))
    {
        AT_ERR_LOG("AT_SetDislogPara:Read NV failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回AT_OK */
    if (stPidEnableType.ulPidEnabled != VOS_TRUE)
    {
        AT_WARN_LOG("AT_SetDislogPara:PID is not enabled");
        return AT_OK;
    }


    /*  打开DIAG口*/
    if ( gastAtParaList[0].ulParaValue == AT_DISLOG_DIAG_OPEN )
    {
#if (FEATURE_LTE == FEATURE_ON)
        ulRet3GDiag   = AT_OpenSpecificPort(AT_DEV_DIAG);
        ulRetDiag     = AT_OpenSpecificPort(AT_DEV_4G_DIAG);
        ulRetGps      = AT_OpenSpecificPort(AT_DEV_4G_GPS);

        if((ulRetDiag == AT_OK) && (ulRetGps == AT_OK) && (ulRet3GDiag == AT_OK))
        {
            ulRet = AT_OK;
        }
        else
        {
            ulRet = AT_ERROR;
        }
#else
        ulRet = AT_OpenDiagPort();
#endif
        return ulRet;
    }

    /* 关闭DIAG口 */
    if ( gastAtParaList[0].ulParaValue == AT_DISLOG_DIAG_CLOSE )
    {
#if (FEATURE_LTE == FEATURE_ON)
        ulRet3GDiag = AT_CloseSpecificPort(AT_DEV_DIAG);
        ulRetDiag   = AT_CloseSpecificPort(AT_DEV_4G_DIAG);
        ulRetGps    = AT_CloseSpecificPort(AT_DEV_4G_GPS);

        if((ulRetDiag == AT_OK) && (ulRetGps == AT_OK) && (ulRet3GDiag == AT_OK))
        {
            ulRet = AT_OK;
        }
        else
        {
            ulRet = AT_ERROR;
        }

#else
        ulRet = AT_CloseDiagPort();
#endif
        return ulRet;
    }


    return AT_ERROR;

}
#if (FEATURE_SECURITY_SHELL == FEATURE_ON)

VOS_UINT32 AT_SetSpwordPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          i;
    DRV_AGENT_SPWORD_SET_REQ_STRU       stSpwordSetReq;

    /* 如果超过三次，则在系统重新启动前不再处理该命令，直接返回Error */
    if (g_stSpWordCtx.ucErrTimes >= AT_SHELL_PWD_VERIFY_MAX_TIMES)
    {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Verify Max Times!");
        return AT_ERROR;
    }

    /* 一旦AT^SPWORD命令校验成功，系统不再对用户以后输入的AT^SPWORD命令进行处理，直接返回ERROR */
    if (g_stSpWordCtx.ucShellPwdCheckFlag == VOS_TRUE)
    {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Not need Verified!");
        return AT_ERROR;
    }

    /* 有且仅有一个参数，参数长度为8 */
    if ((gucAtParaIndex > 1)
     || (gastAtParaList[0].usParaLen != AT_SHELL_PWD_LEN))
    {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Parameter error!");
        return AT_ERROR;
    }

    /* 参数只能为字符0-9 */
    for (i = 0; i < AT_SHELL_PWD_LEN; i++)
    {
        if ((gastAtParaList[0].aucPara[i] < '0')
         || (gastAtParaList[0].aucPara[i] > '9'))
        {
            AT_WARN_LOG("AT_SetSpwordPara:WARNING: PWD NOT 0-9!");
            return AT_ERROR;
        }
    }

    /* 密码校验需要在C核实现 */
    lMemResult = memcpy_s(stSpwordSetReq.acShellPwd, (VOS_SIZE_T)sizeof(stSpwordSetReq.acShellPwd), (VOS_CHAR *)gastAtParaList[0].aucPara, AT_SHELL_PWD_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_SIZE_T)sizeof(stSpwordSetReq.acShellPwd), AT_SHELL_PWD_LEN);

    if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               gastAtClientTab[ucIndex].opId,
                               DRV_AGENT_SPWORD_SET_REQ,
                               &stSpwordSetReq,
                               sizeof(stSpwordSetReq),
                               I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SPWORD_SET;             /*设置当前操作模式 */
        return AT_WAIT_ASYNC_RETURN;                                            /* 等待异步事件返回 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetShellPara ( VOS_UINT8 ucIndex )
{
    AT_SHELL_OPEN_FLAG_ENUM_U32         enTmpOpenFlag;

    /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /*  WIFI使用SHELL口 */
    if (gastAtParaList[0].ulParaValue == AT_SHELL_WIFI_USE)
    {
        /* 保存WIFI使用SHELL结果到NV项 */
        enTmpOpenFlag = AT_SHELL_OPEN_FLAG_WIFI;
        if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, &enTmpOpenFlag,
                              sizeof(enTmpOpenFlag)))
        {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");
            return AT_ERROR;
        }

        return AT_OK;
    }

    /*  打开SHELL口 */
    if (gastAtParaList[0].ulParaValue == AT_SHELL_OPEN )
    {
        /* 判断CK是否校验通过 */
        if (g_stSpWordCtx.ucShellPwdCheckFlag != VOS_TRUE)
        {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");

            return AT_ERROR;
        }

        /* 保存打开结果到NV项 */
        enTmpOpenFlag = AT_SHELL_OPEN_FLAG_OPEN;
        if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, &enTmpOpenFlag,
                              sizeof(enTmpOpenFlag)))
        {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");

            return AT_ERROR;
        }

        return AT_OK;
    }

    /*关闭SHELL口*/
    if ( gastAtParaList[0].ulParaValue == AT_SHELL_CLOSE )
    {
        /* 保存当前SHELL口的关闭状态到NV项 */
        enTmpOpenFlag = AT_SHELL_OPEN_FLAG_CLOSE;
        if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, &enTmpOpenFlag,
                              sizeof(enTmpOpenFlag)))
        {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");
            return AT_ERROR;
        }

        return AT_OK;
    }

    return AT_ERROR;
}
#endif

#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetRsrpCfgPara ( VOS_UINT8 ucIndex )
{

    NVIM_RSRP_CFG_STRU stRsrpCfg;
    VOS_UINT32 RsrpLevel;

    memset_s(&stRsrpCfg, sizeof(stRsrpCfg), 0x00, sizeof(stRsrpCfg));

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[1].usParaLen == 0)
        || (gucAtParaIndex != 2))
    {
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, EN_NV_ID_RSRP_CFG, &stRsrpCfg,
                          sizeof(stRsrpCfg)))
    {
        PS_PRINTF_WARNING("<AT_SetRsrpCfgPara> WARNING:TAF_ACORE_NV_READ RSRP faild!\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    RsrpLevel = gastAtParaList[0].ulParaValue;
    stRsrpCfg.ssLevel[RsrpLevel] = (VOS_INT16)(gastAtParaList[0].ulParaValue);
    stRsrpCfg.ssValue[RsrpLevel] = (VOS_INT16)(gastAtParaList[1].ulParaValue);
    if(g_enATE5RightFlag == AT_E5_RIGHT_FLAG_YES)
    {
        if(NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, EN_NV_ID_RSRP_CFG, &stRsrpCfg,
                          sizeof(stRsrpCfg)))
        {
            PS_PRINTF_WARNING("<AT_SetRsrpCfgPara> WARNING:TAF_ACORE_NV_WRITE RSRP faild!\n");
            return AT_ERROR;
        }
    }
    else
    {
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif

#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetRscpCfgPara ( VOS_UINT8 ucIndex )
{
    NVIM_RSCP_CFG_STRU stRscpCfg;
    VOS_UINT32 RscpLevel;

    memset_s(&stRscpCfg, sizeof(stRscpCfg), 0x00, sizeof(stRscpCfg));

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[1].usParaLen == 0)
        || (gucAtParaIndex != 2))
    {
        PS_PRINTF_WARNING("RSCP para error\n");
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, EN_NV_ID_RSCP_CFG, &stRscpCfg,
                          sizeof(stRscpCfg)))
    {
        PS_PRINTF_WARNING("RSCP read error!\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    RscpLevel = gastAtParaList[0].ulParaValue;
    stRscpCfg.ssLevel[RscpLevel] = (VOS_INT16)(gastAtParaList[0].ulParaValue);
    stRscpCfg.ssValue[RscpLevel] = (VOS_INT16)(gastAtParaList[1].ulParaValue);
    if(g_enATE5RightFlag == AT_E5_RIGHT_FLAG_YES)
    {
        if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, EN_NV_ID_RSCP_CFG, &stRscpCfg,
                          sizeof(stRscpCfg)))
        {
            PS_PRINTF_WARNING("RSCP NV write error\n");
            return AT_ERROR;
        }
    }
    else
    {
        PS_PRINTF_WARNING("RSCP write limit\n");
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif
#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetEcioCfgPara ( VOS_UINT8 ucIndex )
{
    NVIM_ECIO_CFG_STRU stEcioCfg;
    VOS_UINT32 EcioLevel;

    memset_s(&stEcioCfg, sizeof(stEcioCfg), 0x00, sizeof(stEcioCfg));

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[1].usParaLen == 0)
        || (gucAtParaIndex != 2))
    {
        PS_PRINTF_WARNING("ECIO para error\n");
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, EN_NV_ID_ECIO_CFG, &stEcioCfg,
                          sizeof(stEcioCfg)))
    {
        PS_PRINTF_WARNING("ECIO read error\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    EcioLevel = gastAtParaList[0].ulParaValue;
    stEcioCfg.ssLevel[EcioLevel] = (VOS_INT16)(gastAtParaList[0].ulParaValue);
    stEcioCfg.ssValue[EcioLevel] = (VOS_INT16)(gastAtParaList[1].ulParaValue);
    if(g_enATE5RightFlag == AT_E5_RIGHT_FLAG_YES)
    {
        if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, EN_NV_ID_ECIO_CFG, &stEcioCfg,
                          sizeof(stEcioCfg)))
        {
            PS_PRINTF_WARNING("ECIO write error\n");
            return AT_ERROR;
        }
    }
    else
    {
        PS_PRINTF_WARNING("ECIO write limit\n");
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif




#if (FEATURE_DSDS == FEATURE_ON)

VOS_UINT32 At_SetPsProtectModePara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_RRC_PROTECT_PS_REQ_STRU      stPsProtectSetPara;

    /* 结构体重置 */
   memset_s(&stPsProtectSetPara, sizeof(stPsProtectSetPara), 0x00, sizeof(AT_MTA_RRC_PROTECT_PS_REQ_STRU));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stPsProtectSetPara.enPsProtectFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 向MTA发送消息通知PS PROTECT */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   ID_AT_MTA_RRC_PROTECT_PS_REQ,
                                   (VOS_VOID*)(&stPsProtectSetPara),
                                   sizeof(stPsProtectSetPara),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PSPROTECTMODE_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif



VOS_UINT32 AT_SetWifiGlobalMacPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    VOS_UINT8                           aucE5GwMacAddr[AT_MAC_ADDR_LEN+1]; /* MAC地址*/

    if (gucAtParaIndex != 1)
    {
        AT_NORM_LOG("AT_SetApMacPara: the number of parameters is error.");
        return AT_ERROR;
    }

    if (gastAtParaList[0].usParaLen > AT_MAC_ADDR_LEN )
    {
        return AT_ERROR;
    }

    memset_s(aucE5GwMacAddr, sizeof(aucE5GwMacAddr), 0x00, sizeof(aucE5GwMacAddr));

    /* 写MAC地址参数到NV */
    VOS_StrNCpy_s( (VOS_CHAR *)aucE5GwMacAddr, sizeof(aucE5GwMacAddr), (VOS_CHAR *)gastAtParaList[0].aucPara,
                gastAtParaList[0].usParaLen );


    ulRet = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_WIFI_MAC_ADDR, aucE5GwMacAddr, AT_MAC_ADDR_LEN);

    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_SetApMacPara: Fail to write nv.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCsqlvlPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                              ulResult;

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_CSQLVL_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);
    if (ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSQLVL_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCsqlvlPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

}


VOS_UINT32  AT_SetCsqlvlExtPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                              ulResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_CSQLVL_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);

    if (ulResult == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSQLVLEXT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCsqlvlExtPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetApbatlvlPara( VOS_UINT8 ucIndex )
{
    BATT_STATE_S                        stBatLvl;
    VOS_UINT32                          ucChargeState;


    if (mdrv_misc_support_check(BSP_MODULE_TYPE_CHARGE) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }

    /*Arguments found, return error.*/
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        PS_PRINTF_WARNING("AT^APBATLVL arguments found, return error!!\n ");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 调用接口获取充电情况 */
    if ( mdrv_misc_get_battery_state( &stBatLvl ) != VOS_OK )
    {
        return AT_ERROR;
    }

    /* 区分充电和未充电状态 */
    if ( (stBatLvl.charging_state == CHARGING_UP)
      || (stBatLvl.charging_state == CHARGING_DOWN) )
    {
        ucChargeState = 1;
    }
    else if ( (stBatLvl.charging_state == NO_CHARGING_UP)
           || (stBatLvl.charging_state == NO_CHARGING_DOWN) )
    {
        ucChargeState = 0;
    }
    else
    {
        return AT_ERROR;
    }

    /* 过滤电池电量错误值 */
    if ( (stBatLvl.battery_level < BATT_LOW_POWER)
       ||(stBatLvl.battery_level >= BATT_LEVEL_MAX))
    {
        return AT_ERROR;
    }

    gstAtSendData.usBufLen = (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                    (TAF_CHAR*)pgucAtSndCodeAddr,
                                                    (TAF_CHAR*)pgucAtSndCodeAddr,
                                                    "%s:%d,%d",
                                                    g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                                    ucChargeState,
                                                    stBatLvl.battery_level);

    return AT_OK;
}


VOS_UINT32 AT_SetOpenportPara( VOS_UINT8 ucIndex )
{
    /* 能在这里处理OPENPORT, 要么是已经有权限了再输入OPENPORT,直接返回OK
       要么是没开启密码保护, 也直接返回OK */
    return AT_OK;
}
#endif


VOS_UINT32 AT_CheckIpv6Capability(
    VOS_UINT8                           ucPdpType
)
{
    switch (AT_GetIpv6Capability())
    {
        case AT_IPV6_CAPABILITY_IPV4_ONLY:
            /* IPv4 only只能发起IPv4的PDP激活 */
            if (ucPdpType != TAF_PDP_IPV4)
            {
                AT_ERR_LOG("AT_CheckIpv6Capablity: Only IPv4 is supported!");
                return VOS_ERR;
            }
            break;

        case AT_IPV6_CAPABILITY_IPV6_ONLY:
            /* IPv6 only只能发起IPv6的PDP激活 */
            if (ucPdpType != TAF_PDP_IPV6)
            {
                AT_ERR_LOG("AT_CheckIpv6Capablity: Only IPv6 is supported!");
                return VOS_ERR;
            }
            break;

        default:
            break;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetNdisdupPara (VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRslt;
    TAF_IFACE_USER_TYPE_ENUM_U8         enUserType;

    enUserType = AT_PS_GetUserType(ucIndex);

    if (enUserType == TAF_IFACE_USER_TYPE_BUTT)
    {
        /*在V2版本中，其它端口下输入该命令，直接返回OK*/
        AT_ERR_LOG("AT_SetNdisdupPara: User Type is Butt!");
        return AT_OK;
    }

    /* 检查参数有效性 */
    ulRslt = AT_PS_ValidateDialParam(ucIndex, enUserType);

    if (ulRslt != AT_SUCCESS)
    {
        /* 记录PS域呼叫错误码 */
        AT_PS_SetPsCallErrCause(ucIndex, TAF_PS_CAUSE_INVALID_PARAMETER);

        return ulRslt;
    }

    return AT_PS_ProcIfaceCmd(ucIndex, enUserType);
}


TAF_UINT32 At_SetAuthdataPara (TAF_UINT8 ucIndex)
{
    TAF_AUTHDATA_EXT_STRU               stAuthDataInfo;
    errno_t                             lMemResult;

    memset_s(&stAuthDataInfo, sizeof(stAuthDataInfo), 0x00, sizeof(TAF_AUTHDATA_EXT_STRU));

    /* 若无参数，则直接返回OK */
    if ( g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA )
    {
        return AT_OK;
    }

    /* 参数检查 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 5 )
    {
        return AT_TOO_MANY_PARA;
    }

    stAuthDataInfo.ucCid                    = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if ( gucAtParaIndex == 1 )
    {
        stAuthDataInfo.ucDefined            = VOS_FALSE;
    }
    else
    {
        stAuthDataInfo.ucDefined            = VOS_TRUE;

        /* 设置<Auth_type> */
        if ( gastAtParaList[1].usParaLen != 0 )
        {
            stAuthDataInfo.bitOpAuthType    = VOS_TRUE;
            stAuthDataInfo.enAuthType       = (VOS_UINT8)gastAtParaList[1].ulParaValue;
        }

        /* 设置<PLMN> */
        if ( gastAtParaList[2].usParaLen > TAF_MAX_AUTHDATA_PLMN_LEN )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if ( gastAtParaList[2].usParaLen != 0 )
        {
            stAuthDataInfo.bitOpPlmn        = VOS_TRUE;

            lMemResult = memcpy_s((VOS_CHAR*)stAuthDataInfo.aucPlmn,
                                  sizeof(stAuthDataInfo.aucPlmn),
                                  (VOS_CHAR*)gastAtParaList[2].aucPara,
                                  gastAtParaList[2].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthDataInfo.aucPlmn), gastAtParaList[2].usParaLen);
            stAuthDataInfo.aucPlmn[gastAtParaList[2].usParaLen] = 0;
        }

        /* 设置<username> */
        if ( gastAtParaList[4].usParaLen > TAF_MAX_AUTHDATA_USERNAME_LEN )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if(gastAtParaList[4].usParaLen != 0)
        {
            stAuthDataInfo.bitOpUserName    = VOS_TRUE;

            lMemResult = memcpy_s((VOS_CHAR*)stAuthDataInfo.aucUserName,
                                  sizeof(stAuthDataInfo.aucUserName),
                                  (VOS_CHAR*)gastAtParaList[4].aucPara,
                                  gastAtParaList[4].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthDataInfo.aucUserName), gastAtParaList[4].usParaLen);
            stAuthDataInfo.aucUserName[gastAtParaList[4].usParaLen] = 0;
        }

        /* 设置<passwd> */
        if ( gastAtParaList[3].usParaLen > TAF_MAX_AUTHDATA_PASSWORD_LEN )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if ( gastAtParaList[3].usParaLen != 0 )
        {
            stAuthDataInfo.bitOpPassWord    = VOS_TRUE;

            lMemResult = memcpy_s((VOS_CHAR*)stAuthDataInfo.aucPassWord,
                                  sizeof(stAuthDataInfo.aucPassWord),
                                  (VOS_CHAR*)gastAtParaList[3].aucPara,
                                  gastAtParaList[3].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthDataInfo.aucPassWord), gastAtParaList[3].usParaLen);
            stAuthDataInfo.aucPassWord[gastAtParaList[3].usParaLen] = 0;
        }

    }

    /* 执行命令操作 */
    if ( TAF_PS_SetAuthDataInfo(WUEPS_PID_AT,
                                AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                0,
                                &stAuthDataInfo) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_AUTHDATA_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}



TAF_UINT32 At_SetCrpnPara (TAF_UINT8 ucIndex)
{
    TAF_MMA_CRPN_QRY_PARA_STRU          stMnMmaCrpnQry;
    errno_t                             lMemResult;

    /* 参数有效性检查 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_OK;
    }

    if (gucAtParaIndex != 2)
    {
        AT_WARN_LOG("At_SetCrpnPara: gucAtParaIndex != 2.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 若<name_index>或<name>参数为空，则返回失败 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查<name>参数长度有效性 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        if (gastAtParaList[1].usParaLen >= TAF_PH_OPER_NAME_LONG)
        {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    }
    else if(gastAtParaList[0].ulParaValue == 1)
    {
        if (gastAtParaList[1].usParaLen >= TAF_PH_OPER_NAME_SHORT)
        {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    }
    else
    {
        if ((gastAtParaList[1].usParaLen < 5) || (gastAtParaList[1].usParaLen > 6))
        {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    }


    memset_s(&stMnMmaCrpnQry, sizeof(stMnMmaCrpnQry), 0x00, sizeof(TAF_MMA_CRPN_QRY_PARA_STRU));

    /* 发送消息结构赋值 */
    stMnMmaCrpnQry.ucCurrIndex   = 0;
    stMnMmaCrpnQry.ucQryNum      = TAF_PH_CRPN_PLMN_MAX_NUM;
    stMnMmaCrpnQry.ucPlmnType    = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stMnMmaCrpnQry.usPlmnNameLen = gastAtParaList[1].usParaLen;
    lMemResult = memcpy_s(stMnMmaCrpnQry.aucPlmnName, sizeof(stMnMmaCrpnQry.aucPlmnName), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stMnMmaCrpnQry.aucPlmnName), gastAtParaList[1].usParaLen);



    if (TAF_MMA_QryCrpnReq( WUEPS_PID_AT,
                            gastAtClientTab[ucIndex].usClientId,
                            0,
                            &stMnMmaCrpnQry) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CRPN_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32  AT_SetAlsPara( TAF_UINT8 ucIndex )
{
    VOS_UINT32                          ulRet;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_SET_ALS_PARAM_STRU          stSetAls;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stSetAls, sizeof(stSetAls), 0x00, sizeof(stSetAls));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 参数过多 */
    if ( gucAtParaIndex > 2 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*第一个参数不存在*/
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( gastAtParaList[1].usParaLen != 0 )
    {
        stSetAls.enAlsLine = (MN_CALL_ALS_LINE_NO_ENUM_U8)gastAtParaList[1].ulParaValue;

        if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
        {
            return AT_ERROR;
        }

        ulRet = TAF_CCM_CallCommonReq(&stCtrl,
                                      &stSetAls,
                                      ID_TAF_CCM_SET_ALS_REQ,
                                      sizeof(stSetAls),
                                      enModemId);
        if (ulRet != VOS_OK)
        {
            return AT_ERROR;
        }

        pstSsCtx->ucSalsType = (TAF_UINT8)gastAtParaList[0].ulParaValue;

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_APP_SET_ALS_REQ;

        return AT_WAIT_ASYNC_RETURN;
    }

    pstSsCtx->ucSalsType = (TAF_UINT8)gastAtParaList[0].ulParaValue;

    return AT_OK;
}


VOS_UINT32 At_CheckRxDivOrRxPriCmdPara(VOS_VOID)
{
    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_RX_DIV_OTHER_ERR;
    }
    /* 参数不全，直接返回失败 */
    if (   (gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[1].usParaLen == 0)
        || (gastAtParaList[1].usParaLen > 18))
    {
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    /* 目前支持WCDMA，如果是其它值，直接返回失败 */
    if (gastAtParaList[0].aucPara[0] != '0')
    {
         return AT_CME_RX_DIV_OTHER_ERR;
    }

    return AT_OK;
}


VOS_UINT32 At_GetUserSetRxDivOrRxPriParaNum(
                VOS_UINT32      *pulSetDivLowBands,
                VOS_UINT32      *pulSetDivHighBands
)
{
    VOS_UINT32                      ulResult1;
    VOS_UINT32                      ulResult2;
    VOS_UINT8                      *pucInputPara = VOS_NULL_PTR;
    VOS_UINT16                      usInputLen;

    ulResult1 = AT_OK;
    ulResult2 = AT_OK;

    *pulSetDivLowBands  = 0;
    *pulSetDivHighBands = 0;

    /* 设置接收分集参数可以有两种格式:带0x和不带0x.
       如果格式是0x时，当0x后面不带其它参数，认为参数错误 */
    pucInputPara = gastAtParaList[1].aucPara;
    usInputLen   = gastAtParaList[1].usParaLen;
    if (   (gastAtParaList[1].aucPara[0] == '0')
        && (gastAtParaList[1].aucPara[1] == 'X'))
    {
        if (gastAtParaList[1].usParaLen < 3)
        {
            return AT_CME_RX_DIV_OTHER_ERR;
        }

        pucInputPara = &(gastAtParaList[1].aucPara[2]);
        usInputLen   = (VOS_UINT8)(gastAtParaList[1].usParaLen - 2);
    }

    if (usInputLen > 16)
    {
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    /* AT在前面解析时，转换成了ASCII码，此时需要转换成数字 */
    if (usInputLen <= 8)
    {
        ulResult1 = At_String2Hex(pucInputPara,
                        usInputLen, pulSetDivLowBands);
    }
    else
    {
        ulResult1 = At_String2Hex(pucInputPara,
                            usInputLen-8,pulSetDivHighBands);
        ulResult2 = At_String2Hex(pucInputPara + (usInputLen - 8),
                            8,pulSetDivLowBands);
    }
    if ((ulResult1 == AT_FAILURE) || (ulResult2 == AT_FAILURE))
    {
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    return AT_OK;
}


VOS_UINT32 At_CovertUserSetRxDivOrRxPriParaToMsInternal(
    VOS_UINT32 ulSetDivLowBands,
    VOS_UINT32 ulSetDivHighBands,
    VOS_UINT16 *pusSetDivBands
)
{
    VOS_UINT32                      ulMsCapaDivLowBands;
    VOS_UINT32                      ulMsCapaDivHighBands;

    *pusSetDivBands      = 0;

    /*用户设置的接收分集格式如下:
        0x80000            GSM850
        0x300              GSM900
        0x80               DCS1800
        0x200000           PCS1900
        0x400000           WCDMA2100
        0x800000           WCDMA1900
        0x1000000          WCDMA1800
        0x2000000          WCDMA_AWS
        0x4000000          WCDMA850
        0x2000000000000    WCDMA900
        0x4000000000000    WCDMA1700
      而MS支持的接收分集格式如下:
        2100M/ bit1  1900M/bit2  1800M/bit3  1700M/bit4  1600M/bit5
        1500M/bit6   900M/bit7   850M/bit8   800M/bit9   450M/bit10
      需要把用户设置的接收分集转换成MS支持的格式
    */
    ulMsCapaDivLowBands  = TAF_PH_BAND_WCDMA_I_IMT_2100
                         | TAF_PH_BAND_WCDMA_II_PCS_1900
                         | TAF_PH_BAND_WCDMA_III_1800
                         | TAF_PH_BAND_WCDMA_V_850;
    ulMsCapaDivHighBands = TAF_PH_BAND_WCDMA_IX_1700
                         | TAF_PH_BAND_WCDMA_VIII_900;
    if (   ((ulSetDivLowBands & (~ulMsCapaDivLowBands)) != 0)
        || ((ulSetDivHighBands & (~ulMsCapaDivHighBands)) != 0))
    {
        return AT_CME_RX_DIV_NOT_SUPPORTED;
    }
    if ((ulSetDivHighBands & TAF_PH_BAND_WCDMA_VIII_900) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_900;
    }
    if ((ulSetDivHighBands & TAF_PH_BAND_WCDMA_IX_1700) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_IX_1700;
    }
    if ((ulSetDivLowBands & TAF_PH_BAND_WCDMA_I_IMT_2100) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_2100;
    }
    if ((ulSetDivLowBands & TAF_PH_BAND_WCDMA_II_PCS_1900) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_1900;
    }
    if ((ulSetDivLowBands & TAF_PH_BAND_WCDMA_III_1800) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_1800;
    }
    if ((ulSetDivLowBands & TAF_PH_BAND_WCDMA_V_850) != 0)
    {
        *pusSetDivBands |= AT_MS_SUPPORT_RX_DIV_850;
    }

    return AT_OK;
}


VOS_UINT32 At_SaveRxDivPara(
        VOS_UINT16                      usSetDivBands,
        VOS_UINT8                       ucRxDivCfg
        )
{
    TAF_AT_NVIM_RXDIV_CONFIG_STRU       stRxdivConfig;

    memset_s(&stRxdivConfig, sizeof(stRxdivConfig), 0x00, sizeof(TAF_AT_NVIM_RXDIV_CONFIG_STRU));

    stRxdivConfig.ucVaild = ucRxDivCfg;

    /*NV项en_NV_Item_ANTENNA_CONFIG在V3R2B060后改成en_NV_Item_W_RF_DIV_BAND，
      两个NV项完全一样。*/
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_W_RF_DIV_BAND, &usSetDivBands, sizeof(VOS_UINT16)) != NV_OK)
    {
        TAF_LOG(WUEPS_PID_AT, 0, PS_LOG_LEVEL_ERROR,
                "TAF_ACORE_NV_WRITE en_NV_Item_W_RF_DIV_BAND fail!\n");
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_RXDIV_CONFIG, &stRxdivConfig, sizeof(TAF_AT_NVIM_RXDIV_CONFIG_STRU)) != NV_OK)
    {
        TAF_LOG(WUEPS_PID_AT, 0, PS_LOG_LEVEL_ERROR,
                "TAF_ACORE_NV_WRITE en_NV_RXDIV_CONFIG fail!\n");
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    return AT_OK;
}


TAF_UINT32  At_SetTModePara(TAF_UINT8 ucIndex )
{
    TAF_PH_TMODE_ENUM_UINT8            *pucCurrentTMode = VOS_NULL_PTR;

    TAF_MMA_PHONE_MODE_PARA_STRU        stPhoneModePara;
    VOS_UINT8                           ucUpdateFlag;

    #if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    pucCurrentTMode = &g_stAtDevCmdCtrl.ucCurrentTMode;
    #else
    pucCurrentTMode = &g_stMtInfoCtx.enCurrentTMode;
    #endif


    memset_s(&stPhoneModePara, sizeof(stPhoneModePara), 0x00, sizeof(stPhoneModePara));


    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置TMODE */
    if (gastAtParaList[0].ulParaValue >= AT_TMODE_BUTT )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch (gastAtParaList[0].ulParaValue)
    {
        case AT_TMODE_NORMAL :

            stPhoneModePara.PhMode = TAF_PH_MODE_FULL;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stPhoneModePara) == VOS_TRUE)
            {
                /* 设置当前操作类型 */
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SET_TMODE;

                #if (FEATURE_UE_MODE_NR == FEATURE_OFF)
                memset_s(&g_stAtDevCmdCtrl, sizeof(g_stAtDevCmdCtrl), 0x00, sizeof(g_stAtDevCmdCtrl));
                #else
                memset_s(&g_stMtInfoCtx, sizeof(g_stMtInfoCtx), 0x00, sizeof(g_stMtInfoCtx));
                #endif

                *pucCurrentTMode = AT_TMODE_NORMAL;

                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        case AT_TMODE_FTM :

            if (*pucCurrentTMode == AT_TMODE_UPGRADE)
            {
                return AT_ERROR;
            }

            stPhoneModePara.PhMode = TAF_PH_MODE_FT;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stPhoneModePara) == VOS_TRUE)
            {
                /* 设置当前操作类型 */
                *pucCurrentTMode = AT_TMODE_FTM;
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SET_TMODE;
                return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
            }
            else
            {
                return AT_ERROR;
            }
        case AT_TMODE_UPGRADE :

            if (*pucCurrentTMode == AT_TMODE_FTM)
            {
                return AT_ERROR;
            }
            /* 发消息到 C 核设置升级标志位，不需要再启定时器，消息类型为DRV_AGENT_TMODE_SET_REQ
               直接返回AT_OK，不需要等待设置结果 */
            ucUpdateFlag = VOS_TRUE;

            if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_TMODE_SET_REQ,
                                   &ucUpdateFlag,
                                   sizeof(ucUpdateFlag),
                                   I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS)
            {
                AT_ERR_LOG("AT_SetPstandbyPara: AT_FillAndSndAppReqMsg fail.");
            }

            *pucCurrentTMode = AT_TMODE_UPGRADE;
            return AT_OK;
        case AT_TMODE_RESET :

            *pucCurrentTMode = AT_TMODE_RESET;

            /* 单板重启 */
            ucUpdateFlag = VOS_FALSE;

            if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_TMODE_SET_REQ,
                                   &ucUpdateFlag,
                                   sizeof(ucUpdateFlag),
                                   I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS)
            {
                AT_ERR_LOG("AT_SetPstandbyPara: AT_FillAndSndAppReqMsg fail.");
            }

            return AT_OK;
        case AT_TMODE_POWEROFF:
                return AT_SetTmodeAutoPowerOff(ucIndex);

           /* 按北京要求模式4->11和模式1做相同的处理 */
        case AT_TMODE_SIGNALING :
               if (*pucCurrentTMode == AT_TMODE_UPGRADE)
               {
                   return AT_ERROR;
               }

           stPhoneModePara.PhMode = TAF_PH_MODE_FT;

           if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stPhoneModePara) == VOS_TRUE)
           {
               /* 设置当前操作类型 */
               *pucCurrentTMode = AT_TMODE_SIGNALING;
               gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SET_TMODE;
               return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
           }
           else
           {
               return AT_ERROR;
           }

           /* 按北京要求模式5->12和模式0做相同的处理 */
        case AT_TMODE_OFFLINE :

           stPhoneModePara.PhMode = TAF_PH_MODE_FULL;

           if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, &stPhoneModePara) == VOS_TRUE)
           {
               /* 设置当前操作类型 */
               gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SET_TMODE;

                #if (FEATURE_UE_MODE_NR == FEATURE_OFF)
                memset_s(&g_stAtDevCmdCtrl, sizeof(g_stAtDevCmdCtrl), 0x00, sizeof(g_stAtDevCmdCtrl));
                #else
                memset_s(&g_stMtInfoCtx, sizeof(g_stMtInfoCtx), 0x00, sizeof(g_stMtInfoCtx));
                #endif

                *pucCurrentTMode = AT_TMODE_OFFLINE;

               return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
           }
           else
           {
               return AT_ERROR;
           }

#if((FEATURE_LTE == FEATURE_ON) || (FEATURE_UE_MODE_TDS == FEATURE_ON))
        case AT_TMODE_F_NONESIGNAL:
        case AT_TMODE_SYN_NONESIGNAL:
        case AT_TMODE_SET_SLAVE:
        case AT_TMODE_GU_BT:
        case AT_TMODE_TDS_FAST_CT:
        case AT_TMODE_TDS_BT:
        case AT_TMODE_COMM_CT:
            if(atSetTmodePara(ucIndex, gastAtParaList[0].ulParaValue) == AT_OK)
            {
                gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SET_TMODE;
                *pucCurrentTMode = (VOS_UINT8)gastAtParaList[0].ulParaValue;
                return AT_WAIT_ASYNC_RETURN;
            }
            else
            {
                return AT_ERROR;
            }
#endif

        default:
            break;
    }


    return AT_ERROR;
}

#if (FEATURE_LTEV == FEATURE_ON)

TAF_UINT32  At_SetVModePara(VOS_UINT8 ucIndex )
{
    AT_MTA_VMODE_SET_REQ_STRU           stPhoneVModePara = {0};
    VOS_UINT32                          ulRst;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数必须为2 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[1].ulParaValue == 0)
    {
        stPhoneVModePara.enMode = AT_MTA_VMODE_POWEROFF;
    }
    else if(gastAtParaList[1].ulParaValue == 1)
    {
        stPhoneVModePara.enMode = AT_MTA_VMODE_POWERON;
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_VMODE_SET_REQ,
                                   &stPhoneVModePara,
                                   sizeof(AT_MTA_VMODE_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (TAF_SUCCESS == ulRst)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VMODE_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
#endif


#if (FEATURE_LTE == FEATURE_ON)
#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)
VOS_UINT32 At_SetSfm(VOS_UINT8 ucIndex)
{
    OM_SW_VER_FLAG_STRU  stCustomVersion;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    if(gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    /* AT命令与NV中存储的信息相反 */
    if(gastAtParaList[0].ulParaValue == 0)
    {
        stCustomVersion.ulNvSwVerFlag = 1;    /* 1 表示正式版本 */
    }
    else
    {
        stCustomVersion.ulNvSwVerFlag = 0;    /* 0 表示烧片版本 */
    }

    /* 判断是否为烧片版本 */
    if ( TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_SW_VERSION_FLAG, &stCustomVersion.ulNvSwVerFlag, sizeof(stCustomVersion.ulNvSwVerFlag)) != VOS_OK )
    {
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}
#endif


VOS_UINT32 AT_SetFrStatus(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_SET_FR_REQ_STRU              stAtMtaSetFrReq;
    PS_BOOL_ENUM_UINT8                  enActFrFlag;

    /* 局部变量初始化 */
    ulRst                             = TAF_FAILURE;
    enActFrFlag                       = PS_BOOL_BUTT;
    memset_s(&stAtMtaSetFrReq, sizeof(stAtMtaSetFrReq), 0x00, sizeof(AT_MTA_SET_FR_REQ_STRU));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* enActFrFlag取值范围为'0'~'1' */
    if ( ((gastAtParaList[0].ulParaValue) != 0)
      && ((gastAtParaList[0].ulParaValue) != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enActFrFlag = (PS_BOOL_ENUM_UINT8)(gastAtParaList[0].ulParaValue);

    /* 填充结构体 */
    stAtMtaSetFrReq.enActFrFlag       = enActFrFlag;
    stAtMtaSetFrReq.aucRsv[0]         = 0;
    stAtMtaSetFrReq.aucRsv[1]         = 0;
    stAtMtaSetFrReq.aucRsv[2]         = 0;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   ID_AT_MTA_SET_FR_REQ,
                                   (VOS_VOID*)&stAtMtaSetFrReq,
                                   sizeof(AT_MTA_SET_FR_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_FRSTATUS_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
#endif




TAF_UINT32   At_SetBsn(TAF_UINT8 ucIndex)
{
    TAF_PH_SERIAL_NUM_STRU              stSerialNum;
    errno_t                             lMemResult;

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /* 如果参数长度<imei>不等于16，直接返回错误 */
    if(gastAtParaList[0].usParaLen != TAF_SERIAL_NUM_LEN)
    {
        return AT_ERROR;
    }


    /*检查<imei>是否为数字字符串,不是则直接返回错误*/
    if(At_CheckNumCharString( gastAtParaList[0].aucPara,
                              gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    lMemResult = memcpy_s(stSerialNum.aucSerialNum, sizeof(stSerialNum.aucSerialNum), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSerialNum.aucSerialNum), gastAtParaList[0].usParaLen);
    lMemResult = memset_s(stSerialNum.aucSerialNum+TAF_SERIAL_NUM_LEN, (VOS_SIZE_T)(4*sizeof(stSerialNum.aucSerialNum[0])), 0x00, (VOS_SIZE_T)(4*sizeof(stSerialNum.aucSerialNum[0])));
    TAF_MEM_CHK_RTN_VAL(lMemResult, 4 * sizeof(stSerialNum.aucSerialNum[0]),
                        4 * sizeof(stSerialNum.aucSerialNum[0]));

    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_ManufactureInfo,
                           stSerialNum.aucSerialNum,
                           TAF_SERIAL_NUM_NV_LEN))
    {
        return AT_ERROR;
    }
    else
    {
       return AT_OK;
    }

}


VOS_UINT32   At_SetQosPara(VOS_UINT8 ucIndex)
{
    AT_TRAFFIC_CLASS_CUSTOMIZE_STRU                         stATTrafficClass;
    MODEM_ID_ENUM_UINT16                                    enModemId;
    VOS_UINT32                                              ulRet;
    VOS_UINT8                                               ucQosPara;

    enModemId = MODEM_ID_0;

    /* 命令状态类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 数据保护未解除 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_DATA_UNLOCK_ERROR;
    }

    /* 参数个数不为1 */
    if (gucAtParaIndex != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数长度不为1 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    ucQosPara = gastAtParaList[0].aucPara[0];

    /* ucQosPara取值范围为'0'~'4' */
    if ((ucQosPara >= '0') && (ucQosPara <= '4'))
    {
        ucQosPara = gastAtParaList[0].aucPara[0] - '0';
    }
    else
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 将NV项en_NV_Item_TRAFFIC_CLASS_Type的ucStatus单元置为激活态1 */
    stATTrafficClass.ucStatus       = NV_ITEM_ACTIVE;

    /* 将数字参数值写入NV项的ucTrafficClass单元 */
    stATTrafficClass.ucTrafficClass = ucQosPara;

    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("At_SetQosPara: Get modem id fail.");
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_WRITE(enModemId,
                            en_NV_Item_TRAFFIC_CLASS_Type,
                            &stATTrafficClass,
                            sizeof(AT_TRAFFIC_CLASS_CUSTOMIZE_STRU)))
    {
        AT_WARN_LOG("At_SetQosPara:WARNING:NVIM Write en_NV_Item_TRAFFIC_CLASS_Type failed!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return  AT_OK;
}


VOS_UINT32   At_SetSDomainPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_SERVICE_DOMAIN_ENUM_UINT8   enSrvDomain;
    NAS_NVIM_MS_CLASS_STRU              stMsClass;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRet;

    enModemId = MODEM_ID_0;
    memset_s(&stMsClass, sizeof(stMsClass), 0x00, sizeof(NAS_NVIM_MS_CLASS_STRU));

    /* 命令状态类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 数据保护未解除 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return AT_DATA_UNLOCK_ERROR;
    }

    /* 参数个数不为1 */
    if (gucAtParaIndex != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数长度不为1 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    enSrvDomain = gastAtParaList[0].aucPara[0];

    /* ucSrvDomain取值范围为'0'~'3' */
    if ((enSrvDomain >= '0') && (enSrvDomain <= '3'))
    {
        /*将字符参数转换为数字,范围为0~3*/
        enSrvDomain = gastAtParaList[0].aucPara[0] - '0';
    }
    else
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 将数字参数转换为MsClass类型，即将3转换为0*/
    if (enSrvDomain == TAF_MMA_SERVICE_DOMAIN_ANY)
    {
        enSrvDomain = TAF_MMA_SERVICE_DOMAIN_CS;
    }

    stMsClass.ucMsClass = enSrvDomain;
    /* 将转换后的参数值写入NV项en_NV_Item_MMA_MsClass的MsClass单元 */
    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("At_SetSDomainPara: Get modem id fail.");
        return AT_ERROR;
    }
    if (NV_OK != TAF_ACORE_NV_WRITE(enModemId,
                            en_NV_Item_MMA_MsClass,
                            &stMsClass,
                            sizeof(NAS_NVIM_MS_CLASS_STRU)))
    {
       AT_WARN_LOG("At_SetSDomainPara:WARNING:NVIM Write en_NV_Item_MMA_MsClass failed!");
       return AT_DEVICE_OTHER_ERROR;
    }
    return  AT_OK;
}



VOS_UINT32 At_WriteDpaCatToNV(VOS_UINT8 ucDpaRate)
{
    AT_NVIM_UE_CAPA_STRU                stUECapa;
    AT_DPACAT_PARA_STRU                 astDhpaCategory[AT_DPACAT_CATEGORY_TYPE_BUTT] = {
                {PS_TRUE,   AT_HSDSCH_PHY_CATEGORY_6,  PS_FALSE, 0, PS_FALSE},                                                           /* 支持速率等级3.6M  */
                {PS_TRUE,   AT_HSDSCH_PHY_CATEGORY_8,  PS_FALSE, 0, PS_FALSE},                                                           /* 支持速率等级7.2M  */
                {PS_TRUE,   AT_HSDSCH_PHY_CATEGORY_11, PS_FALSE, 0, PS_FALSE},                                                           /* 支持速率等级1.8M  */
                {PS_TRUE,   AT_HSDSCH_PHY_CATEGORY_10, PS_FALSE, 0, PS_FALSE},                                                          /*  支持速率等级14.4M */
                {PS_TRUE,   AT_HSDSCH_PHY_CATEGORY_10, PS_TRUE,  AT_HSDSCH_PHY_CATEGORY_14, PS_FALSE}};           /*  支持速率等级21M */


    memset_s(&stUECapa, sizeof(stUECapa), 0x00, sizeof(stUECapa));


    if (ucDpaRate >= AT_DPACAT_CATEGORY_TYPE_BUTT)
    {
        AT_WARN_LOG("At_WriteDpaCatToNV: WARNING:Input DPA rate index invalid!");
        return VOS_ERR;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WAS_RadioAccess_Capa_New, &stUECapa, sizeof(AT_NVIM_UE_CAPA_STRU)) != NV_OK)
    {
        AT_WARN_LOG("At_WriteDpaCatToNV: en_NV_Item_WAS_RadioAccess_Capa NV Read Fail!");
        return VOS_ERR;
    }

    /* 是否支持enHSDSCHSupport的标志                */
    stUECapa.enHSDSCHSupport        = astDhpaCategory[ucDpaRate].enHSDSCHSupport;

    /* 支持HS-DSCH物理层的类型标志                  */
    stUECapa.ucHSDSCHPhyCategory    = astDhpaCategory[ucDpaRate].ucHSDSCHPhyCategory;
    stUECapa.enMacEhsSupport        = astDhpaCategory[ucDpaRate].enMacEhsSupport;
    stUECapa.ucHSDSCHPhyCategoryExt = astDhpaCategory[ucDpaRate].ucHSDSCHPhyCategoryExt;

    /* 是否支持 Multi cell support,如果支持MultiCell,Ex2存在 */
    stUECapa.enMultiCellSupport     = astDhpaCategory[ucDpaRate].enMultiCellSupport;

    /* 将新的能力写到内部的全局变量，并更新到NV项中 */
    stUECapa.ulHspaStatus           = NV_ITEM_ACTIVE;                /* 此项成为激活项 */

    /* 已经设置好NV结构体中的对应值，将这些值写入NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_WAS_RadioAccess_Capa_New, &stUECapa, sizeof(AT_NVIM_UE_CAPA_STRU)) != NV_OK)
    {
        AT_WARN_LOG("At_WriteDpaCatToNV: en_NV_Item_WAS_RadioAccess_Capa NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)


VOS_UINT32   At_SetDpaCat(VOS_UINT8 ucIndex)
{
    /*0     支持速率为3.6M
     *1     支持速率为7.2M
     *2     支持速率为1.8M
     *3     支持速率为14.4M
     *4     支持速率为21M
    */
    VOS_UINT8                           ucDpaRate;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数不为1 */
    if (gucAtParaIndex != 1)
    {
        return AT_ERROR;
    }

    /* 参数内容只能为1个 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_ERROR;
    }

    ucDpaRate = gastAtParaList[0].aucPara[0];
    /* ucDpaRate取值范围为'0'~'4' */
    if ((ucDpaRate >= '0') && (ucDpaRate <= '4'))
    {
        ucDpaRate = gastAtParaList[0].aucPara[0] - '0';
    }
    else
    {
        return AT_ERROR;
    }

    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_ERROR;
    }

    /* 调用写NV接口函数: At_WriteDpaCatToNV,返回操作结果 */
    if (At_WriteDpaCatToNV(ucDpaRate) == VOS_OK)
    {
        return  AT_OK;
    }
    else
    {
        AT_WARN_LOG("At_SetDpaCat:WARNING:WAS_MNTN_SetDpaCat failed!");
        return AT_ERROR;
    }

}
#endif


VOS_UINT32 AT_WriteRrcVerToNV(VOS_UINT8 ucSrcWcdmaRRC)
{
    AT_NVIM_UE_CAPA_STRU                stUECapa;


    /* 从NV项中读取en_NV_Item_WAS_RadioAccess_Capa值 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WAS_RadioAccess_Capa_New,
                         &stUECapa,
                         sizeof(AT_NVIM_UE_CAPA_STRU)))
    {
        AT_WARN_LOG("AT_WriteRrcVerToNV():en_NV_Item_WAS_RadioAccess_Capa_New NV Read Fail!");
        return VOS_ERR;
    }

    switch(ucSrcWcdmaRRC)
    {
        case AT_RRC_VERSION_WCDMA:
            stUECapa.enEDCHSupport    = VOS_FALSE;
            stUECapa.enHSDSCHSupport  = VOS_FALSE;
            break;

        case AT_RRC_VERSION_DPA:
            stUECapa.enEDCHSupport    = VOS_FALSE;
            stUECapa.enHSDSCHSupport  = VOS_TRUE;
            break;

        case AT_RRC_VERSION_DPA_AND_UPA:
            stUECapa.enAsRelIndicator = AT_PTL_VER_ENUM_R6;
            stUECapa.enEDCHSupport    = VOS_TRUE;
            stUECapa.enHSDSCHSupport  = VOS_TRUE;
            break;

        case AT_RRC_VERSION_HSPA_PLUNS:
            stUECapa.enAsRelIndicator = AT_PTL_VER_ENUM_R7;
            stUECapa.enEDCHSupport    = VOS_TRUE;
            stUECapa.enHSDSCHSupport  = VOS_TRUE;
            break;

        default:
            break;
    }

    /* 将要设置的值写入Balong NV 结构体 */
    stUECapa.ulHspaStatus     = NV_ITEM_ACTIVE;


    /* 已经设置好NV结构体中的对应值，将这些值写入NV */
    if(NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_WAS_RadioAccess_Capa_New,
                         &stUECapa,
                         sizeof(AT_NVIM_UE_CAPA_STRU)))
    {
        AT_WARN_LOG("AT_WriteRrcVerToNV():en_NV_Item_WAS_RadioAccess_Capa_New NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;
}



VOS_UINT32   At_SetHspaSpt(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucRRCVer;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_DPAUPA_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_DPAUPA_ERROR;
    }

    /* 参数内容只能为1个 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_DPAUPA_ERROR;
    }

    ucRRCVer = gastAtParaList[0].aucPara[0];
    /* ucRRCVer取值范围为'0'~'2' */
    if ((ucRRCVer >= '0') && (ucRRCVer <= '2'))
    {
        ucRRCVer = gastAtParaList[0].aucPara[0] - '0';
    }
    else
    {
        return AT_DPAUPA_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息:ErrCode:0 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_DATA_UNLOCK_ERROR;
    }

    /* 调用写NV接口函数: AT_WriteRrcVerToNV,返回操作结果 */
    if (AT_WriteRrcVerToNV(ucRRCVer) == VOS_OK)
    {
        return  AT_OK;
    }
    else
    {
        AT_WARN_LOG("At_SetHspaSpt:WARNING:WAS_MNTN_SetHspaSpt failed!");
        return AT_DPAUPA_ERROR;
    }

}


VOS_UINT32  At_SetDataLock(VOS_UINT8 ucIndex )
{
    DRV_AGENT_DATALOCK_SET_REQ_STRU     stDatalockInfo;
    errno_t                             lMemResult;

    /* 设置命令无参数 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /* <unlock_code>必须为长度为8的数字字符串 */
    if ( gastAtParaList[0].usParaLen != TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX)
    {
        return AT_ERROR;
    }

    if (At_CheckNumString(gastAtParaList[0].aucPara,
                          TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    if (g_bAtDataLocked == VOS_TRUE)
    {
        /* 复制用户解锁码 */
        stDatalockInfo.aucPwd[TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX] = '\0';
        lMemResult = memcpy_s(stDatalockInfo.aucPwd, sizeof(stDatalockInfo.aucPwd), gastAtParaList[0].aucPara, TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stDatalockInfo.aucPwd), TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);

        /* 发消息到 C 核 获取 DATALOCK 校验信息 */
        if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_DATALOCK_SET_REQ,
                                   &stDatalockInfo,
                                   sizeof(stDatalockInfo),
                                   I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DATALOCK_SET;           /*设置当前操作模式 */
            return AT_WAIT_ASYNC_RETURN;                                            /* 等待异步事件返回 */
        }
        else
        {
            return AT_ERROR;
        }
    }

    return AT_OK;

}

#if (FEATURE_LTE == FEATURE_ON)
/* 生产NV恢复 */
VOS_UINT32  At_SetInfoRRS(VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 参数个数过多 */
    if (gucAtParaIndex != 0)
    {
        return AT_ERROR;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_INFORRS_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_INFORRS_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}
#endif


VOS_UINT32  At_SetInfoRBU(VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 参数个数过多 */
    if (gucAtParaIndex != 0)
    {
        return AT_ERROR;
    }
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_INFORBU_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_INFORBU_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}

VOS_UINT32 At_SetGPIOPL(VOS_UINT8 ucIndex)
{
    DRV_AGENT_GPIOPL_SET_REQ_STRU       stGpioplSet;
    errno_t                             lMemResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /* 如果参数长度GPIOPL大于20个字节,即:BCD数 > 20*2个，直接返回错误 */
    if (gastAtParaList[0].usParaLen > (AT_GPIOPL_MAX_LEN*2))
    {
        return AT_ERROR;
    }

    /*检查GPIO值是否为16进制字符串,不是则直接返回错误;是则转换为16进制数字*/
    if (At_AsciiNum2HexString(gastAtParaList[0].aucPara,
                              &gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_ERROR;
    }

    memset_s(stGpioplSet.aucGpiopl, sizeof(stGpioplSet.aucGpiopl), 0x00, DRVAGENT_GPIOPL_MAX_LEN);

    lMemResult = memcpy_s(stGpioplSet.aucGpiopl, sizeof(stGpioplSet.aucGpiopl), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stGpioplSet.aucGpiopl), gastAtParaList[0].usParaLen);

    /*调用AT_FillAndSndAppReqMsg发消息到C核I0_WUEPS_PID_DRV_AGENT*/
    if (AT_FillAndSndAppReqMsg( gastAtClientTab[ucIndex].usClientId,
                                gastAtClientTab[ucIndex].opId,
                                DRV_AGENT_GPIOPL_SET_REQ,
                                &stGpioplSet,
                                sizeof(stGpioplSet),
                                I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_GPIOPL_SET;       /*设置当前操作模式 */
        return AT_WAIT_ASYNC_RETURN;                                      /* 等待异步事件返回 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32  At_ConvertSDErrToAtErrCode(VOS_UINT32 ulSDOprtErr)
{
    VOS_UINT32 ulAtSDErrCode;

    switch (ulSDOprtErr)
    {
        case AT_SD_ERR_CRAD_NOT_EXIST:
            ulAtSDErrCode = AT_SD_CARD_NOT_EXIST;
            break;

        case AT_SD_ERR_INIT_FAILED:
            ulAtSDErrCode = AT_SD_CARD_INIT_FAILED;
            break;

        case AT_SD_ERR_OPRT_NOT_ALLOWED:
            ulAtSDErrCode = AT_SD_CARD_OPRT_NOT_ALLOWED;
            break;

        case AT_SD_ERR_ADDR_ERR :
            ulAtSDErrCode = AT_SD_CARD_ADDR_ERR;
            break;

        default:
            ulAtSDErrCode = AT_SD_CARD_OTHER_ERR;
            break;

    }

    return ulAtSDErrCode;
}

VOS_BOOL At_IsArrayContentValueEquToPara(
    VOS_UINT8                           ucValue,
    VOS_UINT32                          ulArrLen,
    VOS_UINT8                           aucContent[]
 )
{
    VOS_UINT32                          i;

    for (i = 0; i < ulArrLen; i++)
    {
        if(ucValue != aucContent[i])
        {
            break;
        }
    }
    if (i != ulArrLen)
    {
        return VOS_FALSE;
    }
    else
    {
        return VOS_TRUE;
    }

}


VOS_UINT32 At_SDOprtRead(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulOprtErr;
    VOS_UINT32                          ulOprtRslt;
    VOS_UINT32                          ulAddr;
    VOS_UINT8                          *pucSdData = VOS_NULL_PTR;
    VOS_UINT16                          usLength;
    VOS_BOOL                            bSameContent;
    VOS_UINT8                           ucPrintData;

    if (gucAtParaIndex != 2)
    {
        return AT_SD_CARD_OTHER_ERR;
    }

    /* 申请用于保存指定地址开始的512个字节的内存*/
    pucSdData = (VOS_UINT8* )PS_MEM_ALLOC(WUEPS_PID_AT, AT_SD_DATA_UNIT_LEN);

    if (pucSdData == VOS_NULL_PTR)
    {
        AT_ERR_LOG("At_SD_Read: Fail to Alloc memory.");
        return AT_SD_CARD_OTHER_ERR;
    }

    ulAddr = gastAtParaList[1].ulParaValue;

    ulOprtRslt = mdrv_sd_at_process(SD_MMC_OPRT_READ, ulAddr, 0, pucSdData, &ulOprtErr);

    ucPrintData = 0;

    if (ulOprtRslt == VOS_OK)
    {
        ulOprtErr = AT_DEVICE_ERROR_BEGIN;

        /* 指定地址开始的512个字节内容是否相同 */
        bSameContent = At_IsArrayContentValueEquToPara(pucSdData[0],AT_SD_DATA_UNIT_LEN,pucSdData);

        if (bSameContent == VOS_TRUE)
        {
            switch(pucSdData[0])
            {
                case 0x00:
                    ucPrintData = 0;
                    break;
                case 0x55:
                    ucPrintData = 1;
                    break;
                case 0xAA:
                    ucPrintData = 2;
                    break;
                case 0xFF:
                    ucPrintData = 3;
                    break;
                 default:
                    ulOprtErr = AT_SD_CARD_OTHER_ERR;
                    break;

            }
        }
        else
        {
            ulOprtErr = AT_SD_CARD_OTHER_ERR;
        }

        PS_MEM_FREE(WUEPS_PID_AT, pucSdData);

        if  (ulOprtErr == AT_DEVICE_ERROR_BEGIN)
        {
            /* 正常返回，打印对应的显示格式 */
            usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                              (VOS_CHAR *)pgucAtSndCodeAddr,
                                              (VOS_CHAR*)pgucAtSndCodeAddr,
                                              "%s:%d",
                                              g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                              ucPrintData);

            gstAtSendData.usBufLen = usLength;
            return AT_OK;
        }
        else
        {
            /* 转换为对应错误码打印 */
            return At_ConvertSDErrToAtErrCode(ulOprtErr);
        }

    }
    else
    {
        PS_MEM_FREE(WUEPS_PID_AT,pucSdData);
        return At_ConvertSDErrToAtErrCode(ulOprtErr);
    }

}

VOS_UINT32 At_SDOprtWrtEraseFmt(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          ulOprtErr;
    VOS_UINT32                          ulOprtRslt;
    VOS_UINT32                          ulAddr;
    VOS_UINT32                          ulData;

    switch (gastAtParaList[0].ulParaValue)
    {
        case AT_SD_OPRT_FORMAT:
            /* 对SD卡进行格式化操作 */
            ulOprtRslt = mdrv_sd_at_process(SD_MMC_OPRT_FORMAT,
                                            0, 0, VOS_NULL_PTR, &ulOprtErr);
            break;

        case AT_SD_OPRT_ERASE:
            /* 只有一个参数时，擦除整张SD卡; 多个参数时，删除指定地址的SD卡内容  */
            if (gucAtParaIndex == 1)
            {
                ulOprtRslt = mdrv_sd_at_process(SD_MMC_OPRT_ERASE_ALL,
                                                0, 0, VOS_NULL_PTR, &ulOprtErr);
            }
            else
            {
                ulAddr     = gastAtParaList[1].ulParaValue;
                ulOprtRslt = mdrv_sd_at_process(SD_MMC_OPRT_ERASE_SPEC_ADDR,
                                                ulAddr, 0, VOS_NULL_PTR, &ulOprtErr);
            }
            break;

        case AT_SD_OPRT_WRITE:
            /* 对SD卡的指定地址进行写操作 */
            if (gucAtParaIndex == 3)
            {
                ulAddr     = gastAtParaList[1].ulParaValue;
                ulData     = gastAtParaList[2].ulParaValue;
                ulOprtRslt = mdrv_sd_at_process(SD_MMC_OPRT_WRITE,
                                                ulAddr, ulData, VOS_NULL_PTR, &ulOprtErr);
            }
            else
            {
                return AT_SD_CARD_OTHER_ERR;
            }
            break;

        default:
            return AT_SD_CARD_OPRT_NOT_ALLOWED;
    }

    if (ulOprtRslt != VOS_OK)
    {
       return At_ConvertSDErrToAtErrCode(ulOprtErr);
    }

    return AT_OK;
}


VOS_UINT32  At_SetSD(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulCurrentOprtStaus;
    VOS_INT32                           lCurrentSDStaus;

    /* 设置命令无参数时，AT^SD为查询SD卡在位状态 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        lCurrentSDStaus = DRV_SDMMC_GET_STATUS();
        if (lCurrentSDStaus == AT_SD_STATUS_EXIST)
        {
            return AT_OK;
        }
        else
        {
            return AT_ERROR;
        }
    }

    /* 参数过多 */
    if (gucAtParaIndex > 3)
    {
        return AT_SD_CARD_OTHER_ERR;
    }

    /* SD卡操作为串行方式，查询当前是否有进行的操作，以确定是否可进行新的设置操作 */
    ulCurrentOprtStaus = mdrv_sd_get_opptstatus();

    /* 上次的操作尚未结束 ，不进行新操作 */
    if (ulCurrentOprtStaus == AT_SD_OPRT_RSLT_NOT_FINISH)
    {
        return AT_SD_CARD_OTHER_ERR;
    }

    /*  当前非执行状态，可进行新的读、写、格式化操作 */
    if (gastAtParaList[0].ulParaValue == AT_SD_OPRT_READ)
    {
        return At_SDOprtRead(ucIndex);
    }
    else
    {
        return At_SDOprtWrtEraseFmt(ucIndex);
    }


}

 
 VOS_UINT32 At_CheckRxdivOrRxpriParaIfSupported(
     VOS_UINT16                         *pusSetBands,
     VOS_UINT16                         usBands
 )
 {
     VOS_UINT32                         ulResult;
     VOS_UINT32                         i;
     VOS_UINT32                         ulSetLowBands;
     VOS_UINT32                         ulSetHighBands;

     /* 把用户设置的接收分集或主集参数转换成数字 */
     ulResult = At_GetUserSetRxDivOrRxPriParaNum(&ulSetLowBands, &ulSetHighBands);
     if (ulResult != AT_OK)
     {
         return ulResult;
     }

     /* 如果设置成0X3FFFFFFF，认为是打开所有支持的分集或主集;
        否则，把用户设置的参数转成和驱动保存的RX分集或主集对应的格式 */
     if ((ulSetLowBands == TAF_PH_BAND_ANY) && (ulSetHighBands == 0))
     {
         *pusSetBands = usBands;
     }
     else
     {
         ulResult = At_CovertUserSetRxDivOrRxPriParaToMsInternal(ulSetLowBands,
                                           ulSetHighBands, pusSetBands);
         if (ulResult != AT_OK)
         {
             return ulResult;
         }
     }

     /* 底软支持的RX DIV格式如下:
          2100M/ bit1  1900M/bit2  1800M/bit3  1700M/bit4  1600M/bit5
          1500M/bit6   900M/bit7   850M/bit8   800M/bit9   450M/bit10
       如果打开的是底软不支持的分集或主集，返回错误 */
     for (i = 0; i < 16; i++)
     {
         if ((((usBands >> i) & 0x0001) == 0)
          && (((*pusSetBands >> i) & 0x0001) == 0x0001))
         {
              return AT_CME_RX_DIV_NOT_SUPPORTED;
         }
     }

     return AT_OK;

 }


VOS_UINT32  AT_ProcUus1WithParm(
    VOS_UINT8                           ucIndex,
    MN_CALL_UUS1_PARAM_STRU            *pstUus1Group
)
{
    VOS_UINT32                          ulRet;
    VOS_UINT32                          ulMsgNum;
    VOS_UINT32                          i;
    VOS_UINT32                          ulRst;
    VOS_UINT32                          ulStrLength;
    errno_t                             lMemResult;

    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_UUS1_PARAM_STRU             stUus1Info;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stUus1Info, sizeof(stUus1Info), 0x00, sizeof(stUus1Info));

    /* 去处<n>和<m>后,实际的消息个数 */
    ulMsgNum   = gucAtParaIndex;


    if(gastAtParaList[2].usParaLen == 0)
    {
        pstUus1Group->ulActNum = 0;
    }
    else
    {
        /* 设置message */
        for (i = 2 ; (i < ulMsgNum && i < (AT_MAX_PARA_NUMBER-1)); i++)
        {

            /* 先需要转换,由于该命令可设置多次参数,AT格式中仅对前4个参数进行转换,
            后面的参数未进行转换,因此需要将数组中的值进行所转换*/
            if (At_Auc2ul(gastAtParaList[i].aucPara,
                          gastAtParaList[i].usParaLen,
                          &gastAtParaList[i].ulParaValue) != AT_SUCCESS)
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            pstUus1Group->stUus1Info[pstUus1Group->ulActNum].enMsgType = gastAtParaList[i].ulParaValue;
            i++;

            /*<UUIE>不存在,表明是去激活 */
            if ( gastAtParaList[i].usParaLen == 0 )
            {
                pstUus1Group->enSetType[pstUus1Group->ulActNum] = MN_CALL_SET_UUS1_DEACT;
            }
            else
            {
                pstUus1Group->enSetType[pstUus1Group->ulActNum] = MN_CALL_SET_UUS1_ACT;
                /* 需将ASCII转换为HEX */
                if (At_AsciiNum2HexString(gastAtParaList[i].aucPara,
                                          &gastAtParaList[i].usParaLen) == AT_FAILURE)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                ulStrLength = sizeof(pstUus1Group->stUus1Info[pstUus1Group->ulActNum].aucUuie);
                if(ulStrLength < gastAtParaList[i].usParaLen)
                {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                lMemResult = memcpy_s(pstUus1Group->stUus1Info[pstUus1Group->ulActNum].aucUuie,
                                      sizeof(pstUus1Group->stUus1Info[pstUus1Group->ulActNum].aucUuie),
                                      gastAtParaList[i].aucPara,
                                      gastAtParaList[i].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstUus1Group->stUus1Info[pstUus1Group->ulActNum].aucUuie), gastAtParaList[i].usParaLen);
            }

            ulRet = MN_CALL_CheckUus1ParmValid(pstUus1Group->enSetType[pstUus1Group->ulActNum],
                                              &(pstUus1Group->stUus1Info[pstUus1Group->ulActNum]));
            if ( ulRet != MN_ERR_NO_ERROR )
            {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            pstUus1Group->ulActNum++;

            /* 如果未携带UUIE,则默认表示结束不关心后面参数 */
            if (pstUus1Group->enSetType[pstUus1Group->ulActNum] == MN_CALL_SET_UUS1_DEACT)
            {
                break;
            }
        }
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    lMemResult = memcpy_s(&stUus1Info,
                          sizeof(stUus1Info),
                          pstUus1Group,
                          sizeof(MN_CALL_UUS1_PARAM_STRU));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stUus1Info), sizeof(MN_CALL_UUS1_PARAM_STRU));

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 1.对要设置的各个Uus1Info进行设定，然后通过MN_CALL_APP_SET_UUSINFO消息带参数结构
         MN_CALL_UUS1_PARAM_STRU通知CS进行参数设置 */
    ulRst = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stUus1Info,
                                  ID_TAF_CCM_SET_UUSINFO_REQ,
                                  sizeof(stUus1Info),
                                  enModemId);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_APP_SET_UUSINFO_REQ;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetCuus1Para(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulRet;
    MN_CALL_UUS1_PARAM_STRU             stUus1Info;   /* 设置UUS1信息结构 */

    /*************************************************************
    27007中该命令格式,该命令可以不携带任何参数,如果不携带参数直接返回OK
    + CUUS1 =[<n>[,<m>[,<message>[,<UUIE> [,<message>[,<UUIE>[,...]]]]]]]
    ****************************************************************/

    /* 不携带参数直接返回OK */
    if ( gucAtParaIndex == 0 )
    {
        return AT_OK;
    }

    memset_s(&stUus1Info, sizeof(stUus1Info), 0x00, sizeof(stUus1Info));

    /* 设置<n> */
    if(gastAtParaList[0].usParaLen != 0)
    {
        stUus1Info.enCuus1IFlg = (MN_CALL_CUUS1_FLG_ENUM_U32)gastAtParaList[0].ulParaValue;
    }
    else
    {
        /* <n>不存在同时参数个数不为0返回ERROR */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<m> */
    if(gastAtParaList[1].usParaLen != 0)
    {
        stUus1Info.enCuus1UFlg = (MN_CALL_CUUS1_FLG_ENUM_U32)gastAtParaList[1].ulParaValue;
    }

    /* 设置message */
    /* 只带n和m参数时，也要给MN发消息 */
    ulRet = AT_ProcUus1WithParm(ucIndex, &stUus1Info);


    return ulRet;

}

VOS_UINT32  At_SetGlastErrPara(VOS_UINT8 ucIndex)
{
    VOS_UINT16                          usLength;
    TAF_PS_CAUSE_ENUM_UINT32            enPsCause;

    usLength                            = 0;

    /* 检查拨号错误码是否使能*/
    if (gucPppDialErrCodeRpt == PPP_DIAL_ERR_CODE_DISABLE)
    {
       return AT_ERROR;
    }

    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

     /* 没有参数*/
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数值错误*/
    if (gastAtParaList[0].ulParaValue != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gulErrType = gastAtParaList[0].ulParaValue;

    /* 获取错误码*/
    enPsCause = AT_PS_GetPsCallErrCause(ucIndex);
    if (enPsCause == TAF_PS_CAUSE_SUCCESS)
    {
        return AT_ERROR;
    }

    /* 将错误码上报给后台*/
    usLength =  (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       "%s: %d,%d",
                                       g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                       gulErrType,
                                       AT_Get3gppSmCauseByPsCause(enPsCause));

    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}


VOS_UINT32 AT_SetMDatePara(
    VOS_UINT8                           ucIndex
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulRet;
    AT_DATE_STRU                        stDate;
    TAF_AT_NVIM_MANUFACTURE_DATE_STRU   stManufactrueDate;

    if (gucAtParaIndex != 1)
    {
        AT_NORM_LOG("AT_SetMDatePara: the number of parameters is error.");
        return AT_ERROR;
    }

    /* 参数检查1:日期格式检查；*/
    ulRet = AT_CheckDateFormat(gastAtParaList[0].aucPara,
                               gastAtParaList[0].usParaLen);
    if (ulRet != AT_OK)
    {
        AT_NORM_LOG("AT_SetMDatePara: the format of parameters is error.");
        return AT_ERROR;
    }

    /* 参数检查2:获取生产日期并对日期作有效性检查；*/
    ulRet = AT_GetDate(gastAtParaList[0].aucPara,
                       gastAtParaList[0].usParaLen,
                       &stDate);
    if (ulRet != AT_OK)
    {
        AT_NORM_LOG("AT_SetMDatePara: Fail to get the date.");
        return AT_ERROR;
    }

    ulRet = AT_CheckDate(&stDate);
    if (ulRet != AT_OK)
    {
        AT_NORM_LOG("AT_SetMDatePara: the value of parameters is error.");
        return AT_ERROR;
    }

    /* 写日期参数到NV */
    lMemResult = memcpy_s(stManufactrueDate.aucMDate, sizeof(stManufactrueDate.aucMDate), gastAtParaList[0].aucPara, (AT_MDATE_STRING_LENGTH - 1));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stManufactrueDate.aucMDate), (AT_MDATE_STRING_LENGTH - 1));
    stManufactrueDate.aucMDate[AT_MDATE_STRING_LENGTH - 1] = '\0';
    ulRet = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_MANUFACTURE_DATE,
                     stManufactrueDate.aucMDate,
                     AT_MDATE_STRING_LENGTH);
    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_SetMDatePara: Fail to write nv.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetFacInfoPara(
    VOS_UINT8                          ucIndex
)
{
    VOS_UINT32                          ulRet;
    VOS_UINT8                           *pucFacInfo = TAF_NULL_PTR;
    VOS_UINT32                          ulOffSet;
    errno_t                             lMemResult;

    if ((gucAtParaIndex != 2) || ((gastAtParaList[1].usParaLen == 0)))
    {
        AT_WARN_LOG("AT_SetFacInfoPara: the number of parameters is error.");
        return AT_ERROR;
    }

    /* 长度超过制造信息有效字段长度则参数检查失败 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        if (gastAtParaList[1].usParaLen != AT_FACINFO_INFO1_LENGTH)
        {
            AT_NORM_LOG("AT_SetFacInfoPara: Length of info1 is failure.");
            return AT_ERROR;
        }

        if (At_CheckNumString(gastAtParaList[1].aucPara, AT_FACINFO_INFO1_LENGTH) == AT_FAILURE)
        {
            return AT_ERROR;
        }
    }
    else
    {
        if (gastAtParaList[1].usParaLen != AT_FACINFO_INFO2_LENGTH)
        {
            AT_NORM_LOG("AT_SetFacInfoPara: Length of info2 is failure.");
            return AT_ERROR;
        }

        if (At_CheckNumString(gastAtParaList[1].aucPara, AT_FACINFO_INFO2_LENGTH) == AT_FAILURE)
        {
            return AT_ERROR;
        }
    }

    /* 获取NV中已经存储的制造信息 */
    pucFacInfo = (TAF_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_FACINFO_STRING_LENGTH);
    if (pucFacInfo == TAF_NULL_PTR)
    {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to alloc memory.");
        return AT_ERROR;
    }

    ulRet = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_AT_FACTORY_INFO,
                    pucFacInfo,
                    AT_FACINFO_STRING_LENGTH);
    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to read NVIM . ");
        PS_MEM_FREE(WUEPS_PID_AT, pucFacInfo);
        return AT_ERROR;
    }

    /*
       组装待写入NV项en_NV_Item_AT_FACTORY_INFO的局部变量:
       根据用户输入参数<INDEX>刷新制造信息,
       <INDEX>为0则刷新前129字节，其中第129字节为结束符；
       <INDEX>为1则刷新后129字节，其中第129字节为结束符；
    */
    ulOffSet = (AT_FACINFO_INFO1_LENGTH + 1) * gastAtParaList[0].ulParaValue;
    if ((ulOffSet + gastAtParaList[1].usParaLen) > ((AT_FACINFO_INFO1_LENGTH + 1) + AT_FACINFO_INFO2_LENGTH))
    {
        AT_WARN_LOG("AT_SetFacInfoPara: offset is error. ");
        PS_MEM_FREE(WUEPS_PID_AT, pucFacInfo);
        return AT_ERROR;
    }

    *((pucFacInfo + ulOffSet) + gastAtParaList[1].usParaLen) = '\0';

    lMemResult = memcpy_s((pucFacInfo + ulOffSet),
                           AT_FACINFO_STRING_LENGTH - ulOffSet,
                           gastAtParaList[1].aucPara,
                           gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_FACINFO_STRING_LENGTH - ulOffSet, gastAtParaList[1].usParaLen);

    /* 刷新用户修改后的制造信息到NV项en_NV_Item_AT_FACTORY_INFO */
    ulRet = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_FACTORY_INFO,
                     pucFacInfo,
                     AT_FACINFO_STRING_LENGTH);
    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to write NVIM . ");
        PS_MEM_FREE(WUEPS_PID_AT, pucFacInfo);
        return AT_ERROR;
    }

    PS_MEM_FREE(WUEPS_PID_AT, pucFacInfo);
    return AT_OK;
}


VOS_UINT32 At_SetCallSrvPara(VOS_UINT8 ucIndex)
{
    NAS_NVIM_CUSTOMIZE_SERVICE_STRU              stCustSrv;

    /* 命令状态检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数个数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_DATA_UNLOCK_ERROR;
    }

    stCustSrv.ulCustomizeService = gastAtParaList[0].ulParaValue;
    stCustSrv.ulStatus           = NV_ITEM_ACTIVE;          /*NV项设置为激活*/

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CustomizeService, &stCustSrv, sizeof(stCustSrv)) != NV_OK)
    {
        AT_WARN_LOG("At_SetCallSrvPara():en_NV_Item_CustomizeService NV Write Fail!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return AT_OK;

}


VOS_UINT32 At_WriteWifiNVToDefault(
    AT_CUSTOMIZE_ITEM_DFLT_ENUM_UINT8   enCustomizeItem
)
{
    TAF_AT_MULTI_WIFI_SEC_STRU              stWifiKey;
    TAF_AT_MULTI_WIFI_SSID_STRU             stWifiSsid;

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return VOS_OK;
    }

    memset_s(&stWifiKey, sizeof(stWifiKey), 0x00, sizeof(stWifiKey));
    memset_s(&stWifiSsid, sizeof(stWifiSsid), 0x00, sizeof(stWifiSsid));

    /* 读取WIFI KEY对应的NV项 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY, &stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != NV_OK)
    {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:READ NV ERROR");
        return VOS_ERR;
    }

    /* 设置WIKEY为默认值 */
    memset_s(stWifiKey.aucWifiWpapsk, sizeof(stWifiKey.aucWifiWpapsk), 0x00, sizeof(stWifiKey.aucWifiWpapsk));

    /* 设置WIWEP为默认值 */
    memset_s(stWifiKey.aucWifiWepKey1, sizeof(stWifiKey.aucWifiWepKey1), 0x00, sizeof(stWifiKey.aucWifiWepKey1));
    memset_s(stWifiKey.aucWifiWepKey2, sizeof(stWifiKey.aucWifiWepKey2), 0x00, sizeof(stWifiKey.aucWifiWepKey2));
    memset_s(stWifiKey.aucWifiWepKey3, sizeof(stWifiKey.aucWifiWepKey3), 0x00, sizeof(stWifiKey.aucWifiWepKey3));
    memset_s(stWifiKey.aucWifiWepKey4, sizeof(stWifiKey.aucWifiWepKey4), 0x00, sizeof(stWifiKey.aucWifiWepKey4));

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY, &stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != NV_OK)
    {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:WRITE NV ERROR");
        return VOS_ERR;
    }

    /*读取SSID对应的NV项*/
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID, &stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
    {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:READ NV ERROR");
        return VOS_ERR;
    }

    /* 设置SSID为默认值 */
    memset_s(stWifiSsid.aucWifiSsid, sizeof(stWifiSsid.aucWifiSsid), 0x00, sizeof(stWifiSsid.aucWifiSsid));

    /*写入WIFI SSID对应的NV项*/
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID, &stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
    {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:WRITE NV ERROR");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 At_WriteSimLockNVToDefault(
    VOS_UINT8                           ucIndex,
    AT_CUSTOMIZE_ITEM_DFLT_ENUM_UINT8   enCustomizeItem
)
{
    TAF_CUSTOM_SIM_LOCK_PLMN_INFO_STRU  stSimLockPlmnInfo;
    TAF_CUSTOM_CARDLOCK_STATUS_STRU     stCardLockStatus;
    TAF_CUSTOM_SIM_LOCK_MAX_TIMES_STRU  stSimLockMaxTimes;
    VOS_UINT32                          i;
    errno_t                             lMemResult;

    VOS_UINT8                           aucRange[TAF_PH_SIMLOCK_PLMN_STR_LEN]
                                            = {AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                                               AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL};


    /* 该定制项在可配置需求文档中默认值和单板自定义的默认值相同
       en_NV_Item_CustomizeSimLockPlmnInfo的ulStatus:默认未激活;
       mnc_num:默认为2; range_begin和rang_end默认全为0xAA */
    stSimLockPlmnInfo.ulStatus = NV_ITEM_DEACTIVE;
    for (i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++)
    {
        stSimLockPlmnInfo.astSimLockPlmnRange[i].ucMncNum = AT_SIM_LOCK_MNC_NUM_DEFAULT_VAL;
        lMemResult = memcpy_s(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin,
                              sizeof(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin),
                              aucRange, sizeof(aucRange));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin), sizeof(aucRange));
        lMemResult = memcpy_s(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeEnd,
                              sizeof(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeEnd),
                              aucRange, sizeof(aucRange));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeEnd), sizeof(aucRange));
    }

    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CustomizeSimLockPlmnInfo,
                          &stSimLockPlmnInfo, sizeof(stSimLockPlmnInfo)))
    {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():en_NV_Item_CustomizeSimLockPlmnInfo NV Write Fail!");
        return VOS_ERR;
    }

    /* 该定制项在可配置需求文档中默认值和单板自定义的默认值相同,
       en_NV_Item_CardlockStatus的ulStatus:默认为未激活; CardlockStatus:默认值为2;
       RemainUnlockTimes:默认值为0 */
    stCardLockStatus.ulStatus            = NV_ITEM_DEACTIVE;
    stCardLockStatus.enCardlockStatus    = TAF_OPERATOR_LOCK_NONEED_UNLOCK_CODE;
    stCardLockStatus.ulRemainUnlockTimes = TAF_PH_CARDLOCK_DEFAULT_MAXTIME;
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CardlockStatus, &stCardLockStatus,
                          sizeof(stCardLockStatus)))

    {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():en_NV_Item_CardlockStatus NV Write Fail!");
        return VOS_ERR;
    }


    /*向C核发送消息备份simlockNV*/
    if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               0,
                               DRV_AGENT_SIMLOCK_NV_SET_REQ,
                               &stCardLockStatus,
                               sizeof(stCardLockStatus),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS)
    {

        AT_WARN_LOG("At_WriteSimLockNVToDefault():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        return VOS_ERR;
    }


    /* 该定制项在可配置需求文档中默认值和单板自定义的默认值相同,
       en_NV_Item_CustomizeSimLockMaxTimes的ulStatus:默认为未激活；
       LockMaxTimes:默认最大解锁次数为10次 */
    stSimLockMaxTimes.ulStatus       = NV_ITEM_DEACTIVE;
    stSimLockMaxTimes.ulLockMaxTimes = TAF_PH_CARDLOCK_DEFAULT_MAXTIME;
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CustomizeSimLockMaxTimes, &stSimLockMaxTimes,
                          sizeof(stSimLockMaxTimes)))
    {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():en_NV_Item_CustomizeSimLockMaxTimes NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;

}


VOS_UINT32 At_SetCustomizeItemToDefaultVal(
    VOS_UINT8                           ucIndex,
    AT_CUSTOMIZE_ITEM_DFLT_ENUM_UINT8   enCustomizeItem
)
{

    /* 设置WIFI定制项对应的en_NV_Item_WIFI_KEY、
       en_NV_Item_WIFI_STATUS_SSID 2个NV项 */
    if (At_WriteWifiNVToDefault(enCustomizeItem) != VOS_OK)
    {
        return VOS_ERR;
    }

    /* 设置SimLock定制项对应的en_NV_Item_CustomizeSimLockPlmnInfo、
       en_NV_Item_CardlockStatus、en_NV_Item_CustomizeSimLockMaxTimes 3个NV项 */
    if (At_WriteSimLockNVToDefault(ucIndex, enCustomizeItem) != VOS_OK)
    {
        return VOS_ERR;
    }

    return VOS_OK;

}


VOS_UINT32 At_SetCsdfltPara(VOS_UINT8 ucIndex)
{
    /* 命令状态检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 参数个数过多 */
    if (gucAtParaIndex != 0)
    {
        return AT_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_ERROR;
    }

    /* 默认值为0 */
    if (At_SetCustomizeItemToDefaultVal(ucIndex, AT_CUSTOMIZE_ITEM_DEFAULT_VALUE_FROM_CFGFILE) != VOS_OK)
    {
        return AT_ERROR;
    }

    /*  恢复出厂设置后通知应用保存wifi定制信息 */
    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_SUPPORT )
    {
        AT_PhSendRestoreFactParmNoReset();
    }

    return AT_OK;

}

VOS_UINT32  At_GetParaCnt(
    VOS_UINT8                           *pucData,
    VOS_UINT16                          usLen
)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCnt;

    ulCnt = 0;
    for ( i = 0; i < usLen ; i++ )
    {
        if (pucData[i] == ',')
        {
            ++ ulCnt;
        }
    }

    /*参数个数 = ','个数+1*/
    return (ulCnt + 1);
}

VOS_UINT32 At_AsciiNum2SimLockImsiStr (
    VOS_UINT8                           *pucDst,
    VOS_UINT8                           *pucSrc,
    VOS_UINT16                          usSrcLen
)
{
    VOS_UINT16                          usChkLen;
    VOS_UINT8                           ucTmp;
    VOS_UINT8                           ucBcdCode;

    /* 字符串长度最大为16 */
    if (usSrcLen > (TAF_PH_SIMLOCK_PLMN_STR_LEN * 2))
    {
        return AT_FAILURE;
    }

    for (usChkLen = 0; usChkLen < usSrcLen; usChkLen++)
    {
        /* the number is 0-9 */
        if ((pucSrc[usChkLen] >= 0x30) && (pucSrc[usChkLen] <= 0x39))
        {
            ucBcdCode = pucSrc[usChkLen] - 0x30;
        }
        else
        {
            return AT_FAILURE;
        }

        ucTmp = usChkLen % 2;   /* 判断高低位 */
        if (ucTmp == 0)
        {
            pucDst[usChkLen/2] = (VOS_UINT8)((ucBcdCode << 4) & 0xF0); /* 高位 */
        }
        else
        {
            pucDst[usChkLen/2] |= (VOS_UINT8)(ucBcdCode);   /* 低位 */
        }
    }

    if((usSrcLen % 2) == 1)
    {
        pucDst[usSrcLen/2] |= 0x0F; /* 低位 */
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_CovertAtParaToSimlockPlmnInfo(
    VOS_UINT32                          ulParaCnt,
    AT_PARSE_PARA_TYPE_STRU             *pstParalist,
    TAF_CUSTOM_SIM_LOCK_PLMN_INFO_STRU  *pstSimLockPlmnInfo
)
{
    VOS_UINT8                           ucMncNum;
    VOS_UINT8                           aucImsiStr[TAF_PH_SIMLOCK_PLMN_STR_LEN];
    VOS_UINT8                          *pucPlmnRange = VOS_NULL_PTR;
    VOS_UINT32                          i;
    VOS_UINT32                          ulPlmnParaIdx;
    VOS_UINT32                          ulImsiStrLen;
    errno_t                             lMemResult;

    ulPlmnParaIdx = 0;
    ucMncNum      = 2;


    memset_s(aucImsiStr, sizeof(aucImsiStr), 0x00, sizeof(aucImsiStr));

    /* Plmn号段信息，从第2个参数开始，每3个为一组，对应(MNClen,PlmnRangeBegin,PlmnRangeEnd) */
    for (i = 1; i < ulParaCnt; i++)
    {
        /* 当Plmninfo参数index是3n+1时,对应MNC的长度 */
        if ((i % 3) == 1)
        {
            if (pstParalist[i].usParaLen != 1)
            {
                return AT_SIMLOCK_PLMN_MNC_LEN_ERR;
            }
            else if ((pstParalist[i].aucPara[0] != '2')
                  && (pstParalist[i].aucPara[0] != '3'))
            {
                return AT_SIMLOCK_PLMN_MNC_LEN_ERR;
            }
            else
            {
                ucMncNum = pstParalist[i].aucPara[0] - '0';
                pstSimLockPlmnInfo->astSimLockPlmnRange[ulPlmnParaIdx].ucMncNum = ucMncNum;
            }

        }
        else if ((i % 3) == 2)
        {
            /* 当Plmninfo参数index是3n+2 时,对应PlmnRangeBegin */
            if (At_AsciiNum2SimLockImsiStr(aucImsiStr, pstParalist[i].aucPara,pstParalist[i].usParaLen) == AT_FAILURE)
            {
                return AT_ERROR;
            }
            else
            {
                ulImsiStrLen = (pstParalist[i].usParaLen + 1) / 2;
                pucPlmnRange = pstSimLockPlmnInfo->astSimLockPlmnRange[ulPlmnParaIdx].aucRangeBegin;
                lMemResult = memcpy_s(pucPlmnRange, TAF_PH_SIMLOCK_PLMN_STR_LEN, aucImsiStr, (VOS_UINT16)ulImsiStrLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_PH_SIMLOCK_PLMN_STR_LEN, (VOS_UINT16)ulImsiStrLen);
                memset_s(pucPlmnRange + ulImsiStrLen,
                         TAF_PH_SIMLOCK_PLMN_STR_LEN - ulImsiStrLen,
                         0xFF,
                         (TAF_PH_SIMLOCK_PLMN_STR_LEN - ulImsiStrLen));
            }
        }
        else
        {
            /* 当Plmninfo参数index是3n+2 时,对应PlmnRangeEnd */
            if (At_AsciiNum2SimLockImsiStr(aucImsiStr, pstParalist[i].aucPara,pstParalist[i].usParaLen) == AT_FAILURE)
            {
                return AT_ERROR;
            }
            /* 起始和结束号段长度不一致 或起始号段大于结束号段 直接返回失败 */
            else if((pstParalist[i - 1].usParaLen != pstParalist[i].usParaLen)
                 || (AT_AtoI((VOS_CHAR *)pstParalist[i - 1].aucPara) > AT_AtoI((VOS_CHAR *)pstParalist[i].aucPara)))
            {
                AT_ERR_LOG("At_CovertAtParaToSimlockPlmnInfo: AT_CME_INCORRECT_PARAMETERS!");
                return AT_CME_INCORRECT_PARAMETERS;
            }
            else
            {
                ulImsiStrLen = (pstParalist[i].usParaLen + 1) / 2;
                pucPlmnRange = pstSimLockPlmnInfo->astSimLockPlmnRange[ulPlmnParaIdx].aucRangeEnd;
                lMemResult = memcpy_s(pucPlmnRange, TAF_PH_SIMLOCK_PLMN_STR_LEN, aucImsiStr, (VOS_UINT16)ulImsiStrLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_PH_SIMLOCK_PLMN_STR_LEN, (VOS_UINT16)ulImsiStrLen);
                memset_s(pucPlmnRange + ulImsiStrLen,
                         TAF_PH_SIMLOCK_PLMN_STR_LEN - ulImsiStrLen,
                         0xFF,
                         (TAF_PH_SIMLOCK_PLMN_STR_LEN - ulImsiStrLen));
            }
            ++ ulPlmnParaIdx;
        }

    }

    return AT_OK;

}


VOS_UINT32 At_SetSimLockPlmnInfo(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulParaCnt,
    AT_PARSE_PARA_TYPE_STRU             *pstParalist
)
{
    VOS_UINT32                          ulRslt;
    TAF_CUSTOM_SIM_LOCK_PLMN_INFO_STRU  stSimLockPlmnInfo;
    TAF_CUSTOM_CARDLOCK_STATUS_STRU     stCardLockStatus;
    VOS_UINT32                          i;
    VOS_UINT32                          ulPlmnInfoNum;
    /*TAF_CUSTOM_SIM_LOCK_PLMN_RANGE_STRU stDftPlmnInfoVal;*/

    if (g_bAtDataLocked == VOS_TRUE)
    {
        ulRslt = AT_DATA_UNLOCK_ERROR;
    }
    else if (ulParaCnt > ((TAF_MAX_SIM_LOCK_RANGE_NUM * 3) + 1))
    {
        ulRslt = AT_SIMLOCK_PLMN_NUM_ERR;
    }
    else if (((ulParaCnt - 1) % 3) != 0)
    {
        ulRslt = AT_ERROR;
    }
    else
    {
        ulRslt =  At_CovertAtParaToSimlockPlmnInfo(ulParaCnt, pstParalist, &stSimLockPlmnInfo);
    }

    if (ulRslt != AT_OK)
    {
        At_FormatResultData(ucIndex, ulRslt);
        return AT_ERROR;
    }

    /* 获得PLMN 号段(MNClen,PlmnRangeBegin,PlmnRangeEnd)的个数 ，第2个参数开始是Plmn 信息 */
    ulPlmnInfoNum = (ulParaCnt - 1) / 3;

    /* 将剩余的PLMN号段设置为默认值 */
    for (i = ulPlmnInfoNum ; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++)
    {
        memset_s(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin,
                 TAF_PH_SIMLOCK_PLMN_STR_LEN,
                 AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                 TAF_PH_SIMLOCK_PLMN_STR_LEN);
        memset_s(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeEnd,
                 TAF_PH_SIMLOCK_PLMN_STR_LEN,
                 AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
                 TAF_PH_SIMLOCK_PLMN_STR_LEN);
        stSimLockPlmnInfo.astSimLockPlmnRange[i].ucMncNum = AT_SIM_LOCK_MNC_NUM_DEFAULT_VAL;
    }

    stSimLockPlmnInfo.ulStatus = NV_ITEM_ACTIVE;


    memset_s(&stCardLockStatus, sizeof(stCardLockStatus), 0x00, sizeof(stCardLockStatus));

    /* 获取当前解锁状态*/
    ulRslt = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_CardlockStatus,
                      &stCardLockStatus,
                      sizeof(stCardLockStatus));

    if (ulRslt != NV_OK)
    {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:read en_NV_Item_CardlockStatus Fail.");
        At_FormatResultData(ucIndex, AT_ERROR);
        return AT_ERROR;
    }

    /* 如果当前已经处于锁定状态，直接返回ERROR */
    if ((stCardLockStatus.ulStatus == NV_ITEM_ACTIVE)
     && (stCardLockStatus.ulRemainUnlockTimes == TAF_OPERATOR_UNLOCK_TIMES_MIN)
     && (stCardLockStatus.enCardlockStatus == TAF_OPERATOR_LOCK_LOCKED))
    {
        AT_WARN_LOG("At_SetSimLockPlmnInfo: is locked, operation is not allowed.");
        At_FormatResultData(ucIndex, AT_ERROR);
        return AT_ERROR;

    }

    /* 将en_NV_Item_CardlockStatus的状态置为激活，CardStatus 的内容设置为1,Remain Times保持不变 */
    stCardLockStatus.ulStatus            = NV_ITEM_ACTIVE;
    stCardLockStatus.enCardlockStatus    = TAF_OPERATOR_LOCK_NEED_UNLOCK_CODE;

    ulRslt = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CardlockStatus,
                        &stCardLockStatus,
                        sizeof(stCardLockStatus));
    if (ulRslt != NV_OK)
    {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:write en_NV_Item_CardlockStatus Fail.");
        At_FormatResultData(ucIndex, AT_ERROR);
        return AT_ERROR;
    }


    /*向C核发送消息备份simlockNV*/
    if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               0,
                               DRV_AGENT_SIMLOCK_NV_SET_REQ,
                               &stCardLockStatus,
                               sizeof(stCardLockStatus),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS)
    {

        AT_WARN_LOG("At_SetSimLockPlmnInfo():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        At_FormatResultData(ucIndex, AT_ERROR);
        return VOS_ERR;
    }


    /* 将PLMN信息写入到NV项en_NV_Item_CustomizeSimLockPlmnInfo */

    ulRslt = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_CustomizeSimLockPlmnInfo,
                        &stSimLockPlmnInfo,
                        sizeof(stSimLockPlmnInfo));
    if (ulRslt != NV_OK)
    {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:write en_NV_Item_CustomizeSimLockPlmnInfo Fail.");
        At_FormatResultData(ucIndex, AT_ERROR);
        return AT_ERROR;
    }

    At_FormatResultData(ucIndex, AT_OK);
    return AT_OK;
}


VOS_UINT32 At_SetMaxLockTimes(VOS_UINT8 ucIndex)
{
    TAF_CUSTOM_SIM_LOCK_MAX_TIMES_STRU          stSimLockMaxTimes;

    /* 设置参数为空 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数个数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_bAtDataLocked == VOS_TRUE)
    {
        return  AT_DATA_UNLOCK_ERROR;
    }

    stSimLockMaxTimes.ulStatus       = NV_ITEM_ACTIVE;
    stSimLockMaxTimes.ulLockMaxTimes = gastAtParaList[0].ulParaValue;


    /* 向C核发送消息设置SIMLOCK的最大次数 */
    if (AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               0,
                               DRV_AGENT_MAX_LOCK_TIMES_SET_REQ,
                               &stSimLockMaxTimes,
                               sizeof(stSimLockMaxTimes),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS)
    {

        AT_WARN_LOG("At_SetMaxLockTimes():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MAXLCKTMS_SET;
    return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */


}


VOS_UINT32 AT_SetVertime ( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 发送消息DRV_AGENT_VERTIME_QRY_REQ给AT代理处理 */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_VERTIME_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if(ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VERSIONTIME_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

#if ( VOS_WIN32 == VOS_OS_VER )


VOS_UINT32 AT_ResetNplmn ( VOS_UINT8 ucIndex )
{
    return AT_OK;
}


VOS_UINT32 AT_SetNplmn ( VOS_UINT8 ucIndex )
{
    return AT_OK;
}


VOS_UINT32 At_SetReadUsimStub(VOS_UINT8 ucIndex)
{

    return AT_OK;
}


VOS_UINT32 AT_SetNvimPara ( VOS_UINT8 ucIndex )
{
    NV_ID_ENUM_U16                      eNvimTempId;
    VOS_UINT32                          ulTempLen;
    VOS_UINT32                          ulRst;
    VOS_UINT8                          *pNvTemp = VOS_NULL_PTR;
    VOS_UINT16                          usLength;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRet;

    enModemId = MODEM_ID_0;
    ulTempLen = 0;

    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);
    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("At_SetCgsnPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 参数不正确*/
    if (!(((gastAtParaList[0].ulParaValue == 0) && (gucAtParaIndex == 2))
       || ((gastAtParaList[0].ulParaValue == 1) && (gucAtParaIndex == 3))))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*第二个参数为NV项ID*/
    eNvimTempId = (NV_ID_ENUM_U16)gastAtParaList[1].ulParaValue;

    /*第一个参数为0表示读NV项值，为1表示写NV项*/
    if (gastAtParaList[0].ulParaValue == 0)
    {
        (VOS_VOID)TAF_ACORE_NV_GET_LENGTH(eNvimTempId, &ulTempLen);
        pNvTemp = (VOS_UINT8 *)PS_MEM_ALLOC(I0_WUEPS_PID_TAF, ulTempLen);

        if (pNvTemp == VOS_NULL_PTR)
        {
            AT_ERR_LOG("AT_SetNvimPara:ERROR:ALLOC MEMORY FAIL.");
            return AT_ERROR;
        }
        ulRst = AT_ReadValueFromNvim(eNvimTempId, pNvTemp, ulTempLen, enModemId);
        if (ulRst == AT_OK )
        {
            usLength = 0;
            usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s",gaucAtCrLf);
            usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"^NVSTUB:");
            usLength += (TAF_UINT16)At_HexString2AsciiNumPrint(AT_CMD_MAX_LEN,
                                                                 (TAF_INT8 *)pgucAtSndCodeAddr,
                                                                 pgucAtSndCodeAddr + usLength,
                                                                 pNvTemp,
                                                                 (VOS_UINT16)ulTempLen);

            usLength += (TAF_UINT16)At_sprintf(AT_CMD_MAX_LEN,(TAF_CHAR *)pgucAtSndCodeAddr,(TAF_CHAR *)pgucAtSndCodeAddr + usLength,"%s",gaucAtCrLf);
            At_SendResultData(ucIndex,pgucAtSndCodeAddr,usLength);
            ulRst = AT_SUCCESS;
        }

        /* 增加内存释放 */
        PS_MEM_FREE(I0_WUEPS_PID_TAF, pNvTemp);
        return ulRst;
    }
    else
    {
        if(At_AsciiNum2HexString(gastAtParaList[2].aucPara,
                                 &gastAtParaList[2].usParaLen) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (TAF_ACORE_NV_WRITE_OLD(enModemId, eNvimTempId, gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen) != NV_OK)
        {
             AT_WARN_LOG("AT_SetNvimPara():WARNING:Invoke NVIM Write function falied");
             return AT_ERROR;
        }

        return AT_OK;
    }
}

/* Added by s46746 for DSDA GUNAS C CORE, 2013-01-28, begin */

VOS_UINT32 AT_SetPidReinitPara ( VOS_UINT8 ucIndex )
{
    return AT_OK;
}
/* Added by s46746 for DSDA GUNAS C CORE, 2013-01-28, end */


VOS_UINT32 AT_CheckUSIMPara(VOS_VOID)
{
    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 4)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(gastAtParaList[1].aucPara, &gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}

extern VOS_UINT32 USIMM_ChangeDefFileToPath(
    USIMM_DEF_FILEID_ENUM_UINT32        enDefFileID,
    VOS_CHAR                          **ppcPathStr);


TAF_UINT32 AT_SetUSIMPara(TAF_UINT8 ucIndex)
{
    USIMM_STK_COMMAND_DETAILS_STRU      stCMDDetail;
    VOS_UINT8                           ucRecordNum;
    USIMM_RESET_INFO_STRU               stRstInfo;
    USIMM_UPDATEFILE_REQ_STRU          *pstMsg          = VOS_NULL_PTR;
    USIMM_STKREFRESH_REQ_STRU          *pstRefreshMsg   = VOS_NULL_PTR;
    VOS_UINT32                          ulPathLength;
    VOS_UINT32                          ulMsgLength;
    VOS_CHAR                           *pucFilePathStr  = VOS_NULL_PTR;
    USIMM_DEF_FILEID_ENUM_UINT32        enFileId;
    VOS_UINT32                          i;
    VOS_UINT8                           ucFoundFlag;
    USIMM_CARDAPP_ENUM_UINT32           enAppType;
    VOS_UINT16                          enModemId;
    VOS_UINT32                          ulResult;
    errno_t                             lMemResult;

    ulPathLength                        = 0;
    ulMsgLength                         = 0;

    ucRecordNum = 0;
    enAppType   = USIMM_GUTL_APP;
    enModemId  = MODEM_ID_0;
    AT_GetModemIdFromClient(ucIndex, &enModemId);

    ulResult = AT_CheckUSIMPara();
    if (ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    if (gucAtParaIndex == 3)
    {
        ucRecordNum = gastAtParaList[2].ulParaValue;
    }

    if (gucAtParaIndex == 4)
    {
        ucRecordNum = gastAtParaList[2].ulParaValue;

        enAppType = (USIMM_CARDAPP_ENUM_UINT32)gastAtParaList[3].ulParaValue;
    }

    /* 当读到AT&T & DCM的定制需求更新0x4F36和0x4F34文件时，要设置enAppType */
    /* 文件Id转文件路径 */
    ucFoundFlag = VOS_FALSE;

    if (enAppType == USIMM_GUTL_APP)
    {
        for (i = 0; i < g_aenAtUsimFileNumToIdTabLen; i++)
        {
            if (gastAtParaList[0].ulParaValue == g_aenAtUsimFileNumToIdTab[i].ulFileNum)
            {
                enFileId    = g_aenAtUsimFileNumToIdTab[i].enFileId;

                ucFoundFlag =  VOS_TRUE;
                break;
            }
        }
    }

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    if (enAppType == USIMM_CDMA_APP)
    {
        for (i = 0; i < g_aenAtCsimFileNumToIdTabLen; i++)
        {
            if (gastAtParaList[0].ulParaValue == g_aenAtCsimFileNumToIdTab[i].ulFileNum)
            {
                enFileId    = g_aenAtCsimFileNumToIdTab[i].enFileId;

                ucFoundFlag =  VOS_TRUE;
                break;
            }
        }
    }
#endif


    if ( ucFoundFlag == VOS_FALSE )
    {
        return AT_ERROR;
    }

    if (USIMM_ChangeDefFileToPath(enFileId, &pucFilePathStr) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 文件路径长度保护 */
    ulPathLength = VOS_StrLen(pucFilePathStr);
    if (ulPathLength == 0)
    {
        return AT_ERROR;
    }

    ulMsgLength = (sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH)
            + (gastAtParaList[1].usParaLen - 3 * sizeof(VOS_UINT8));

    if (ulMsgLength < (sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH))
    {
        ulMsgLength = sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH;
    }

    pstMsg = (USIMM_UPDATEFILE_REQ_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT, ulMsgLength);
    if (pstMsg == VOS_NULL_PTR)
    {
        return AT_ERROR;
    }

    memset_s(pstMsg, ulMsgLength + VOS_MSG_HEAD_LENGTH, 0x00, ulMsgLength + VOS_MSG_HEAD_LENGTH);

    pstMsg->stMsgHeader.ulSenderCpuId   = VOS_LOCAL_CPUID;
    pstMsg->stMsgHeader.ulSenderPid     = WUEPS_PID_AT;
    pstMsg->stMsgHeader.ulReceiverCpuId = VOS_LOCAL_CPUID;
    pstMsg->stMsgHeader.ulReceiverPid   = WUEPS_PID_USIM;
    if (enModemId == MODEM_ID_1)
    {
        pstMsg->stMsgHeader.ulReceiverPid   = I1_WUEPS_PID_USIM;
    }

    pstMsg->stMsgHeader.ulLength        = ulMsgLength;
    pstMsg->stMsgHeader.enMsgName       = USIMM_UPDATEFILE_REQ;
    pstMsg->stMsgHeader.enAppType       = enAppType;
    pstMsg->stMsgHeader.ulSendPara      = 0;
    pstMsg->stFilePath.ulPathLen        = ulPathLength;
    lMemResult = memcpy_s(pstMsg->stFilePath.acPath, sizeof(pstMsg->stFilePath.acPath), pucFilePathStr, pstMsg->stFilePath.ulPathLen + 1);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstMsg->stFilePath.acPath), pstMsg->stFilePath.ulPathLen + 1);
    pstMsg->usDataLen                   = gastAtParaList[1].usParaLen;
    pstMsg->ucRecordNum                 = ucRecordNum;
    lMemResult = memcpy_s(pstMsg->aucContent, gastAtParaList[1].usParaLen, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, gastAtParaList[1].usParaLen, gastAtParaList[1].usParaLen);

    /* 调用VOS发送原语 */
    if (PS_SEND_MSG(WUEPS_PID_AT, pstMsg) != VOS_OK)
    {
        return AT_ERROR;
    }

    if (gastAtParaList[0].ulParaValue == 0x6F07)
    {
       memset_s(&stCMDDetail, sizeof(stCMDDetail), 0x00, sizeof(USIMM_STK_COMMAND_DETAILS_STRU));

        stCMDDetail.ucCommandQua    = USIMM_RESET;
        stCMDDetail.ucCommandNum    = 1;
        stCMDDetail.ucCommandType   = 1;

        memset_s(&stRstInfo, sizeof(stRstInfo), 0x00, sizeof(stRstInfo));

        /* 分配消息内存并初始化 */
        ulMsgLength = sizeof(USIMM_STKREFRESH_REQ_STRU) - VOS_MSG_HEAD_LENGTH;
        pstRefreshMsg = (USIMM_STKREFRESH_REQ_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT, ulMsgLength);
        if (pstRefreshMsg == VOS_NULL_PTR)
        {
            return AT_ERROR;
        }

        memset_s(pstRefreshMsg, sizeof(USIMM_STKREFRESH_REQ_STRU), 0x00, sizeof(USIMM_STKREFRESH_REQ_STRU));

        /* 填写消息头 */
        pstRefreshMsg->stMsgHeader.ulSenderCpuId   = VOS_LOCAL_CPUID;
        pstRefreshMsg->stMsgHeader.ulSenderPid     = WUEPS_PID_AT;
        pstRefreshMsg->stMsgHeader.ulReceiverCpuId = VOS_LOCAL_CPUID;
        pstRefreshMsg->stMsgHeader.ulReceiverPid   = WUEPS_PID_USIM;
        if (enModemId == MODEM_ID_1)
        {
            pstRefreshMsg->stMsgHeader.ulReceiverPid   = I1_WUEPS_PID_USIM;
        }
        pstRefreshMsg->stMsgHeader.ulLength        = ulMsgLength;

        pstRefreshMsg->stMsgHeader.enMsgName       = USIMM_STKREFRESH_REQ;
        pstRefreshMsg->stMsgHeader.ulSendPara      = 0;
        pstRefreshMsg->stMsgHeader.enAppType       = USIMM_GUTL_APP;

        /* 填写消息体 */
        pstRefreshMsg->ulCommandNum                = stCMDDetail.ucCommandNum;
        pstRefreshMsg->ulCommandType               = stCMDDetail.ucCommandType;
        pstRefreshMsg->enRefreshType               = stCMDDetail.ucCommandQua;

        /* 调用VOS发送原语 */
        if (PS_SEND_MSG(WUEPS_PID_AT, pstRefreshMsg) != VOS_OK)
        {
            return AT_ERROR;
        }
    }

    return AT_OK;
}

TAF_UINT32 AT_SetSIMPara(TAF_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    USIMM_STK_COMMAND_DETAILS_STRU      stCMDDetail;
    VOS_UINT8                           ucRecordNum;
    USIMM_RESET_INFO_STRU               stRstInfo;
    USIMM_UPDATEFILE_REQ_STRU          *pstMsg          = VOS_NULL_PTR;
    USIMM_STKREFRESH_REQ_STRU          *pstRefreshMsg   = VOS_NULL_PTR;
    VOS_UINT32                          ulPathLength;
    VOS_UINT32                          ulMsgLength;
    VOS_CHAR                           *pucFilePathStr  = VOS_NULL_PTR;
    USIMM_DEF_FILEID_ENUM_UINT32        enFileId;
    VOS_UINT32                          i;
    VOS_UINT8                           ucFoundFlag;

    ulPathLength                        = 0;
    ulMsgLength                         = 0;

    ucRecordNum = 0;

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(gastAtParaList[1].aucPara, &gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex == 3)
    {
        ucRecordNum = gastAtParaList[2].ulParaValue;
    }

    /* 当读到AT&T & DCM的定制需求更新0x4F36和0x4F34文件时，要设置enAppType */
    /* 文件Id转文件路径 */
    ucFoundFlag = VOS_FALSE;
    for (i = 0; i < g_aenAtSimFileNumToIdTabLen; i++)
    {
        if (gastAtParaList[0].ulParaValue == g_aenAtSimFileNumToIdTab[i].ulFileNum)
        {
            enFileId    = g_aenAtSimFileNumToIdTab[i].enFileId;
            ucFoundFlag =  VOS_TRUE;
            break;
        }
    }

    if ( ucFoundFlag == VOS_FALSE )
    {
        return AT_ERROR;
    }

    if (USIMM_ChangeDefFileToPath(enFileId, &pucFilePathStr) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 文件路径长度保护 */
    ulPathLength = VOS_StrLen(pucFilePathStr);
    if (ulPathLength == 0)
    {
        return AT_ERROR;
    }

    ulMsgLength = (sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH)
            + (gastAtParaList[1].usParaLen - 3 * sizeof(VOS_UINT8));

    if (ulMsgLength < (sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH))
    {
        ulMsgLength = (sizeof(USIMM_UPDATEFILE_REQ_STRU) - VOS_MSG_HEAD_LENGTH);
    }

    pstMsg = (USIMM_UPDATEFILE_REQ_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT, ulMsgLength);
    if (pstMsg == VOS_NULL_PTR)
    {
        return AT_ERROR;
    }

    memset_s(pstMsg, ulMsgLength + VOS_MSG_HEAD_LENGTH, 0x00, ulMsgLength + VOS_MSG_HEAD_LENGTH);

    pstMsg->stMsgHeader.ulSenderCpuId   = VOS_LOCAL_CPUID;
    pstMsg->stMsgHeader.ulSenderPid     = WUEPS_PID_AT;
    pstMsg->stMsgHeader.ulReceiverCpuId = VOS_LOCAL_CPUID;
    pstMsg->stMsgHeader.ulReceiverPid   = WUEPS_PID_USIM;
    pstMsg->stMsgHeader.ulLength        = ulMsgLength;
    pstMsg->stMsgHeader.enMsgName       = USIMM_UPDATEFILE_REQ;
    pstMsg->stMsgHeader.enAppType       = USIMM_GUTL_APP;
    pstMsg->stMsgHeader.ulSendPara      = 0;
    pstMsg->stFilePath.ulPathLen        = ulPathLength;
    lMemResult = memcpy_s(pstMsg->stFilePath.acPath, sizeof(pstMsg->stFilePath.acPath), pucFilePathStr, pstMsg->stFilePath.ulPathLen + 1);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstMsg->stFilePath.acPath), pstMsg->stFilePath.ulPathLen + 1);
    pstMsg->usDataLen                   = gastAtParaList[1].usParaLen;
    pstMsg->ucRecordNum                 = ucRecordNum;
    lMemResult = memcpy_s(pstMsg->aucContent, gastAtParaList[1].usParaLen, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, gastAtParaList[1].usParaLen, gastAtParaList[1].usParaLen);

    /* 调用VOS发送原语 */
    if (PS_SEND_MSG(WUEPS_PID_AT, pstMsg) != VOS_OK)
    {
        return AT_ERROR;
    }

    if (gastAtParaList[0].ulParaValue == 0x6F07)
    {
        memset_s(&stCMDDetail, sizeof(stCMDDetail), 0x00, sizeof(USIMM_STK_COMMAND_DETAILS_STRU));

        stCMDDetail.ucCommandQua    = USIMM_RESET;
        stCMDDetail.ucCommandNum    = 1;
        stCMDDetail.ucCommandType   = 1;

        memset_s(&stRstInfo, sizeof(stRstInfo), 0x00, sizeof(stRstInfo));

        /* 分配消息内存并初始化 */
        ulMsgLength = sizeof(USIMM_STKREFRESH_REQ_STRU) - VOS_MSG_HEAD_LENGTH;
        pstRefreshMsg = (USIMM_STKREFRESH_REQ_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT, ulMsgLength);
        if (pstRefreshMsg == VOS_NULL_PTR)
        {
            return AT_ERROR;
        }

        memset_s(pstRefreshMsg, sizeof(USIMM_STKREFRESH_REQ_STRU), 0x00, sizeof(USIMM_STKREFRESH_REQ_STRU));

        /* 填写消息头 */
        pstRefreshMsg->stMsgHeader.ulSenderCpuId   = VOS_LOCAL_CPUID;
        pstRefreshMsg->stMsgHeader.ulSenderPid     = WUEPS_PID_AT;
        pstRefreshMsg->stMsgHeader.ulReceiverCpuId = VOS_LOCAL_CPUID;
        pstRefreshMsg->stMsgHeader.ulReceiverPid   = WUEPS_PID_USIM;
        pstRefreshMsg->stMsgHeader.ulLength        = ulMsgLength;

        pstRefreshMsg->stMsgHeader.enMsgName       = USIMM_STKREFRESH_REQ;
        pstRefreshMsg->stMsgHeader.ulSendPara      = 0;
        pstRefreshMsg->stMsgHeader.enAppType       = USIMM_GUTL_APP;

        /* 填写消息体 */
        pstRefreshMsg->ulCommandNum                = stCMDDetail.ucCommandNum;
        pstRefreshMsg->ulCommandType               = stCMDDetail.ucCommandType;
        pstRefreshMsg->enRefreshType               = stCMDDetail.ucCommandQua;

        /* 调用VOS发送原语 */
        if (PS_SEND_MSG(WUEPS_PID_AT, pstRefreshMsg) != VOS_OK)
        {
            return AT_ERROR;
        }
    }

    return AT_OK;
}


/* AT_SetSTKParaStub无调用点，删除 */


VOS_UINT32 AT_RefreshUSIMPara(VOS_UINT8 ucIndex)
{
    USIMM_STKREFRESH_IND_STRU          *pstMmcUsimRefreshMsg = VOS_NULL_PTR;
    USIMM_STKREFRESH_IND_STRU          *pstMmaUsimRefreshMsg = VOS_NULL_PTR;
    VOS_UINT32                          ulRslt;

    /* 参数检查 */
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(gastAtParaList[1].aucPara, &gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 申请内存  */
    pstMmcUsimRefreshMsg = (USIMM_STKREFRESH_IND_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT,
                                               sizeof(USIMM_STKREFRESH_IND_STRU) - VOS_MSG_HEAD_LENGTH);

    if ( pstMmcUsimRefreshMsg == VOS_NULL_PTR )
    {
        /* 内存申请失败 */
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR: Memory Alloc Error for pstMsg");
        return VOS_ERR;
    }

    /* 模拟USIM给MMC模块发送消息 */
    pstMmcUsimRefreshMsg->stIndHdr.enMsgName        = USIMM_STKREFRESH_IND;
    pstMmcUsimRefreshMsg->astEfId[0].usFileId       = gastAtParaList[0].ulParaValue;
    pstMmcUsimRefreshMsg->usEfNum                   = 1;
    pstMmcUsimRefreshMsg->enRefreshType             = USIMM_REFRESH_FILE_LIST;

    /* 填写相关参数 */
    pstMmcUsimRefreshMsg->stIndHdr.ulSenderPid      = MAPS_PIH_PID;
    pstMmcUsimRefreshMsg->stIndHdr.ulReceiverPid    = AT_GetDestPid(ucIndex, I0_WUEPS_PID_MMC);
    pstMmcUsimRefreshMsg->stIndHdr.ulLength             = sizeof(USIMM_STKREFRESH_IND_STRU) - VOS_MSG_HEAD_LENGTH;

    /* 调用VOS发送原语 */
    ulRslt = PS_SEND_MSG(WUEPS_PID_AT, pstMmcUsimRefreshMsg);

    if ( ulRslt != VOS_OK )
    {
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR:PS_SEND_MSG ");
        return VOS_ERR;
    }

    /* 申请内存  */
    pstMmaUsimRefreshMsg = (USIMM_STKREFRESH_IND_STRU *)PS_ALLOC_MSG(WUEPS_PID_AT,
                                               sizeof(USIMM_STKREFRESH_IND_STRU) - VOS_MSG_HEAD_LENGTH);

    if ( pstMmaUsimRefreshMsg == VOS_NULL_PTR )
    {
        /* 内存申请失败 */
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR: Memory Alloc Error for pstMsg");
        return VOS_ERR;
    }

    /* 模拟USIM给MMA模块发送消息 */
    pstMmaUsimRefreshMsg->stIndHdr.enMsgName        = USIMM_STKREFRESH_IND;
    pstMmaUsimRefreshMsg->astEfId[0].usFileId       = gastAtParaList[0].ulParaValue;
    pstMmaUsimRefreshMsg->usEfNum                   = 1;
    pstMmaUsimRefreshMsg->enRefreshType             = USIMM_REFRESH_FILE_LIST;

    /* 填写相关参数 */
    pstMmaUsimRefreshMsg->stIndHdr.ulSenderPid      = MAPS_PIH_PID;
    pstMmaUsimRefreshMsg->stIndHdr.ulReceiverPid    = AT_GetDestPid(ucIndex, I0_WUEPS_PID_MMA);
    pstMmaUsimRefreshMsg->stIndHdr.ulLength         = sizeof(USIMM_STKREFRESH_IND_STRU) - VOS_MSG_HEAD_LENGTH;


    /* 调用VOS发送原语 */
    ulRslt = PS_SEND_MSG(WUEPS_PID_AT, pstMmaUsimRefreshMsg);

    if ( ulRslt != VOS_OK )
    {
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR:PS_SEND_MSG ");
        return VOS_ERR;
    }

    return AT_OK;
}
#endif


/* begin V7R1 PhaseI Modify */

VOS_UINT32 At_SetSystemInfoEx(TAF_UINT8 ucIndex)
{
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(TAF_MMA_QrySystemInfoReq(WUEPS_PID_AT,
                                gastAtClientTab[ucIndex].usClientId,
                                0,
                                VOS_TRUE) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SYSINFOEX_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}
/* end V7R1 PhaseI Modify */

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 At_Set5gOptionPara(TAF_UINT8 ucIndex)
{
    AT_MTA_SET_5G_OPTION_REQ_STRU       stOption5G;
    VOS_UINT32                          ulRst;

    memset_s(&stOption5G, sizeof(stOption5G), 0x00, sizeof(stOption5G));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0) ||
        (gastAtParaList[1].usParaLen == 0) ||
        (gastAtParaList[2].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stOption5G.ucNrSaSupportFlag = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stOption5G.enNrDcMode        = (AT_MTA_NR_DC_MODE_ENUM_UINT8)gastAtParaList[1].ulParaValue;
    stOption5G.en5gcAccessMode   = (AT_MTA_5GC_ACCESS_MODE_ENUM_UINT8)gastAtParaList[2].ulParaValue;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_5G_OPTION_CFG_REQ,
                                   &stOption5G,
                                   sizeof(AT_MTA_SET_5G_OPTION_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_5G_OPTION_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_Qry5gOptionPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_READ_CMD)
    {
        return AT_ERROR;
    }

    /* 发送消息*/
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_5G_OPTION_QRY_REQ,
                                      VOS_NULL_PTR,
                                      0,
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("At_Qry5gOptionPara: WARNINT: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_5G_OPTION_QRY;

    return AT_WAIT_ASYNC_RETURN;
}
#endif

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetGodloadPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRet;

    /* 参数检查 */
    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("AT_SetGodloadPara: too many parameters.");
        return AT_ERROR;
    }

    /* 发消息到C核指示使单板进入下载模式 */
    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_GODLOAD_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetApbatlvlPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_GODLOAD_SET;
    return AT_WAIT_ASYNC_RETURN;

}
#endif

VOS_UINT32 At_SetResetPara( VOS_UINT8 ucIndex  )
{
    VOS_UINT8                           ucUpdateFlag;
    VOS_UINT32                          ulRslt;

    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("At_SetResetPara: too many parameters.");
        return AT_ERROR;
    }

    /* 先返回OK */
    At_FormatResultData(ucIndex,AT_OK);

    /* B31版本升级工具切换后，下发AT^RESET命令后来不及把OK回复给PC，需要增加延时，延时500ms */
    VOS_TaskDelay(500);

    /* 发送消息到C核，重启 */
    ucUpdateFlag = VOS_FALSE;

    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    DRV_AGENT_TMODE_SET_REQ,
                                    &ucUpdateFlag,
                                    sizeof(ucUpdateFlag),
                                    I0_WUEPS_PID_DRV_AGENT);
    if (ulRslt != VOS_OK)
    {
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetNvBackUpPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    AT_PR_LOGI("Rcv Msg");

    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("AT_SetNvBackUpPara: too many parameters.");
        return AT_ERROR;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_NVBACKUP_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        AT_PR_LOGI("Snd Msg");

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NVBACKUP_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetNvManufactureExtPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("AT_SetNvManufactureExtPara: too many parameters.");
        return AT_ERROR;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_NVMANUFACTUREEXT_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NVMANUFACTUREEXT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetNvRestorePara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                 ulRst;

    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("At_SetNvRestorePara: too many parameters.");
        return AT_ERROR;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_NVRESTORE_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NVRESTORE_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32  AT_SetNvRststtsPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulRst;

    if (gucAtParaIndex != 0)
    {
        AT_WARN_LOG("AT_SetNvRststtsPara: too many parameters.");
        return AT_ERROR;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   DRV_AGENT_NVRSTSTTS_QRY_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NVRSTSTTS_READ;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

VOS_UINT32 AT_SetWiFiEnablePara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;

    ulRst = VOS_OK;

    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].ulParaValue == 0 )
    {
        /*关闭WIFI*/
        ulRst = (VOS_UINT32)WIFI_POWER_SHUTDOWN();
    }
    else if (gastAtParaList[0].ulParaValue == 1 )
    {
    }
    else
    {
#if(FEATURE_LTE == FEATURE_ON)

        VOS_TaskDelay(5500);    /* 按底软要求需要5.5s秒延迟 */

#endif

        if ( WIFI_POWER_SHUTDOWN() != VOS_OK)
        {
            return AT_ERROR;
        }

#if(FEATURE_LTE == FEATURE_ON)

        VOS_TaskDelay(1000);    /* 按底软要求需要1秒延迟 */

#endif


        /*测试模式打开WIFI*/
        ulRst = (VOS_UINT32)WIFI_POWER_START();
    }

    if (ulRst != VOS_OK)
    {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetWiFiModePara(VOS_UINT8 ucIndex)
{
    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }

    WIFI_TEST_CMD("wl down");

    if (gastAtParaList[0].ulParaValue == AT_WIFI_SUPPORT_MODE_B)
    {
        WIFI_TEST_CMD("wl nmode 0");
        WIFI_TEST_CMD("wl gmode 0");
    }
    else if (gastAtParaList[0].ulParaValue == AT_WIFI_SUPPORT_MODE_G)
    {
        WIFI_TEST_CMD("wl nmode 0");
        WIFI_TEST_CMD("wl gmode 2");
    }
    else
    {
        WIFI_TEST_CMD("wl nmode 1");
        WIFI_TEST_CMD("wl gmode 1");
    }

    WIFI_TEST_CMD("wl up");

    /*保存全局变量里，已备查询*/
    g_ulWifiMode = gastAtParaList[0].ulParaValue;

    return AT_OK;
}


VOS_UINT32 AT_SetWiFiBandPara(VOS_UINT8 ucIndex)
{

    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /*目前Wifi只支持20M，40M返回ERROR*/
    if(gastAtParaList[0].ulParaValue != AT_WIFI_BAND_20M)
    {
        return AT_ERROR;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetWiFiFreqPara(VOS_UINT8 ucIndex)
{
    VOS_CHAR                            acCmd[200]={0};
    VOS_UINT32                          ulWifiFreq;
    VOS_UINT32                          i;
    VOS_UINT32                          aulChannel[] = {2412,2417,2422,2427,2432,
                                                        2437,2442,2447,2452,2457,
                                                        2462,2467,2472,2484};

    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /* 计算信道  */
    ulWifiFreq = 0;
    for (i=0; i<(sizeof(aulChannel)/sizeof(VOS_UINT32)); i++)
    {
        if (gastAtParaList[0].ulParaValue == aulChannel[i])
        {
            ulWifiFreq = (i+1);
            break;
        }
    }

    if (ulWifiFreq == 0)
    {
        AT_WARN_LOG("AT_SetWiFiFreqPara: freq ERROR");
        return AT_ERROR;
    }

    /* 调用底软接口 */
    WIFI_TEST_CMD("wl down");

    VOS_sprintf_s(acCmd, sizeof(acCmd), "wl channel %d", ulWifiFreq);
    WIFI_TEST_CMD(acCmd);

    WIFI_TEST_CMD("wl up");

    /* 保存全局变量里，已备查询 */
    g_ulWifiFreq = ulWifiFreq;

    return AT_OK;
}


VOS_UINT32 AT_TransferWifiRate(
    VOS_UINT32                          ulInRate,
    VOS_UINT32                         *pulOutRate
)
{
    VOS_UINT8                           ucIndex;
    /* WIFI n模式 AT^WIDATARATE设置的速率值和WL命令速率值的对应表 */
    VOS_UINT32                          aucAtWifiNRate_Table[AT_WIFI_N_RATE_NUM] = {650, 1300, 1950, 2600, 3900, 5200, 5850, 6500};

    for (ucIndex = 0; ucIndex < AT_WIFI_N_RATE_NUM; ucIndex++)
    {
        if (aucAtWifiNRate_Table[ucIndex] == ulInRate)
        {
            *pulOutRate = ucIndex;
            break;
        }
    }

    if (ucIndex >= AT_WIFI_N_RATE_NUM)
    {
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetWiFiRatePara(VOS_UINT8 ucIndex)
{
    VOS_CHAR                            acCmd[200]={0};
    VOS_UINT32                          ulWifiRate;

#if(FEATURE_LTE == FEATURE_ON)
#else
    VOS_UINT32                          ulNRate;
    VOS_UINT32                          ulRslt;
#endif
    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    ulWifiRate = gastAtParaList[0].ulParaValue/100;


    if (g_ulWifiMode == AT_WIFI_SUPPORT_MODE_N)         /*11 n*/
    {
#if(FEATURE_LTE == FEATURE_ON)
        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl nrate -m %d", 7);
#else
        ulRslt = AT_TransferWifiRate(gastAtParaList[0].ulParaValue, &ulNRate);

        if (ulRslt == VOS_OK)
        {
            VOS_sprintf_s(acCmd, sizeof(acCmd), "wl nrate -m %d", ulNRate);
        }
        else
        {
            return AT_ERROR;
        }
#endif
    }
    else if (g_ulWifiMode == AT_WIFI_SUPPORT_MODE_G )    /*11 g*/
    {
#if(FEATURE_LTE == FEATURE_ON)
        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl bg_rate %d", ulWifiRate);
#else
        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl rate %d", ulWifiRate);
#endif
    }
    else if(g_ulWifiMode == AT_WIFI_SUPPORT_MODE_B)    /*11 b*/
    {
#if(FEATURE_LTE == FEATURE_ON)
        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl bg_rate %d", ulWifiRate);
#else
        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl rate %d", ulWifiRate);
#endif
    }
    else
    {
        AT_WARN_LOG("AT_SetWiFiRatePara: wifimode ERROR");
        return AT_ERROR;
    }

    WIFI_TEST_CMD(acCmd);


    /*保存全局变量里，已备查询*/
    g_ulWifiRate = gastAtParaList[0].ulParaValue;

    return AT_OK;
}

VOS_UINT32 AT_SetWiFiPowerPara(VOS_UINT8 ucIndex)
{
    VOS_CHAR                            acCmd[200]={0};
    VOS_INT32                           lWifiPower;

    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }

    g_lWifiPower = (VOS_INT32)gastAtParaList[0].ulParaValue;

    lWifiPower = g_lWifiPower/100;

    if (lWifiPower < AT_WIFI_POWER_MIN)
    {
        lWifiPower = AT_WIFI_POWER_MIN;
    }

    if (lWifiPower > AT_WIFI_POWER_MAX)
    {
        lWifiPower = AT_WIFI_POWER_MAX;
    }

    VOS_sprintf_s(acCmd, sizeof(acCmd), "wl txpwr1 -o -d %d", lWifiPower);

    /*调用底软接口*/
    WIFI_TEST_CMD(acCmd);


    return AT_OK;
}



VOS_UINT32 AT_SetWiFiTxPara(VOS_UINT8 ucIndex)
{
#if(FEATURE_LTE == FEATURE_ON)
    VOS_CHAR                            acCmd[200]={0};
#endif

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }
#if(FEATURE_LTE == FEATURE_ON)
    if(g_ulWifiMode == AT_WIFI_SUPPORT_MODE_CW)
    {
        if (gastAtParaList[0].ulParaValue == AT_WIFI_TX_OFF)
        {
            WIFI_TEST_CMD("wl fqacurcy 0");
        }
        else
        {
            WIFI_TEST_CMD("wl up");
            WIFI_TEST_CMD("wl band b");
            WIFI_TEST_CMD("wl out");
            WIFI_TEST_CMD("wl phy_txpwrctrl 0");

            if(g_ulWifiRF == 0)
            {
                WIFI_TEST_CMD("wl phy_txpwrindex 0 127");
            }
            else
            {
                WIFI_TEST_CMD("wl phy_txpwrindex 127 0");
            }

            WIFI_TEST_CMD("wl phy_txpwrctrl 1");

            VOS_sprintf_s(acCmd, sizeof(acCmd), "wl fqacurcy %d", g_ulWifiFreq);

            WIFI_TEST_CMD(acCmd);

        }
    }
    else
    {
#endif
    /* 参数为零关闭发射机，参数为1打开发射机 */
    if (gastAtParaList[0].ulParaValue == AT_WIFI_TX_OFF)
    {
         WIFI_TEST_CMD("wl pkteng_stop tx");
    }
    else
    {
        /* 调用底软接口 */
        WIFI_TEST_CMD("wl down");

        WIFI_TEST_CMD("wl mpc 0");

        WIFI_TEST_CMD("wl country ALL");

        WIFI_TEST_CMD("wl frameburst 1");

        WIFI_TEST_CMD("wl scansuppress 1");

        WIFI_TEST_CMD("wl up");

        WIFI_TEST_CMD("wl pkteng_start 00:11:22:33:44:55 tx 100 1500 0");

#if(FEATURE_LTE == FEATURE_ON)
        WIFI_TEST_CMD("wl phy_forcecal 1");
#endif
    }
#if(FEATURE_LTE == FEATURE_ON)
    }
#endif
    return AT_OK;
}


VOS_UINT32 AT_SetWiFiRxPara(VOS_UINT8 ucIndex)
{
    VOS_CHAR                            acCmd[200]={0};

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /* 参数过多*/
    if (gucAtParaIndex > 3)
    {
        return  AT_TOO_MANY_PARA;
    }

    /*参数为零关闭接收机，参数为1打开接收机*/
    if ( gastAtParaList[0].ulParaValue == AT_WIFI_RX_OFF)
    {
        /* 调用驱动关闭接收机 */
        WIFI_TEST_CMD("wl pkteng_stop rx");
    }
    else
    {
        WIFI_TEST_CMD("wl down");

        WIFI_TEST_CMD("wl mpc 0");

        WIFI_TEST_CMD("wl country ALL");

        WIFI_TEST_CMD("wl frameburst 1");

        WIFI_TEST_CMD("wl scansuppress 1");


        WIFI_TEST_CMD("wl up");

        VOS_sprintf_s(acCmd, sizeof(acCmd), "wl pkteng_start %c%c:%c%c:%c%c:%c%c:%c%c:%c%c rx async 0 0",
                    gastAtParaList[1].aucPara[0],gastAtParaList[1].aucPara[1],
                    gastAtParaList[1].aucPara[2],gastAtParaList[1].aucPara[3],
                    gastAtParaList[1].aucPara[4],gastAtParaList[1].aucPara[5],
                    gastAtParaList[1].aucPara[6],gastAtParaList[1].aucPara[7],
                    gastAtParaList[1].aucPara[8],gastAtParaList[1].aucPara[9],
                    gastAtParaList[1].aucPara[10],gastAtParaList[1].aucPara[11]);

        WIFI_TEST_CMD(acCmd);

        WIFI_GET_RX_PACKET_REPORT(&g_ulUcastWifiRxPkts,  &g_ulMcastWifiRxPkts);


    }

    return AT_OK;
}

VOS_UINT32 AT_SetWiFiPacketPara(VOS_UINT8 ucIndex)
{
    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }
    /* 参数过多*/
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }


    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    /* TODO: */
    /* 目前暂用该方式清零 */
    WIFI_GET_RX_PACKET_REPORT(&g_ulUcastWifiRxPkts,  &g_ulMcastWifiRxPkts);


    return AT_OK;
}


VOS_UINT32 AT_SetWiFiLogPara(VOS_UINT8 ucIndex)
{
    TAF_AT_MULTI_WIFI_SSID_STRU         stWifiSsid;
    TAF_AT_MULTI_WIFI_SEC_STRU          stWifiKey;
    errno_t                             lMemResult;

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /* 参数过多*/
    if (gucAtParaIndex > 2)
    {
        return  AT_TOO_MANY_PARA;
    }

    memset_s(&stWifiKey, sizeof(stWifiKey), 0x00, sizeof(stWifiKey));
    memset_s(&stWifiSsid, sizeof(stWifiSsid), 0x00, sizeof(stWifiSsid));

    /*设置WIFI SSID*/
    if (gastAtParaList[0].ulParaValue == 0)
    {
        /*参数长度过长*/
        if (gastAtParaList[1].usParaLen >= AT_WIFI_SSID_LEN_MAX)
        {
            return  AT_CME_INCORRECT_PARAMETERS;
        }

        /*读取WIFI KEY对应的NV项*/
        if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID, &stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetWiFiSsidPara:READ NV ERROR");
            return AT_ERROR;
        }
        else
        {
            memset_s(stWifiSsid.aucWifiSsid[0], AT_WIFI_SSID_LEN_MAX, 0x00, AT_WIFI_SSID_LEN_MAX);

            lMemResult = memcpy_s(stWifiSsid.aucWifiSsid[0], AT_WIFI_SSID_LEN_MAX, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, AT_WIFI_SSID_LEN_MAX, gastAtParaList[1].usParaLen);

            stWifiSsid.aucWifiSsid[0][gastAtParaList[1].usParaLen] = '\0';

            /*写入WIFI SSID对应的NV项*/
            if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID, &stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
            {
                AT_WARN_LOG("AT_SetWiFiSsidPara:WRITE NV ERROR");
                return AT_ERROR;
            }
        }
    }
    else
    {
        /*读取WIFI KEY对应的NV项*/
        if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY, &stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetWiFiKeyPara:READ NV ERROR");
            return AT_ERROR;
        }
        else
        {

            /*参数长度过长*/
            if (gastAtParaList[1].usParaLen >= AT_WIFI_KEY_LEN_MAX)
            {
                return  AT_CME_INCORRECT_PARAMETERS;
            }

            /*根据index写入对应的KEY*/
            switch(stWifiKey.ucWifiWepKeyIndex[0])
            {
                case 0:
                    lMemResult = memcpy_s(stWifiKey.aucWifiWepKey1[0], sizeof(stWifiKey.aucWifiWepKey1), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
                    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stWifiKey.aucWifiWepKey1), gastAtParaList[1].usParaLen);
                    stWifiKey.aucWifiWepKey1[0][gastAtParaList[1].usParaLen] = '\0';
                    break;

                case 1:
                    lMemResult = memcpy_s(stWifiKey.aucWifiWepKey2[0], sizeof(stWifiKey.aucWifiWepKey2), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
                    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stWifiKey.aucWifiWepKey2), gastAtParaList[1].usParaLen);
                    stWifiKey.aucWifiWepKey2[0][gastAtParaList[1].usParaLen] = '\0';
                    break;

                case 2:
                    lMemResult = memcpy_s(stWifiKey.aucWifiWepKey3[0], sizeof(stWifiKey.aucWifiWepKey3), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
                    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stWifiKey.aucWifiWepKey3), gastAtParaList[1].usParaLen);
                    stWifiKey.aucWifiWepKey3[0][gastAtParaList[1].usParaLen] = '\0';
                    break;

                case 3:
                    lMemResult = memcpy_s(stWifiKey.aucWifiWepKey4[0], sizeof(stWifiKey.aucWifiWepKey4), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
                    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stWifiKey.aucWifiWepKey4), gastAtParaList[1].usParaLen);
                    stWifiKey.aucWifiWepKey4[0][gastAtParaList[1].usParaLen] = '\0';
                    break;

                default:
                    break;
            }

            if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY, &stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != VOS_OK)
            {
                AT_WARN_LOG("AT_SetWiFiKeyPara:WRITE NV ERROR");
                return AT_ERROR;
            }
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_SetWiFiSsidPara(VOS_UINT8 ucIndex)
{
    TAF_AT_MULTI_WIFI_SSID_STRU         stWifiSsid;
    errno_t                             lMemResult;
    VOS_UINT8                           ucGroup;

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /* 参数过多*/
    if (gucAtParaIndex > 2)
    {
        return  AT_TOO_MANY_PARA;
    }

    /*参数长度过长*/
    if (gastAtParaList[1].usParaLen >= AT_WIFI_SSID_LEN_MAX)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    /* SSID最多4组 */
    if (gastAtParaList[0].ulParaValue >= AT_WIFI_MAX_SSID_NUM)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_bAtDataLocked == VOS_TRUE)
    {
        return AT_ERROR;
    }

    memset_s(&stWifiSsid, sizeof(stWifiSsid), 0x00, sizeof(stWifiSsid));

    ucGroup = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /*读取WIFI KEY对应的NV项*/
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID,&stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
    {
        AT_WARN_LOG("AT_SetWiFiSsidPara:READ NV ERROR");
        return AT_ERROR;
    }
    else
    {
        lMemResult = memcpy_s(&(stWifiSsid.aucWifiSsid[ucGroup][0]), AT_WIFI_SSID_LEN_MAX, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, AT_WIFI_SSID_LEN_MAX, gastAtParaList[1].usParaLen);
        stWifiSsid.aucWifiSsid[ucGroup][gastAtParaList[1].usParaLen] = '\0';

        /*写入WIFI SSID对应的NV项*/
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_STATUS_SSID,&stWifiSsid, sizeof(TAF_AT_MULTI_WIFI_SSID_STRU)) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetWiFiSsidPara:WRITE NV ERROR");
            return AT_ERROR;
        }
    }

    return AT_OK;
}

VOS_UINT32 AT_SetWiFiKeyPara(VOS_UINT8 ucIndex)
{
    TAF_AT_MULTI_WIFI_SEC_STRU          stWifiKey;
    errno_t                             lMemResult;
    VOS_UINT8                           ucGroup;

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return  AT_TOO_MANY_PARA;
    }

    /* 参数长度过长 */
    if (gastAtParaList[1].usParaLen > AT_WIFI_WLWPAPSK_LEN)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_bAtDataLocked == VOS_TRUE)
    {
        return AT_ERROR;
    }

    /* 做多4组SSID */
    if (gastAtParaList[0].ulParaValue >= AT_WIFI_MAX_SSID_NUM)
    {
       return  AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stWifiKey, sizeof(stWifiKey), 0x00, sizeof(stWifiKey));

    ucGroup = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 读取WIFI KEY对应的NV项 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY,&stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != NV_OK)
    {
        AT_WARN_LOG("AT_SetWiFiKeyPara:READ NV ERROR");
        return AT_ERROR;
    }
    else
    {
        /* 写入KEY */
        lMemResult = memcpy_s(&(stWifiKey.aucWifiWpapsk[ucGroup][0]), AT_WIFI_WLWPAPSK_LEN, gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, AT_WIFI_WLWPAPSK_LEN, gastAtParaList[1].usParaLen);
        stWifiKey.aucWifiWpapsk[ucGroup][gastAtParaList[1].usParaLen] = '\0';


        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_MULTI_WIFI_KEY, &stWifiKey, sizeof(TAF_AT_MULTI_WIFI_SEC_STRU)) != NV_OK)
        {
            AT_WARN_LOG("AT_SetWiFiKeyPara:WRITE NV ERROR");
            return AT_ERROR;
        }
    }


    return AT_OK;
}


VOS_VOID AT_PrintWifiChannelInfo(
    AT_WIFI_INFO_STRU                  *pstWifiInfo,
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulLoopIndex;
    VOS_UINT16                          usLength;

    /* 初始化 */
    ulLoopIndex                         = 0;
    usLength                            = gstAtSendData.usBufLen;


    /* 单板支持802.11b制式, 输出802.11b制式支持的信道号 */
    if (pstWifiInfo->bitOpbSupport == VOS_TRUE)
    {
        usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                           "%s:%s",
                                           g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                           "b");

        pstWifiInfo->usbLowChannel  = AT_MIN(pstWifiInfo->usbLowChannel, AT_WIFI_CHANNEL_MAX_NUM);
        pstWifiInfo->usbHighChannel = AT_MIN(pstWifiInfo->usbHighChannel, AT_WIFI_CHANNEL_MAX_NUM);
        for (ulLoopIndex = pstWifiInfo->usbLowChannel; ulLoopIndex <= pstWifiInfo->usbHighChannel; ulLoopIndex++)
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                               (VOS_CHAR *)pgucAtSndCodeAddr,
                                               (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                               ",%d",
                                               ulLoopIndex);
        }
        if ( (pstWifiInfo->bitOpgSupport == VOS_TRUE)
          || (pstWifiInfo->bitOpnSupport == VOS_TRUE) )
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                               (VOS_CHAR *)pgucAtSndCodeAddr,
                                               (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                               "%s",gaucAtCrLf);
        }
    }

    /* 单板支持802.11g制式, 输出802.11g制式支持的信道号 */
    if (pstWifiInfo->bitOpgSupport == VOS_TRUE)
    {
        usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                           "%s:%s",
                                           g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                           "g");

        pstWifiInfo->usgLowChannel  = AT_MIN(pstWifiInfo->usgLowChannel, AT_WIFI_CHANNEL_MAX_NUM);
        pstWifiInfo->usgHighChannel = AT_MIN(pstWifiInfo->usgHighChannel, AT_WIFI_CHANNEL_MAX_NUM);
        for (ulLoopIndex = pstWifiInfo->usgLowChannel; ulLoopIndex <= pstWifiInfo->usgHighChannel; ulLoopIndex++)
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                               (VOS_CHAR *)pgucAtSndCodeAddr,
                                               (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                               ",%d",
                                               ulLoopIndex);
        }
        if (pstWifiInfo->bitOpnSupport == VOS_TRUE)
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                               (VOS_CHAR *)pgucAtSndCodeAddr,
                                               (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                               "%s",gaucAtCrLf);
        }
    }

    /* 单板支持802.11n制式, 输出802.11n制式支持的信道号 */
    if (pstWifiInfo->bitOpnSupport == VOS_TRUE)
    {
        usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                           "%s:%s",
                                           g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                           "n");

        pstWifiInfo->usnLowChannel  = AT_MIN(pstWifiInfo->usnLowChannel, AT_WIFI_CHANNEL_MAX_NUM);
        pstWifiInfo->usnHighChannel = AT_MIN(pstWifiInfo->usnHighChannel, AT_WIFI_CHANNEL_MAX_NUM);
        for (ulLoopIndex = pstWifiInfo->usnLowChannel; ulLoopIndex <= pstWifiInfo->usnHighChannel; ulLoopIndex++)
        {
            usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                               (VOS_CHAR *)pgucAtSndCodeAddr,
                                               (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                               ",%d",
                                               ulLoopIndex);
        }
    }

    gstAtSendData.usBufLen += usLength;
    return;
}


VOS_VOID AT_PrintWifibPowerInfo(
    AT_WIFI_INFO_STRU                  *pstWifiInfo,
    VOS_UINT8                           ucWifiMode,
    VOS_UINT8                           ucIndex
)
{

    /* 输出802.11b制式期望功率 */
    gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                       "%s:%s",
                                       g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                       "b");
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_PA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausbPower[0]);
    }
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_NOPA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausbPower[1]);
    }
}


VOS_VOID AT_PrintWifigPowerInfo(
    AT_WIFI_INFO_STRU                  *pstWifiInfo,
    VOS_UINT8                           ucWifiMode,
    VOS_UINT8                           ucIndex
)
{

    /* 输出802.11g制式期望功率 */
    gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                       "%s:%s",
                                       g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                       "g");
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_PA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausgPower[0]);
    }
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_NOPA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausgPower[1]);
    }
}


VOS_VOID AT_PrintWifinPowerInfo(
    AT_WIFI_INFO_STRU                  *pstWifiInfo,
    VOS_UINT8                           ucWifiMode,
    VOS_UINT8                           ucIndex
)
{
    /* 输出802.11n制式期望功率 */
    gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                       "%s:%s",
                                       g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                       "n");
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_PA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausnPower[0]);
    }
    if ( (ucWifiMode == AT_WIFI_MODE_ONLY_NOPA)
      || (ucWifiMode == AT_WIFI_MODE_PA_NOPA) )
    {
        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                           (VOS_CHAR *)pgucAtSndCodeAddr,
                                           (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                           ",%d",
                                           pstWifiInfo->ausnPower[1]);
    }
}


VOS_VOID AT_PrintWifiPowerInfo(
    AT_WIFI_INFO_STRU                  *pstWifiInfo,
    VOS_UINT8                           ucIndex
)
{
    AT_WIFI_MODE_ENUM_UINT8             ucWifiMode;

    /* 初始化 */
    ucWifiMode                          = (VOS_UINT8)WIFI_GET_PA_MODE();

    /* 单板支持802.11b制式, 输出期望功率 */
    if (pstWifiInfo->bitOpbSupport == VOS_TRUE)
    {
        AT_PrintWifibPowerInfo(pstWifiInfo, ucWifiMode, ucIndex);
        if ( (pstWifiInfo->bitOpgSupport == VOS_TRUE)
          || (pstWifiInfo->bitOpnSupport == VOS_TRUE) )
        {
            gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                       "%s",gaucAtCrLf);
        }

    }

    /* 单板支持802.11g制式, 输出期望功率 */
    if (pstWifiInfo->bitOpgSupport == VOS_TRUE)
    {
        AT_PrintWifigPowerInfo(pstWifiInfo, ucWifiMode, ucIndex);
        if (pstWifiInfo->bitOpnSupport == VOS_TRUE)
        {
            gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                       (VOS_CHAR *)pgucAtSndCodeAddr,
                                       (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                       "%s",gaucAtCrLf);
        }
    }

    /* 单板支持802.11n制式, 输出期望功率 */
    if (pstWifiInfo->bitOpnSupport == VOS_TRUE)
    {
        AT_PrintWifinPowerInfo(pstWifiInfo, ucWifiMode, ucIndex);
    }

    return;
}


VOS_UINT32 AT_SetWifiInfoPara(VOS_UINT8 ucIndex)
{
#if (FEATURE_LTE == FEATURE_ON)
    VOS_UINT16                          usLen;
    const VOS_CHAR * cString = "1,2,3,4,5,6,7,8,9,10,11,12,13";

    usLen = 0;

    if(gucAtParaIndex > 2)
    {
        return AT_ERROR;
    }

    if(gastAtParaList[0].ulParaValue == 0)
    {
        /* 0,0 */
        if(gastAtParaList[1].ulParaValue == 0)
        {
            usLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                        (TAF_CHAR *)pgucAtSndCodeAddr,
                        (TAF_CHAR *)pgucAtSndCodeAddr + usLen,
                        "^WIINFO:b,%s%s^WIINFO:g,%s%s^WIINFO:n,%s",
                        cString, gaucAtCrLf, cString, gaucAtCrLf, cString);
        }
        else    /* 0,1 */
        {
            usLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                        (TAF_CHAR *)pgucAtSndCodeAddr,
                        (TAF_CHAR *)pgucAtSndCodeAddr + usLen,
                        "^WIINFO:n,%s",
                        cString);
        }
    }
    else
    {
        /* 1,0 */
        if(gastAtParaList[1].ulParaValue == 0)
        {
            usLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                        (TAF_CHAR *)pgucAtSndCodeAddr,
                        (TAF_CHAR *)pgucAtSndCodeAddr + usLen,
                        "^WIINFO:b,130%s^WIINFO:g,80%s^WIINFO:n,80",
                        gaucAtCrLf, gaucAtCrLf);
        }
        else    /* 1,1 */
        {
            usLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                        (TAF_CHAR *)pgucAtSndCodeAddr,
                        (TAF_CHAR *)pgucAtSndCodeAddr + usLen,
                        "^WIINFO:n,80");
        }
    }
    gstAtSendData.usBufLen = usLen;

    return AT_OK;
#else

    AT_WIFI_INFO_STRU                   stWifiInfo = {0};

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }

    /* 初始化 */
    gstAtSendData.usBufLen              = 0;

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_ERROR;
    }

    /*读取WIFI INFO对应的NV项*/
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WIFI_INFO, &stWifiInfo, sizeof(AT_WIFI_INFO_STRU)) != VOS_OK)
    {
        AT_WARN_LOG("AT_SetWifiInfoPara:READ NV ERROR!");
        return AT_ERROR;
    }

    /* 查询支持的信道号或期望功率 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        /* 输出各制式支持的信道号 */
        AT_PrintWifiChannelInfo(&stWifiInfo, ucIndex);
    }
    else
    {
        /* 输出各制式的期望功率 */
        AT_PrintWifiPowerInfo(&stWifiInfo, ucIndex);
    }

    return AT_OK;
#endif
}


VOS_UINT32 AT_SetWifiPaRangePara (VOS_UINT8 ucIndex)
{
    AT_WIFI_MODE_ENUM_UINT8             ucWifiMode;

    /* 初始化 */
    ucWifiMode                          = (VOS_UINT8)WIFI_GET_PA_MODE();

    if (mdrv_misc_support_check(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT )
    {
        return AT_ERROR;
    }


    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    /*参数检查*/
    if (gastAtParaList[0].aucPara[0] == 'h')
    {
        if (ucWifiMode == AT_WIFI_MODE_ONLY_NOPA)
        {
            return AT_ERROR;
        }

        if (WIFI_SET_PA_MODE(AT_WIFI_MODE_ONLY_PA) != VOS_OK)
        {
            return AT_ERROR;
        }
    }
    else if (gastAtParaList[0].aucPara[0] == 'l')
    {
        if (ucWifiMode == AT_WIFI_MODE_ONLY_PA)
        {
            return AT_ERROR;
        }

        if (WIFI_SET_PA_MODE(AT_WIFI_MODE_ONLY_NOPA) != VOS_OK)
        {
            return AT_ERROR;
        }
    }
    else
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}



VOS_UINT32 AT_SetTmmiPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulResult;
    VOS_UINT8                           aucFacInfo[AT_FACTORY_INFO_LEN];

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }


    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }
    memset_s(aucFacInfo, sizeof(aucFacInfo), 0x00, AT_FACTORY_INFO_LEN);

    /* 写入en_NV_Item_Factory_Info，需偏移24个字节，长度4为四个字节，因此需要先读 */
    ulResult = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Factory_Info, aucFacInfo, AT_FACTORY_INFO_LEN);

    if (ulResult != NV_OK)
    {
        AT_ERR_LOG("AT_SetTmmiPara: NV Read Fail!");
        return AT_ERROR;
    }

    /* 成功 写入"ST P" */
    if (gastAtParaList[0].ulParaValue == 1)
    {
        lMemResult = memcpy_s(&aucFacInfo[AT_MMI_TEST_FLAG_OFFSET],
                              AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET,
                              AT_MMI_TEST_FLAG_SUCC,
                              AT_MMI_TEST_FLAG_LEN);
        TAF_MEM_CHK_RTN_VAL(lMemResult, AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET, AT_MMI_TEST_FLAG_LEN);
    }
    /* 失败 清空 */
    else
    {
        lMemResult = memcpy_s(&aucFacInfo[AT_MMI_TEST_FLAG_OFFSET],
                              AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET,
                              "0000",
                              AT_MMI_TEST_FLAG_LEN);
        TAF_MEM_CHK_RTN_VAL(lMemResult, AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET, AT_MMI_TEST_FLAG_LEN);
    }

    ulResult = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Factory_Info, aucFacInfo, AT_FACTORY_INFO_LEN);

    if (ulResult != NV_OK)
    {
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}

VOS_UINT32 AT_SetChrgEnablePara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;

    ulRet                               = mdrv_misc_support_check(BSP_MODULE_TYPE_CHARGE);

    if (ulRet == BSP_MODULE_UNSUPPORT)
    {
        return AT_ERROR;
    }


    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }


    /*参数长度过长*/
    if (gastAtParaList[0].usParaLen != 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    if((gastAtParaList[0].ulParaValue == 0)
    || (gastAtParaList[0].ulParaValue == 1))
    {

        /* 调用驱动接口使能或去使能充电 */
        mdrv_misc_set_charge_state((unsigned long)gastAtParaList[0].ulParaValue);
    }
    else
    {

        /*调用补电接口*/
        mdrv_misc_sply_battery();
    }


    return AT_OK;
}

VOS_UINT32 AT_SetTestScreenPara(VOS_UINT8 ucIndex)
{
    return AT_OK;
}


VOS_UINT32 AT_SetCdurPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_GET_CDUR_PARA_STRU         stGetCdurPara;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stGetCdurPara, sizeof(stGetCdurPara), 0x00, sizeof(stGetCdurPara));

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return  AT_TOO_MANY_PARA;
    }

    if ((gucAtParaIndex != 1)
     || (gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[0].ulParaValue > AT_CALL_MAX_NUM))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stGetCdurPara.callId = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发消息到C核获取通话时长 */
    ulRet = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stGetCdurPara,
                                  ID_TAF_CCM_GET_CDUR_REQ,
                                  sizeof(stGetCdurPara),
                                  enModemId);

    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetCdurPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CDUR_READ;
    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 AT_SetWebPwdPara(VOS_UINT8 ucIndex)
{
    VOS_CHAR                                aucWebPwdTmp[AT_WEBUI_PWD_MAX + 1];
    TAF_AT_NVIM_WEB_ADMIN_PASSWORD_STRU     stWebPwd;
    errno_t                                 lMemResult;

    memset_s(&stWebPwd, sizeof(stWebPwd), 0x00, sizeof(stWebPwd));

    /* 参数检查 */
    if (gucAtParaIndex > 2)
    {
        return  AT_TOO_MANY_PARA;
    }

    /* 参数长度过长 */
    if (gastAtParaList[1].usParaLen > AT_WEBUI_PWD_MAX)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }
    /* 校验WEBUI PWD */
    if (gastAtParaList[0].ulParaValue == AT_WEBUI_PWD_VERIFY)
    {
        if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WEB_ADMIN_PASSWORD,&stWebPwd, sizeof(stWebPwd)) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetWebPwdPara:READ NV ERROR");
            return AT_ERROR;
        }

        lMemResult = memcpy_s(aucWebPwdTmp, sizeof(aucWebPwdTmp), &stWebPwd, sizeof(stWebPwd));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucWebPwdTmp), sizeof(stWebPwd));

        /* 密码不匹配 */
        if (VOS_StrCmp(aucWebPwdTmp,(VOS_CHAR*)gastAtParaList[1].aucPara) != 0)
        {
            return AT_ERROR;
        }
    }
    else
    {
        /* 读取WEBPWD对应的NV项 */
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_WEB_ADMIN_PASSWORD, gastAtParaList[1].aucPara, AT_WEBUI_PWD_MAX) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetWebPwdPara:WRITE NV ERROR");
            return AT_ERROR;
        }
    }

    return AT_OK;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32  AT_SetSdloadPara(VOS_UINT8 ucIndex)
{

#if (FEATURE_LTE == FEATURE_ON)
    return AT_SetLteSdloadPara(ucIndex);
#else
    VOS_UINT32                          ulRet;

    /* 1. 发消息到C核指示使单板进入下载模式 */
    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_SDLOAD_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetSdloadPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 2. 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SDLOAD_SET;
    return AT_WAIT_ASYNC_RETURN;

#endif
}
#endif


VOS_UINT32 AT_SetProdNamePara(VOS_UINT8 ucIndex)
{
    TAF_AT_PRODUCT_ID_STRU              stProductId;
    VOS_UINT32                          ulProductIdLen;
    VOS_UINT32                          ulRet;
    errno_t                             lMemResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    memset_s(&stProductId, sizeof(stProductId), 0x00, sizeof(TAF_AT_PRODUCT_ID_STRU));

    /* 从NV50048中读取产品名称 */
    /* 读取NV项en_NV_Item_PRODUCT_ID*/
    ulRet = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_PRODUCT_ID,
                    &stProductId,
                    sizeof(stProductId.ulNvStatus) + sizeof(stProductId.aucProductId));

    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("AT_SetProdNamePara: Fail to read en_NV_Item_PRODUCT_ID");
        return AT_ERROR;
    }


    /*产品名称写到NV项中，长度最长AT_PRODUCT_NAME_MAX_NUM 30，超过截断*/
    ulProductIdLen
        = (gastAtParaList[0].usParaLen > AT_PRODUCT_NAME_MAX_NUM) ? AT_PRODUCT_NAME_MAX_NUM:gastAtParaList[0].usParaLen;

    memset_s(stProductId.aucProductId, sizeof(stProductId.aucProductId), 0x00, sizeof(stProductId.aucProductId));
    lMemResult = memcpy_s(stProductId.aucProductId, sizeof(stProductId.aucProductId), gastAtParaList[0].aucPara, (VOS_UINT16)ulProductIdLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stProductId.aucProductId), (VOS_UINT16)ulProductIdLen);

    stProductId.ulNvStatus = VOS_TRUE;

    /* 写入NV */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_PRODUCT_ID,
                        &stProductId,
                        sizeof(stProductId.ulNvStatus) + sizeof(stProductId.aucProductId)))
    {
        AT_ERR_LOG("AT_SetProdNamePara:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}



VOS_UINT32 AT_SetApRptSrvUrlPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT8                           aucApRptSrvUrl[AT_AP_XML_RPT_SRV_URL_LEN + 1];
    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1 )
    {
        return AT_ERROR;
    }

    /* URL为空或者长度超过127*/
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].usParaLen > AT_AP_XML_RPT_SRV_URL_LEN))
    {
        return AT_ERROR;
    }

    memset_s(aucApRptSrvUrl, sizeof(aucApRptSrvUrl), 0x00, (VOS_SIZE_T)(AT_AP_XML_RPT_SRV_URL_LEN + 1));
    lMemResult = memcpy_s(aucApRptSrvUrl, sizeof(aucApRptSrvUrl), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucApRptSrvUrl), gastAtParaList[0].usParaLen);

    /* 写NV:en_NV_Item_AP_RPT_SRV_URL*/
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AP_RPT_SRV_URL,
                        aucApRptSrvUrl,
                        AT_AP_XML_RPT_SRV_URL_LEN + 1))
    {
        AT_ERR_LOG("AT_SetApRptSrvUrlPara:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        gstAtSendData.usBufLen = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                    (TAF_CHAR *)pgucAtSndCodeAddr,
                                                    (TAF_CHAR *)pgucAtSndCodeAddr,
                                                    "^APRPTSRVURLNTY");

        return AT_OK;
    }
}


VOS_UINT32 AT_SetApXmlInfoTypePara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           aucApXmlInfoType[AT_AP_XML_RPT_INFO_TYPE_LEN + 1];
    errno_t                             lMemResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1 )
    {
        return AT_ERROR;
    }

    /* INFO TYPE为空或者长度超过127*/
    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].usParaLen > AT_AP_XML_RPT_INFO_TYPE_LEN))
    {
        return AT_ERROR;
    }

    memset_s(aucApXmlInfoType, sizeof(aucApXmlInfoType), 0x00, (VOS_SIZE_T)(AT_AP_XML_RPT_INFO_TYPE_LEN + 1));
    lMemResult = memcpy_s(aucApXmlInfoType, sizeof(aucApXmlInfoType), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucApXmlInfoType), gastAtParaList[0].usParaLen);

    /* 写NV:en_NV_Item_AP_XML_INFO_TYPE*/
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AP_XML_INFO_TYPE,
                        aucApXmlInfoType,
                        AT_AP_XML_RPT_INFO_TYPE_LEN + 1))
    {
        AT_ERR_LOG("AT_SetApXmlInfoTypePara:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        gstAtSendData.usBufLen = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                                    (TAF_CHAR *)pgucAtSndCodeAddr,
                                                    (TAF_CHAR *)pgucAtSndCodeAddr,
                                                    "^APXMLINFOTYPENTY");

        return AT_OK;
    }
}


VOS_UINT32 AT_SetApXmlRptFlagPara(VOS_UINT8 ucIndex)
{
    TAF_AT_NVIM_AP_XML_RPT_FLG_STRU     stApXmlRptFlg;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1 )
    {
        return AT_ERROR;
    }

    stApXmlRptFlg.ucApXmlRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 写NV:en_NV_Item_AP_XML_RPT_FLAG*/
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AP_XML_RPT_FLAG,
                        &stApXmlRptFlg,
                        sizeof(TAF_AT_NVIM_AP_XML_RPT_FLG_STRU)))
    {
       AT_ERR_LOG("AT_SetApXmlRptFlagPara:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }
}



VOS_UINT32 AT_SetFastDormPara(VOS_UINT8 ucIndex)
{
    AT_RABM_FASTDORM_PARA_STRU          stFastDormPara;
    VOS_UINT32                          ulRslt;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第二个参数为空，则填写默认值 */
    if (gastAtParaList[1].usParaLen == 0)
    {
        /* 填写默认值5S */
        gastAtParaList[1].ulParaValue = AT_FASTDORM_DEFAULT_TIME_LEN;
    }

    stFastDormPara.enFastDormOperationType = gastAtParaList[0].ulParaValue;
    stFastDormPara.ulTimeLen = gastAtParaList[1].ulParaValue;

#if (FEATURE_LTE == FEATURE_ON)
    AT_SetLFastDormPara(ucIndex);
#endif

    /* 在AT融合版本上，新增的接口为直接发消息，因此这里直接发送消息给RABM */
    ulRslt = AT_SndSetFastDorm(gastAtClientTab[ucIndex].usClientId,
                               gastAtClientTab[ucIndex].opId,
                               &stFastDormPara);
    if (ulRslt == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_FASTDORM_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetMemInfoPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;

    /* 参数检查 */
    if( (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
     || (gucAtParaIndex > 1) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发消息到C核获取 MEMINFO 信息, gastAtParaList[0].ulParaValue 中为查询的类型 */
    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_MEMINFO_QRY_REQ,
                                   &(gastAtParaList[0].ulParaValue),
                                   sizeof(gastAtParaList[0].ulParaValue),
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_QryMemInfoPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MEMINFO_READ;
    return AT_WAIT_ASYNC_RETURN;

}
#endif

#if (VOS_WIN32 == VOS_OS_VER)

VOS_UINT32  AT_SetRplmnStub( VOS_UINT8 ucIndex )
{
    TAF_PLMN_ID_STRU                    stPlmnId;
    VOS_UINT32                          ulLai;
    VOS_UINT32                          ulRac;


    /* 参数不正确,
    0:表示需要设置L的RPLMN
    1:表示需要设置GU的RPLMN
    */
    if ( (gastAtParaList[0].ulParaValue != 0)
      && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要设置PLMN ID的值 */
    if ( (gastAtParaList[1].usParaLen != 5)
       && (gastAtParaList[1].usParaLen != 6) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* Mcc */
    if(At_String2Hex(gastAtParaList[1].aucPara,3,&stPlmnId.Mcc) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* Mnc */
    if(At_String2Hex(&gastAtParaList[1].aucPara[3],gastAtParaList[1].usParaLen-3,&stPlmnId.Mnc) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    stPlmnId.Mcc |= 0xFFFFF000U;
    stPlmnId.Mnc |= (0xFFFFFFFFU << ((gastAtParaList[1].usParaLen-3)*4));

    /* lai */
    ulLai = 0x0001;
    if (gastAtParaList[2].usParaLen == 4)
    {
        if(At_String2Hex(gastAtParaList[2].aucPara, 4, &ulLai) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /*rac  */
    ulRac = 0x01;
    if (gastAtParaList[3].usParaLen == 2)
    {
        if(At_String2Hex(gastAtParaList[3].aucPara, 2, &ulRac) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 需要设置L的RPLMN */
    if ( gastAtParaList[0].ulParaValue == 0 )
    {
        NAS_SetLteRplmnId(&stPlmnId, ulLai,ulRac);
    }
    else
    {
    }

    return AT_OK;
}


VOS_UINT32  AT_SetCsgStub( VOS_UINT8 ucIndex )
{
    /* 第一个参数为设置UE是否支持CSG功能，0:不支持csg功能；1:支持csg功能 */
    if(At_String2Hex(gastAtParaList[0].aucPara,gastAtParaList[0].usParaLen,&gastAtParaList[0].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[0].ulParaValue != 0)
      && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第二个参数设置EFAD文件中csg display indicator的值，0:都上报；1:只上报operator csg list中csg id */
    if(At_String2Hex(gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen,&gastAtParaList[1].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[1].ulParaValue != 0)
      && (gastAtParaList[1].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数csg list搜网是否仅上报operator csg list中的网络，0:都上报；1:只上报operator csg list中csg id */
    if(At_String2Hex(gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen,&gastAtParaList[2].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[2].ulParaValue != 0)
      && (gastAtParaList[2].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    NAS_SetCsgCfg(gastAtParaList[0].ulParaValue,gastAtParaList[1].ulParaValue,gastAtParaList[2].ulParaValue);

    return AT_OK;
}



VOS_UINT32  AT_SetDamParaStub( VOS_UINT8 ucIndex )
{
    TAF_PLMN_ID_STRU                    stImsiPlmnList[16];
    VOS_UINT8                           ucImsiPlmnNum;
    TAF_PLMN_ID_STRU                    stDamPlmnList[16];
    VOS_UINT8                           ucDamPlmnNum;
    VOS_UINT8                           ucEnableLteTrigPlmnSearchFlag;
    VOS_UINT8                           ucAddDamPlmnInDisabledPlmnList;
    VOS_UINT8                           i;
    VOS_UINT8                           ucParaIndex;
    VOS_UINT32                          ulMcc;
    VOS_UINT32                          ulMnc;
    VOS_UINT8                           ucDamActiveFlg;

    memset_s(&stImsiPlmnList, sizeof(stImsiPlmnList), 0x00, sizeof(stImsiPlmnList));
    memset_s(&stDamPlmnList, sizeof(stDamPlmnList), 0x00, sizeof(stDamPlmnList));

    /* 第一个参数为enable lte是否需要搜网，0为不需要；1为需要；
       第二个参数为DAM网络disable lte后是否加入禁止接入技术网络列表中，0为不需要；1为需要；
       第三个参数为imsi plmn list个数，如果个数为2，第四个参数和第五个参数为 imsi plmn id。
       第六个参数为DAM plmn list 个数，如果个数为2，第七个参数和第8个参数为dam plmn id*/

    /* 获取ucDamActiveFlg */
    if (At_String2Hex(gastAtParaList[0].aucPara,gastAtParaList[0].usParaLen,&gastAtParaList[0].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[0].ulParaValue != 0)
      && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucDamActiveFlg = gastAtParaList[0].ulParaValue;


    /* 获取ucEnableLteTrigPlmnSearchFlag */
    if (At_String2Hex(gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen,&gastAtParaList[1].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[1].ulParaValue != 0)
      && (gastAtParaList[1].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucEnableLteTrigPlmnSearchFlag = gastAtParaList[1].ulParaValue;


    /* 获取ucAddDamPlmnInDisabledPlmnList */
    if(At_String2Hex(gastAtParaList[2].aucPara,gastAtParaList[2].usParaLen,&gastAtParaList[2].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( (gastAtParaList[2].ulParaValue != 0)
      && (gastAtParaList[2].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucAddDamPlmnInDisabledPlmnList = gastAtParaList[2].ulParaValue;


    /* 获取ucImsiPlmnNum */
    if(At_String2Hex(gastAtParaList[3].aucPara,gastAtParaList[3].usParaLen,&gastAtParaList[3].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[3].ulParaValue > 16)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucImsiPlmnNum = gastAtParaList[3].ulParaValue;
    for (i = 1; i <= ucImsiPlmnNum; i++)
    {
        /* Mcc */
        if(At_String2Hex(gastAtParaList[3+i].aucPara,3,&ulMcc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        stImsiPlmnList[i-1].Mcc = ulMcc;

        /* Mnc */
        if(At_String2Hex(&gastAtParaList[3+i].aucPara[3],gastAtParaList[3+i].usParaLen-3,&ulMnc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        stImsiPlmnList[i-1].Mnc = ulMnc;

        stImsiPlmnList[i-1].Mcc |= 0xFFFFF000U;
        stImsiPlmnList[i-1].Mnc |= (0xFFFFFFFFU << ((gastAtParaList[3+i].usParaLen-3)*4));
    }

    /* ucDamPlmnNum */
    ucParaIndex = 3+ucImsiPlmnNum+1;
    if(At_String2Hex(gastAtParaList[ucParaIndex].aucPara,gastAtParaList[ucParaIndex].usParaLen,&gastAtParaList[ucParaIndex].ulParaValue) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucDamPlmnNum = gastAtParaList[ucParaIndex].ulParaValue;

    for (i = 1; i <= ucDamPlmnNum; i++)
    {
        /* Mcc */
        if(At_String2Hex(gastAtParaList[ucParaIndex+i].aucPara,3,&stDamPlmnList[i-1].Mcc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* Mnc */
        if(At_String2Hex(&gastAtParaList[ucParaIndex+i].aucPara[3],gastAtParaList[ucParaIndex+i].usParaLen-3,&stDamPlmnList[i-1].Mnc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        stDamPlmnList[i-1].Mcc |= 0xFFFFF000U;
        stDamPlmnList[i-1].Mnc |= (0xFFFFFFFFU << ((gastAtParaList[ucParaIndex+i].usParaLen-3)*4));
    }

    NAS_SetDamCfg(ucDamActiveFlg,ucEnableLteTrigPlmnSearchFlag, ucAddDamPlmnInDisabledPlmnList,
        ucImsiPlmnNum, stImsiPlmnList, ucDamPlmnNum, stDamPlmnList);
    return AT_OK;
}



VOS_UINT32  AT_SetEonsParaStub( VOS_UINT8 ucIndex )
{
    VOS_UINT8                           ucNum;
    VOS_UINT8                           aucEonsPrioType[4];
    VOS_UINT8                           ucRefreshAllFileRestartFlag;

    memset_s(&aucEonsPrioType, sizeof(aucEonsPrioType), 0x00, sizeof(aucEonsPrioType));

    ucNum              = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    aucEonsPrioType[0] = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    aucEonsPrioType[1] = (VOS_UINT8)gastAtParaList[2].ulParaValue;
    aucEonsPrioType[2] = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    aucEonsPrioType[3] = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    ucRefreshAllFileRestartFlag = (VOS_UINT8)gastAtParaList[5].ulParaValue;

    NAS_SetEonsPara(ucNum, aucEonsPrioType,ucRefreshAllFileRestartFlag);

    return AT_OK;
}


VOS_UINT32  AT_SetWildCardParaStub( VOS_UINT8 ucIndex )
{
    NAS_SetWildCardPara(gastAtParaList[0].aucPara[0]);

    return AT_OK;
}


/* Added by s46746 for CS/PS mode 1, 2012-6-25, begin */

VOS_UINT32 AT_SetCsUnAvailPlmnStub( VOS_UINT8 ucIndex )
{
    TAF_PLMN_ID_STRU                    stPlmnId;


    /* 参数不正确,
    0:表示需要删除CS不可用网络
    1:表示需要新增CS不可用网络
    */
    if ( (gastAtParaList[0].ulParaValue != 0)
      && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue != 0)
    {
        /* 需要设置PLMN ID的值 */
        if ( (gastAtParaList[1].usParaLen != 5)
           && (gastAtParaList[1].usParaLen != 6) )
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* Mcc */
        if(At_String2Hex(gastAtParaList[1].aucPara,3,&stPlmnId.Mcc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mnc */
        if(At_String2Hex(&gastAtParaList[1].aucPara[3],gastAtParaList[1].usParaLen-3,&stPlmnId.Mnc) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        stPlmnId.Mcc |= 0xFFFFF000U;
        stPlmnId.Mnc |= (0xFFFFFFFFU << ((gastAtParaList[1].usParaLen-3)*4));
    }

    /* 需要设置L的CS不可用网络 */
    if (NAS_SetCsUnAvailPlmnId(gastAtParaList[0].ulParaValue, &stPlmnId) == VOS_OK)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetDisableRatPlmnStub( VOS_UINT8 ucIndex )
{
    /* 参数不正确,
    0:表示需要删除禁止接入技术网络列表
    */
    if (gastAtParaList[0].ulParaValue != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (NAS_SetDisableRatPlmn(gastAtParaList[0].ulParaValue) == VOS_OK)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetForbRoamTaStub( VOS_UINT8 ucIndex )
{
    /* 参数不正确,
    0:表示需要删除禁止漫游TA
    1:表示需要新增禁止漫游TA
    */
    if ( (gastAtParaList[0].ulParaValue != 0)
      && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要设置L的禁止漫游TA */
    if (NAS_SetForbRoamTa(gastAtParaList[0].ulParaValue) == VOS_OK)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }
}
/* Added by s46746 for CS/PS mode 1, 2012-6-25, end */


VOS_UINT32  AT_SetTinTypeStub( VOS_UINT8 ucIndex )
{
    if (gucAtParaIndex > 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置TIN类型 */
    NAS_SetTinType(gastAtParaList[0].ulParaValue);

    return AT_OK;
}



VOS_UINT32  AT_SetPsRegisterContainDrxStub( VOS_UINT8 ucIndex )
{
    if (gucAtParaIndex > 1)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

    NAS_SetPsRegContainDrx(gastAtParaList[0].ulParaValue);

    return AT_OK;
}


VOS_UINT32  AT_SetPsBearIsrFlgStub( VOS_UINT8 ucIndex )
{
    if (gucAtParaIndex > 3)
    {
        return  AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)

    /* 设置usapi 对应的pdp是在ISR激活前激活的还是在ISR激活后激活的 */
    NAS_SetPsBearerIsrFlg(gastAtParaList[0].ulParaValue,
                          gastAtParaList[1].ulParaValue,
                          gastAtParaList[2].ulParaValue);
#endif

    return AT_OK;
}


VOS_UINT32 AT_SetImsRatStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                                               ucLteImsSupportFlg;
    VOS_UINT8                                               ucLteEmsSupportFlg;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 2)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数 LTE IMS是否支持 */
    ucLteImsSupportFlg       = gastAtParaList[0].ulParaValue;

    /* 第二个参数 LTE EMS是否支持 */
    ucLteEmsSupportFlg    = gastAtParaList[1].ulParaValue;

    NAS_SetLteImsSupportFlag(ucLteImsSupportFlg, ucLteEmsSupportFlg);

    return AT_OK;

}



VOS_UINT32 AT_SetImsCapabilityStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                                               ucVoiceCallOnImsSupportFlg;
    VOS_UINT8                                               ucVideoCallOnImsSupportFlg;
    VOS_UINT8                                               ucSmsOnImsSupportFlg;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 3)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数表示voice call是否支持 0:不支持;1:支持 */
    ucVoiceCallOnImsSupportFlg      = gastAtParaList[0].ulParaValue;

    /* 第二个参数表示video call是否支持 0:不支持;1:支持 */
    ucVideoCallOnImsSupportFlg      = gastAtParaList[1].ulParaValue;

    /* 第三个参数表示sms是否支持 0:不支持;1:支持 */
    ucSmsOnImsSupportFlg            = gastAtParaList[2].ulParaValue;

    NAS_SetImsLteCapabilitySupportFlag(ucVoiceCallOnImsSupportFlg, ucVideoCallOnImsSupportFlg, ucSmsOnImsSupportFlg);

    return AT_OK;

}


VOS_UINT32 AT_SetDomainStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                                               ucVoiceDomain;
    VOS_UINT8                                               ucSmsDomain;
    VOS_UINT32                                              ulUpdateMmlVoiceDomainFlag;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 3)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数 voice domain时，0:CS ONLY; 1:IMS PS ONLY; 2:CS PREFERRED; 3:IMS PS PREFERRED */
    ucVoiceDomain   = gastAtParaList[0].ulParaValue;

    /* 第二个参数 sms domain时，  0:NOT USE SMS OVER IP;    1:PREFERR TO USE SMS OVER IP */
    ucSmsDomain    = gastAtParaList[1].ulParaValue;

    ulUpdateMmlVoiceDomainFlag = gastAtParaList[2].ulParaValue;

    NAS_SetPreferDomain(ucVoiceDomain, ucSmsDomain, ulUpdateMmlVoiceDomainFlag);


    return AT_OK;

}



VOS_UINT32 AT_SetCmdImsRoamingStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucImsRoamingFlag;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    ucImsRoamingFlag   = gastAtParaList[0].ulParaValue;

    NAS_SetImsRoaming(ucImsRoamingFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetCmdRedailStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucCallRedialImsToCs;
    VOS_UINT8                           ucSmsRedialImsToCs;
    VOS_UINT8                           ucSsRedialImsToCs;
    VOS_UINT8                           ucCallRedialCsToIms;
    VOS_UINT8                           ucSmsRedialCsToIms;
    VOS_UINT8                           ucSsRedialCsToIms;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 7)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* IMS到CS呼叫换域重拨配置 */
    ucCallRedialImsToCs = gastAtParaList[0].ulParaValue;

    /* IMS到CS短信换域重拨配置 */
    ucSmsRedialImsToCs  = gastAtParaList[1].ulParaValue;

    /* IMS到CS补充换域重拨配置 */
    ucSsRedialImsToCs   = gastAtParaList[2].ulParaValue;

    /* CS到IMS呼叫换域重拨配置 */
    ucCallRedialCsToIms = gastAtParaList[3].ulParaValue;

    /* CS到IMS短信换域重拨配置 */
    ucSmsRedialCsToIms  = gastAtParaList[4].ulParaValue;

    /* CS到IMS补充换域重拨配置 */
    ucSsRedialCsToIms   = gastAtParaList[5].ulParaValue;

    NAS_SetRedialCfg(ucCallRedialImsToCs, ucSmsRedialImsToCs, ucSsRedialImsToCs,
                     ucCallRedialCsToIms, ucSmsRedialCsToIms, ucSsRedialCsToIms);

    return AT_OK;
}



VOS_UINT32 AT_SetImsVoiceInterSysLauEnableStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucForceLauFlag;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    ucForceLauFlag   = gastAtParaList[0].ulParaValue;

    NAS_SetImsVoiceInterSysLauEnable(ucForceLauFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetImsVoiceMMEnableStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucImsVoiceMMEnableFlag;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    ucImsVoiceMMEnableFlag   = gastAtParaList[0].ulParaValue;

    NAS_SetImsVoiceMMEnableFlg(ucImsVoiceMMEnableFlag);

    return AT_OK;
}




VOS_UINT32 AT_SetCmdImsUssdStub(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucImsUssdFlag;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    ucImsUssdFlag   = gastAtParaList[0].ulParaValue;

    NAS_SetImsUssd(ucImsUssdFlag);

    return AT_OK;
}

#endif


VOS_UINT32 AT_SetDnsQueryPara(VOS_UINT8 ucIndex)
{

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 给APS模块发送执行命令操作消息 */
    if ( TAF_PS_GetDynamicDnsInfo(WUEPS_PID_AT,
                                  AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                  gastAtClientTab[ucIndex].opId,
                                  (VOS_UINT8)gastAtParaList[0].ulParaValue) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DNSQUERY_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 AT_SetMemStatusPara(VOS_UINT8 ucIndex)
{
    MN_MSG_SET_MEMSTATUS_PARM_STRU      stMemStatus;

    /* 初始化 */
    memset_s(&stMemStatus, sizeof(stMemStatus), 0x00, sizeof(MN_MSG_SET_MEMSTATUS_PARM_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        stMemStatus.enMemFlag = MN_MSG_MEM_FULL_SET;
    }
    else
    {
        stMemStatus.enMemFlag = MN_MSG_MEM_FULL_UNSET;
    }

    /* 调用MN消息API发送设置请求给MSG模块 */
    if ( MN_MSG_SetMemStatus(gastAtClientTab[ucIndex].usClientId,
                             gastAtClientTab[ucIndex].opId,
                             &stMemStatus) != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_CSASM_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCdmaMemStatusPara(VOS_UINT8 ucIndex)
{
    TAF_XSMS_AP_MEM_FULL_ENUM_UINT8     enAPMemFullFlag = 0;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        enAPMemFullFlag = TAF_XSMS_AP_MEM_FULL;
    }
    else
    {
        enAPMemFullFlag = TAF_XSMS_AP_MEM_NOT_FULL;
    }

    /* 调用MN消息API发送设置请求给MSG模块 */
    if (TAF_XSMS_SetXsmsApMemFullReq(gastAtClientTab[ucIndex].usClientId,
                                     gastAtClientTab[ucIndex].opId,
                                     enAPMemFullFlag) != AT_SUCCESS)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt  = AT_CMD_CCSASM_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;

}
#endif



VOS_UINT32 AT_SetApRptPortSelectTwoPara(void)
{
    VOS_UINT32                          ulResult0;
    VOS_UINT32                          ulResult1;
    AT_PORT_RPT_CFG_STRU                stRptCfg;
    VOS_UINT32                          ulClientCfgTabLen;
    AT_CLIENT_CFG_MAP_TAB_STRU         *pstCfgMapTbl = VOS_NULL_PTR;
    AT_CLIENT_CONFIGURATION_STRU       *pstClientCfg = VOS_NULL_PTR;
    VOS_UINT8                           i;

    memset_s(&stRptCfg, sizeof(stRptCfg), 0x00, sizeof(stRptCfg));
    /* AT的端口个数大于32个，所以用两个32bit的参数表示对应的端口是否允许主动上报 */
    ulResult0 = AT_String2Hex(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen, &stRptCfg.aulRptCfgBit32[0]);
    ulResult1 = AT_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &stRptCfg.aulRptCfgBit32[1]);

    if ((ulResult0 == VOS_ERR) || (ulResult1 == VOS_ERR))
    {
        AT_ERR_LOG1("AT_SetApRptPortSelectTwoPara: ulResult0 is d%", ulResult0);
        AT_ERR_LOG1("AT_SetApRptPortSelectTwoPara: ulResult1 is d%", ulResult1);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulClientCfgTabLen = AT_GET_CLIENT_CFG_TAB_LEN();
    /*  FEATURE_VCOM_EXT宏关闭的时候，ulClientCfgTabLen 总长度为2，不需要减 */
#if (FEATURE_VCOM_EXT == FEATURE_ON)
        /* 两个参数的时候，需要总长度需要减去一个参数所代表的长度32，另外加上预留了6个端口，所以是26*/
    ulClientCfgTabLen = ulClientCfgTabLen - 26;
#endif

    for (i = 0; i < ulClientCfgTabLen; i++)
    {
        pstCfgMapTbl = AT_GetClientCfgMapTbl(i);
        pstClientCfg = AT_GetClientConfig(pstCfgMapTbl->enClientId);

        pstClientCfg->ucReportFlg = ((stRptCfg.aulRptCfgBit32[0] & pstCfgMapTbl->ulRptCfgBit32[0])
                                   ||(stRptCfg.aulRptCfgBit32[1] & pstCfgMapTbl->ulRptCfgBit32[1])) ?
                                   VOS_TRUE : VOS_FALSE;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetApRptPortSelectThreePara(void)
{
    VOS_UINT32                          ulResult0;
    VOS_UINT32                          ulResult1;
    VOS_UINT32                          ulResult2;
    AT_PORT_RPT_CFG_STRU                stRptCfg;
    AT_CLIENT_CFG_MAP_TAB_STRU         *pstCfgMapTbl = VOS_NULL_PTR;
    AT_CLIENT_CONFIGURATION_STRU       *pstClientCfg = VOS_NULL_PTR;
    VOS_UINT8                           i;

    memset_s(&stRptCfg, sizeof(stRptCfg), 0x00, sizeof(stRptCfg));
    /* 获取用户设置的参数 */
    /* AT的端口个数大于64个，所以用三个32bit的参数表示对应的端口是否允许主动上报 */
    ulResult0 = AT_String2Hex(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen, &stRptCfg.aulRptCfgBit32[0]);
    ulResult1 = AT_String2Hex(gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen, &stRptCfg.aulRptCfgBit32[1]);
    ulResult2 = AT_String2Hex(gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen, &stRptCfg.aulRptCfgBit32[2]);

    if ((ulResult0 == VOS_ERR) || (ulResult1 == VOS_ERR) || (ulResult2 == VOS_ERR))
    {
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult0 is d%", ulResult0);
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult1 is d%", ulResult1);
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult2 is d%", ulResult2);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < AT_GET_CLIENT_CFG_TAB_LEN(); i++)
    {
        pstCfgMapTbl = AT_GetClientCfgMapTbl(i);
        pstClientCfg = AT_GetClientConfig(pstCfgMapTbl->enClientId);

        pstClientCfg->ucReportFlg = ((stRptCfg.aulRptCfgBit32[0] & pstCfgMapTbl->ulRptCfgBit32[0])
                                   ||(stRptCfg.aulRptCfgBit32[1] & pstCfgMapTbl->ulRptCfgBit32[1])
                                   ||(stRptCfg.aulRptCfgBit32[2] & pstCfgMapTbl->ulRptCfgBit32[2])) ?
                                   VOS_TRUE : VOS_FALSE;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetApRptPortSelectPara(VOS_UINT8 ucIndex)
{
    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ( (gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 为了兼容扩容以前的两个参数的AT命令 总长度要减去32 */
    if ( gastAtParaList[2].usParaLen == 0 )
    {
        return AT_SetApRptPortSelectTwoPara();
    }

    return AT_SetApRptPortSelectThreePara();
}


VOS_UINT32 At_SetGpioPara (VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucGroup;
    VOS_UINT8                           ucPin;
    VOS_UINT8                           ucValue;

    /* 如果不支持HSIC特性，不支持GPIO切换 */
    if (mdrv_misc_support_check(BSP_MODULE_TYPE_HSIC) != BSP_MODULE_SUPPORT)
    {
        return AT_ERROR;
    }

    /* para too many */
    if (gucAtParaIndex > 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucGroup = (VOS_UINT8)(gastAtParaList[0].ulParaValue / 100);
    ucPin   = (VOS_UINT8)(gastAtParaList[0].ulParaValue % 100);

    if (DRV_GPIO_SET(ucGroup, ucPin, (VOS_UINT8)gastAtParaList[1].ulParaValue) != VOS_OK)
    {
        return AT_ERROR;
    }

    VOS_TaskDelay(gastAtParaList[2].ulParaValue);

    /* 完成GPIO设置后需要将电平反转过来 */
    ucValue = (gastAtParaList[1].ulParaValue == DRV_GPIO_HIGH)?DRV_GPIO_LOW:DRV_GPIO_HIGH;


    if (DRV_GPIO_SET(ucGroup, ucPin, ucValue) != VOS_OK)
    {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 At_SetUsbSwitchPara (VOS_UINT8 ucIndex)
{
    VOS_INT                          iResult;
    VOS_UINT8                        ucUsbStatus;

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* para too many */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    ucUsbStatus = USB_SWITCH_OFF;

    if (DRV_USB_PHY_SWITCH_GET(&ucUsbStatus) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置Modem的USB启动 */
    if(gastAtParaList[0].ulParaValue == AT_USB_SWITCH_SET_VBUS_VALID)
    {
        if (ucUsbStatus != USB_SWITCH_ON)
        {
            iResult = DRV_USB_PHY_SWITCH_SET(USB_SWITCH_ON);
        }
        else
        {
            return AT_OK;
        }
    }
    else if(gastAtParaList[0].ulParaValue == AT_USB_SWITCH_SET_VBUS_INVALID)
    {
        if (ucUsbStatus != USB_SWITCH_OFF)
        {
            iResult = DRV_USB_PHY_SWITCH_SET(USB_SWITCH_OFF);
        }
        else
        {
            return AT_OK;
        }
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (iResult == VOS_OK)
    {
        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_SetSARReduction(VOS_UINT8 ucIndex)
{
    VOS_UINT32                              ulResult;
    VOS_UINT16                              usUETestMode;

    AT_MODEM_MT_INFO_CTX_STRU              *pstMtInfoCtx = VOS_NULL_PTR;
    MODEM_ID_ENUM_UINT16                    enModemId;
    VOS_UINT16                              usAntState;

    usUETestMode = 0;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_ERR_LOG("AT_SetSARReduction: Cmd Opt Type is wrong.");
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 读取NV项判定是否为测试模式，该NV项只有一份 */
    ulResult = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_RF_SAR_BACKOFF_TESTMODE,
                         &usUETestMode,
                         sizeof(usUETestMode));

    if (ulResult != NV_OK)
    {
        AT_ERR_LOG("AT_SetSARReduction:Read NV fail");
        return AT_ERROR;
    }


    enModemId  = MODEM_ID_0;

    ulResult   = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulResult != VOS_OK)
    {
        AT_ERR_LOG("AT_SetSARReduction:Get modem id fail");

        return AT_ERROR;
    }

    pstMtInfoCtx = AT_GetModemMtInfoCtxAddrFromModemId(enModemId);

    ulResult = TAF_AGENT_GetAntState(ucIndex, &usAntState);
    if (ulResult != VOS_OK)
    {
        AT_ERR_LOG("AT_QrySARReduction:Get modem id fail");
        return AT_ERROR;
    }

    if ((usAntState == AT_ANT_CONDUCTION_MODE) && (usUETestMode != VOS_TRUE))
    {
        AT_ERR_LOG("AT_SetSARReduction: Test mode wrong");
        return AT_ERROR;
    }

    pstMtInfoCtx->ulSarReduction = gastAtParaList[0].ulParaValue;

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_SARREDUCTION_NTF,
                                      &pstMtInfoCtx->ulSarReduction,
                                      sizeof(VOS_UINT32),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_ERR_LOG("AT_SetSARReduction: Send Msg Fail");

        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetScidPara(TAF_UINT8 ucIndex)
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if(Taf_ParaQuery(gastAtClientTab[ucIndex].usClientId,0,TAF_PH_ICC_ID,TAF_NULL_PTR) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ICCID_READ;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}




VOS_UCHAR ToBase64Char(const VOS_UCHAR code6bit)
{
    VOS_UCHAR                           ucValue;

    /* [ 0..25] => ['A'..'Z'] */
    if (code6bit<26)
    {
        ucValue = (VOS_UCHAR)(code6bit+'A');
        return ucValue;
    }

    /* [26..51] => ['a'..'z'] */
    else if (code6bit<52)
    {
        ucValue = (VOS_UCHAR)(code6bit+('a'-26));
        return ucValue;
    }

    /* [52..61] => ['0'..'9'] */
    else if (code6bit<62)
    {
        ucValue = (VOS_UCHAR)(code6bit-52+'0');
        return ucValue;
    }

    /* 62 => '+' */
    else if (code6bit==62)
    {
        ucValue = '+';
        return ucValue;
    }

    /* 63 => */
    else
    {
        ucValue = '/';
        return ucValue;
    }
}



VOS_VOID AtBase64Encode(const VOS_VOID* pdata,const VOS_UINT32 data_size,VOS_VOID* out_pcode)
{
    const VOS_UCHAR* input      =(const unsigned char*)pdata;
    const VOS_UCHAR* input_end  =&input[data_size];
    VOS_UCHAR*       output     =(unsigned char*)out_pcode;
    VOS_UINT32       bord_width = 0;

    for(; input+2 < input_end; input += 3, output += 4 )
    {
        output[0] = ToBase64Char(   input[0] >> 2 );
        output[1] = ToBase64Char( ((input[0] << 4) | (input[1] >> 4)) & 0x3F );
        output[2] = ToBase64Char( ((input[1] << 2) | (input[2] >> 6)) & 0x3F );
        output[3] = ToBase64Char(   input[2] & 0x3F);
    }

    if(input_end > input)
    {
        bord_width = (VOS_UINT32)(input_end-input);
        if ( bord_width == 1 )
        {
            output[0] = ToBase64Char(   input[0] >> 2 );
            output[1] = ToBase64Char(  (input[0] << 4) & 0x3F );
            output[2] = AT_BASE64_PADDING;
            output[3] = AT_BASE64_PADDING;
        }
        else if (bord_width==2)
        {
            output[0] = ToBase64Char(   input[0] >> 2 );
            output[1] = ToBase64Char( ((input[0] << 4) | (input[1] >> 4)) & 0x3F );
            output[2] = ToBase64Char(  (input[1] << 2) & 0x3F );
            output[3] = AT_BASE64_PADDING;
        }
        else
        {
        }
    }
}



unsigned int AtBase64Decode(const void* pcode,const unsigned int code_size,void* out_pdata,
                            const unsigned int data_size,unsigned int* out_pwrited_data_size)
{
    const unsigned char *input_last_fast_node = VOS_NULL_PTR;
    unsigned char       *output               = VOS_NULL_PTR;
    const unsigned char *input                = VOS_NULL_PTR;
    const unsigned char DECODE_DATA_MAX = 64-1;
    const unsigned char DECODE_PADDING  = DECODE_DATA_MAX+2;
    const unsigned char DECODE_ERROR    = DECODE_DATA_MAX+3;
    static unsigned char BASE64_DECODE[256];
    static VOS_BOOL initialized         = VOS_FALSE;
    unsigned int code0;
    unsigned int code1;
    unsigned int code2;
    unsigned int code3;
    unsigned int bord_width;
    unsigned int output_size;
    unsigned int code_node;
    unsigned int i;

    if(!initialized)
    {
        for(i=0;i<256;++i)
        {
            BASE64_DECODE[i]=DECODE_ERROR;
        }
        for(i='A';i<='Z';++i)
        {
            BASE64_DECODE[i]=(unsigned char)(i-'A');
        }
        for(i='a';i<='z';++i)
        {
            BASE64_DECODE[i]=(unsigned char)(i-'a'+26);
        }
        for(i='0';i<='9';++i)
        {
            BASE64_DECODE[i]=(unsigned char)(i-'0'+26*2);
        }
        BASE64_DECODE['+']=26*2+10;
        BASE64_DECODE['/']=26*2+10+1;
        BASE64_DECODE['=']=DECODE_PADDING;
        initialized=VOS_TRUE;
    }
    *out_pwrited_data_size=0;
    code_node=code_size/4;
    if ((code_node*4)!=code_size)
    {
        return b64Result_CODE_SIZE_ERROR;
    }
    else if (code_node==0)
    {
        return b64Result_OK;
    }
    else
    {
    }

    /* code_node>0 */
    input=(const unsigned char*)pcode;
    output=(unsigned char*)out_pdata;
    output_size=code_node*3;

    if (input[code_size-2]==AT_BASE64_PADDING)
    {
        if (input[code_size-1]!=AT_BASE64_PADDING)
        {
            return b64Result_CODE_ERROR;
        }

        output_size-=2;
    }
    else if (input[code_size-1]==AT_BASE64_PADDING)
    {
        --output_size;
    }
    else
    {
    }

    if (output_size>data_size)
    {
        return b64Result_DATA_SIZE_SMALLNESS;
    }
    input_last_fast_node=&input[output_size/3UL * 4UL];

    for(;input<input_last_fast_node;input+=4,output+=3)
    {
        code0=BASE64_DECODE[input[0]];
        code1=BASE64_DECODE[input[1]];
        code2=BASE64_DECODE[input[2]];
        code3=BASE64_DECODE[input[3]];
        if ( ((code0|code1)|(code2|code3)) <= DECODE_DATA_MAX )
        {
            output[0]=(unsigned char)((code0<<2) + (code1>>4));
            output[1]=(unsigned char)((code1<<4) + (code2>>2));
            output[2]=(unsigned char)((code2<<6) + code3);
        }
        else
        {
            return b64Result_CODE_ERROR;
        }
    }
    bord_width=output_size%3;
    if (bord_width==1)
    {
        code0=BASE64_DECODE[input[0]];
        code1=BASE64_DECODE[input[1]];
        if ((code0|code1) <= DECODE_DATA_MAX)
        {
            output[0]=(unsigned char)((code0<<2) + (code1>>4));
        }
        else
        {
            return b64Result_CODE_ERROR;
        }
    }
    else if (bord_width==2)
    {
        code0=BASE64_DECODE[input[0]];
        code1=BASE64_DECODE[input[1]];
        code2=BASE64_DECODE[input[2]];
        if ((code0|code1|code2) <= DECODE_DATA_MAX)
        {
            output[0]=(unsigned char)((code0<<2) + (code1>>4));
            output[1]=(unsigned char)((code1<<4) + (code2>>2));
        }
        else
        {
            return b64Result_CODE_ERROR;
        }
    }
    else
    {
    }
    *out_pwrited_data_size=output_size;
    return b64Result_OK;
}






VOS_UINT32 AT_RsfrSimLockProc(VOS_UINT8* pgcSrcData, VOS_UINT16* pusLen)
{
    TAF_CUSTOM_SIM_LOCK_PLMN_INFO_STRU  stSimLockPlmnInfo;
    VOS_UINT32                          i;
    VOS_UINT16                          usLength;
    VOS_UINT8                           ucMncLen;
    VOS_UINT32                          ulPlmnIdx;
    VOS_UINT32                          ulRsltChkPlmnBegin;
    VOS_UINT32                          ulRsltChkPlmnEnd;
    VOS_UINT32                          ulTotalPlmnNum;
    VOS_BOOL                            abPlmnValidFlg[TAF_MAX_SIM_LOCK_RANGE_NUM] = {VOS_FALSE};
    VOS_UINT8                           aucAsciiNumBegin[(TAF_PH_SIMLOCK_PLMN_STR_LEN * 2) + 1];
    VOS_UINT8                           aucAsciiNumEnd[(TAF_PH_SIMLOCK_PLMN_STR_LEN * 2) + 1];


    memset_s(&stSimLockPlmnInfo, sizeof(stSimLockPlmnInfo), 0x00, sizeof(stSimLockPlmnInfo));

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_CustomizeSimLockPlmnInfo,
                       &stSimLockPlmnInfo,
                       sizeof(stSimLockPlmnInfo)))
    {
        return AT_ERROR;
    }

    ulTotalPlmnNum = 0;

    if (stSimLockPlmnInfo.ulStatus == NV_ITEM_DEACTIVE)
    {
        /* 状态非激活时，显示Plmn个数为0 */
        usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
                                           (VOS_CHAR *)pgcSrcData, "%s%s:%d%s",
                                           gaucAtCrLf,"^SIMLOCK",ulTotalPlmnNum,gaucAtCrLf);

        *pusLen = usLength;
        return AT_OK;
    }

    /*  判断Plmn号段是否有效 */
    for ( i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++ )
    {
        ucMncLen = stSimLockPlmnInfo.astSimLockPlmnRange[i].ucMncNum;

        ulRsltChkPlmnBegin = At_SimlockPlmnNumToAscii(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin,
                                    TAF_PH_SIMLOCK_PLMN_STR_LEN,aucAsciiNumBegin);

        ulRsltChkPlmnEnd = At_SimlockPlmnNumToAscii(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin,
                                    TAF_PH_SIMLOCK_PLMN_STR_LEN,aucAsciiNumEnd);

        if ((ulRsltChkPlmnBegin == AT_SUCCESS)
         && (ulRsltChkPlmnEnd == AT_SUCCESS)
         && ((ucMncLen <= 3) && (ucMncLen >= 2)))
        {
            abPlmnValidFlg[i] = VOS_TRUE;
            ++ ulTotalPlmnNum;
        }
    }

    usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
                                       (VOS_CHAR *)pgcSrcData, "%s%s:%d%s",
                                       gaucAtCrLf,"^SIMLOCK",ulTotalPlmnNum,gaucAtCrLf);

    if (ulTotalPlmnNum == 0)
    {
        *pusLen = usLength;
        return AT_OK;
    }

    /* CustomInfoSetting 工具软件要求的格式 */
    usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
                                (VOS_CHAR *)pgcSrcData + usLength,
                                "^SIMLOCK:");

    ulPlmnIdx = 0;
    for ( i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++ )
    {
        if (abPlmnValidFlg[i] == VOS_FALSE)
        {
            continue;
        }

        ++ ulPlmnIdx;

        At_SimlockPlmnNumToAscii(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeBegin,
                                    TAF_PH_SIMLOCK_PLMN_STR_LEN,aucAsciiNumBegin);

        At_SimlockPlmnNumToAscii(stSimLockPlmnInfo.astSimLockPlmnRange[i].aucRangeEnd,
                                    TAF_PH_SIMLOCK_PLMN_STR_LEN,aucAsciiNumEnd);

        usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
                                    (VOS_CHAR *)pgcSrcData + usLength,
                                    "%d,%d,%s,%s%s",
                                    ulPlmnIdx,
                                    stSimLockPlmnInfo.astSimLockPlmnRange[i].ucMncNum,
                                    aucAsciiNumBegin,
                                    aucAsciiNumEnd,
                                    gaucAtCrLf);
    }

    *pusLen = usLength;

    return AT_OK;
}




VOS_UINT32 AT_SetRsfrPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulRet;
    VOS_UINT16                          usLength = 0;
    VOS_CHAR                            cName[AT_RSFR_RSFW_NAME_LEN + 1]       = {0};
    VOS_CHAR                            cSubName[AT_RSFR_RSFW_SUBNAME_LEN + 1] = {0};
    VOS_UINT8                          *pcRsfrSrcItem = VOS_NULL_PTR;
    VOS_CHAR                           *pcRsfrDstItem = VOS_NULL_PTR;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数个数不为两个 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if ((gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[0].usParaLen > AT_RSFR_RSFW_NAME_LEN))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(cName, sizeof(cName), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(cName), gastAtParaList[0].usParaLen);

    At_UpString((VOS_UINT8*)cName, gastAtParaList[0].usParaLen);

    if (gastAtParaList[1].usParaLen > AT_RSFR_RSFW_SUBNAME_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(cSubName, sizeof(cSubName), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(cSubName), gastAtParaList[1].usParaLen);

    if(AT_STRCMP(cName, "VERSION") == ERR_MSP_SUCCESS)
    {
        if(AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                  gastAtClientTab[ucIndex].opId,
                                  DRV_AGENT_VERSION_QRY_REQ,
                                  VOS_NULL_PTR,
                                  0,
                                  I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_RSFR_VERSION_QRY;
            return AT_WAIT_ASYNC_RETURN;
        }
        else
        {
            return AT_ERROR;
        }
    }
    else if(AT_STRCMP(cName, "SIMLOCK") == ERR_MSP_SUCCESS)
    {
        pcRsfrSrcItem = (VOS_UINT8*)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (pcRsfrSrcItem == VOS_NULL_PTR )
        {
            return AT_ERROR;
        }

        memset_s(pcRsfrSrcItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        ulRet = AT_RsfrSimLockProc(pcRsfrSrcItem, &usLength);
        if(ulRet != AT_OK)
        {
            PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
            return ulRet;
        }

        pcRsfrDstItem = (VOS_CHAR*)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (pcRsfrDstItem == VOS_NULL_PTR )
        {
            PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
            return AT_ERROR;
        }

        memset_s(pcRsfrDstItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        /* 把从SIMLOCK命令中读出来的结果字符串作为编码源 */
        AtBase64Encode(pcRsfrSrcItem, usLength, pcRsfrDstItem);

        gstAtSendData.usBufLen = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgucAtSndCodeAddr,
                                    (VOS_CHAR *)pgucAtSndCodeAddr,
                                    "^RSFR:\"%s\",\"%s\",123,1,1,%s",
                                    cName, cSubName, gaucAtCrLf);

        gstAtSendData.usBufLen += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgucAtSndCodeAddr,
                                    (VOS_CHAR *)pgucAtSndCodeAddr + gstAtSendData.usBufLen,
                                    "\"%s\"", pcRsfrDstItem);
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
        PS_MEM_FREE(WUEPS_PID_AT, pcRsfrDstItem);
        /*lint -restore */

        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }
}



VOS_VOID AT_SetRsfrVersionCnf(VOS_UINT8 ucIndex, VOS_UINT8* pucData, VOS_UINT32 ulLen)
{
    VOS_UINT16 usLength;
    VOS_CHAR* pcRsfrItem = NULL;

    pcRsfrItem = (VOS_CHAR*)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
    if (pcRsfrItem == VOS_NULL_PTR )
    {
        return ;
    }

    memset_s(pcRsfrItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

    /* 把从SIMLOCK命令中读出来的结果字符串作为编码源 */
    AtBase64Encode(pucData, ulLen, pcRsfrItem);

    usLength = 0;
    usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgucAtSndCodeAddr,
                                (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                "^RSFR:\"VERSION\",\"111\",125,1,1,%s",
                                gaucAtCrLf);

    usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN, (VOS_CHAR *)pgucAtSndCodeAddr,
                                (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                "\"%s\"", pcRsfrItem);

    gstAtSendData.usBufLen = usLength;

    At_FormatResultData(ucIndex, AT_OK);
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pcRsfrItem);
    /*lint -restore */
    return ;
}



VOS_VOID AT_RsfwSimLockProc(VOS_UINT8 *pucData, VOS_UINT16 usLen)
{
    VOS_UINT16 i = 0;
    VOS_UINT32 usNum = 0;

    /* 补充AT两个字符 */
    pucData[0] = 'A';
    pucData[1] = 'T';
    pucData[10] = '=';      /* 把冒号改为等号 */

    if(usLen < 13)
    {
        return ;
    }

    if((pucData[11] == '1') && (pucData[12] == ','))
    {

        /* 工具下发的字符串里MNC长度添的是0，需要改为2或3 */
        for(i = 11; i < usLen; i++)
        {
            if(pucData[i] == ',')
            {
                usNum++;
                if(i+8 >= usLen)
                {
                    return ;
                }

                /* 通过判断PLMN的位数来确定是2还是3 */
                if(((usNum%3) == 1) && (pucData[i+1] == '0') && (pucData[i+2] == ','))
                {
                    if(pucData[i+8] == ',')
                    {
                        pucData[i+1] = '2';
                    }
                    else
                    {
                        pucData[i+1] = '3';
                    }
                }
            }
        }
    }

    return ;
}


VOS_UINT32 AT_SetRsfwPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulRet;
    VOS_UINT32                          ulLength = 0;
    VOS_CHAR                            cName[AT_RSFR_RSFW_NAME_LEN + 1]   = {0};
    VOS_UINT8*                          pucRsfw  = NULL;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数个数不为六个 */
    if (gucAtParaIndex != 6)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if ((gastAtParaList[0].usParaLen == 0)
        || (gastAtParaList[0].usParaLen > AT_RSFR_RSFW_NAME_LEN))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(cName, sizeof(cName), gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(cName), gastAtParaList[0].usParaLen);

    At_UpString((VOS_UINT8*)cName, gastAtParaList[0].usParaLen);

    /* CustomInfoSetting 工具软件只检查参数<name>，其余参数不检查 */

    if(AT_STRCMP(cName, "SIMLOCK") == ERR_MSP_SUCCESS)
    {
        if(gastAtParaList[5].usParaLen > AT_PARA_MAX_LEN)
        {
            PS_PRINTF_WARNING("<AT_SetRsfwPara> param 5 is too long : %d.\n", gastAtParaList[5].usParaLen);

            return AT_ERROR;
        }

        pucRsfw = (TAF_UINT8*)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (pucRsfw == VOS_NULL_PTR )
        {
            return AT_ERROR;
        }

        memset_s(pucRsfw, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        /* 前两个字符用来补充AT，然后送给^SIMLOCK命令的处理函数处理 */
        ulRet = AtBase64Decode(gastAtParaList[5].aucPara, gastAtParaList[5].usParaLen,
            &(pucRsfw[2]), (AT_RSFR_RSFW_MAX_LEN-2), &ulLength);
        if(b64Result_OK != ulRet)
        {
            PS_MEM_FREE(WUEPS_PID_AT, pucRsfw);
            return AT_ERROR;
        }

        /* 整理从CustomInfoSetting接收到的字符串 */
        AT_RsfwSimLockProc(pucRsfw, (VOS_UINT16)(ulLength + 2));

        ulRet = At_ProcSimLockPara(ucIndex, pucRsfw, (VOS_UINT16)(ulLength + 2));

        if(ulRet != AT_SUCCESS)
        {
            PS_PRINTF_WARNING("<AT_SetRsfwPara> At_ProcSimLockPara failed %d.\n", ulRet);
        }

        PS_MEM_FREE(WUEPS_PID_AT, pucRsfw);

        /* AT_ERROR AT_OK在At_ProcSimLockPara中返回 */
        return AT_SUCCESS;
    }

    else
    {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_SetHukPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulResult;
    VOS_UINT16                          usLength;
    DRV_AGENT_HUK_SET_REQ_STRU          stHukSetReq;

    AT_PR_LOGI("Rcv Msg");

    /* 局部变量初始化 */
    ulResult = VOS_NULL;
    usLength = gastAtParaList[0].usParaLen;
    memset_s(&stHukSetReq, sizeof(stHukSetReq), 0x00, sizeof(DRV_AGENT_HUK_SET_REQ_STRU));

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 检查码流参数长度 */
    if (usLength != AT_HUK_PARA_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串参数转换为码流 */
    ulResult = At_AsciiNum2HexString(gastAtParaList[0].aucPara, &usLength);
    if ( (ulResult != AT_SUCCESS) || (usLength != DRV_AGENT_HUK_LEN) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    lMemResult = memcpy_s(stHukSetReq.aucHUK, sizeof(stHukSetReq.aucHUK), gastAtParaList[0].aucPara, DRV_AGENT_HUK_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stHukSetReq.aucHUK), DRV_AGENT_HUK_LEN);

    /* 转换成功, 发送跨核消息到C核, 设置HUK */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      DRV_AGENT_HUK_SET_REQ,
                                      &stHukSetReq,
                                      sizeof(DRV_AGENT_HUK_SET_REQ_STRU),
                                      I0_WUEPS_PID_DRV_AGENT);
    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetHukPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_HUK_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_ProcAuthPubkeyExData(
    VOS_UINT32                          ulParaLen,
    VOS_UINT8                          *pucPubKeyData
)
{
    AT_AUTH_PUBKEYEX_CMD_PROC_CTX      *pstAuthPubKeyCtx = VOS_NULL_PTR;
    VOS_UINT8                          *pTempData = VOS_NULL_PTR;
    errno_t                             lMemResult;
    VOS_UINT16                          usTotalLen;

    if ((pucPubKeyData == VOS_NULL_PTR)
     || (ulParaLen == 0))
    {
        AT_ERR_LOG("AT_ProcAuthPubkeyExData: NULL Pointer");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    pstAuthPubKeyCtx = AT_GetAuthPubkeyExCmdCtxAddr();

    /* 当前是一次新的设置过程，收到的是第一条AT命令 */
    if (pstAuthPubKeyCtx->pucData == VOS_NULL_PTR)
    {
        pstAuthPubKeyCtx->pucData = (VOS_UINT8*)PS_MEM_ALLOC(WUEPS_PID_AT, ulParaLen);

        /* 分配内存失败，直接返回 */
        if (pstAuthPubKeyCtx->pucData == VOS_NULL_PTR)
        {
            AT_ERR_LOG("AT_ProcAuthPubkeyExData: first data, Alloc mem fail");

            return AT_ERROR;
        }

        lMemResult = memcpy_s(pstAuthPubKeyCtx->pucData, ulParaLen, pucPubKeyData, ulParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, ulParaLen, ulParaLen);

        pstAuthPubKeyCtx->usParaLen = (VOS_UINT16)ulParaLen;
    }
    else
    {
        /* 当前不是收到第一条AT命令，需要拼接码流 */
        usTotalLen = (VOS_UINT16)ulParaLen + pstAuthPubKeyCtx->usParaLen;
        /*lint -save -e516 */
        pTempData = (VOS_UINT8*)PS_MEM_ALLOC(WUEPS_PID_AT, usTotalLen);
        /*lint -restore */
                /* 分配内存失败，直接返回 */
        if (pTempData == VOS_NULL_PTR)
        {
            AT_ERR_LOG("AT_ProcAuthPubkeyExData: Non-first data, Alloc mem fail");

            return AT_ERROR;
        }

        lMemResult = memcpy_s(pTempData, usTotalLen, pstAuthPubKeyCtx->pucData, pstAuthPubKeyCtx->usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, usTotalLen, pstAuthPubKeyCtx->usParaLen);
        lMemResult = memcpy_s((pTempData + pstAuthPubKeyCtx->usParaLen), usTotalLen, pucPubKeyData, ulParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, usTotalLen, ulParaLen);
        PS_MEM_FREE(WUEPS_PID_AT, pstAuthPubKeyCtx->pucData);

        pstAuthPubKeyCtx->usParaLen = usTotalLen;
        pstAuthPubKeyCtx->pucData   = pTempData;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetFacAuthPubkeyExPara(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulCurrIndex,
    VOS_UINT32                          ulTotal,
    VOS_UINT32                          ulParaLen,
    VOS_UINT8                          *pucPubKeyData
)
{
    AT_AUTH_PUBKEYEX_CMD_PROC_CTX          *pstAuthPubKeyCtx = VOS_NULL_PTR;
    DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU   *pstFacAuthPubkeySetReq = VOS_NULL_PTR;
    VOS_UINT32                              ulResult;
    VOS_UINT32                              ulTempIndex;
    VOS_UINT32                              ulTimerName;
    errno_t                                 lMemResult;

    ulTempIndex  = (VOS_UINT32)ucIndex;
    ulTimerName  = AT_AUTH_PUBKEY_TIMER;
    ulTimerName |= AT_INTERNAL_PROCESS_TYPE;
    ulTimerName |= (ulTempIndex<<12);


    pstAuthPubKeyCtx = AT_GetAuthPubkeyExCmdCtxAddr();

    /* Index要小于total */
    if (ulCurrIndex > ulTotal)
    {
        AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: Index bigger then total", ulCurrIndex, ulTotal);

        AT_ClearAuthPubkeyCtx();
        (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当前不再设置过程中，第一次收到此命令 */
    if (pstAuthPubKeyCtx->ucSettingFlag == VOS_FALSE)
    {
        if (ulCurrIndex != 1)
        {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: Invalid ulCurrIndex", ulCurrIndex);

            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 将字符串参数转换为码流 */
        ulResult = AT_ProcAuthPubkeyExData(ulParaLen, pucPubKeyData);
        if (ulResult != AT_SUCCESS)
        {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: AT_ProcAuthPubkeyExData fail %d", ulResult);

            return ulResult;
        }

        pstAuthPubKeyCtx->ucClientId    = ucIndex;
        pstAuthPubKeyCtx->ucTotalNum    = (VOS_UINT8)ulTotal;
        pstAuthPubKeyCtx->ucCurIdx      = (VOS_UINT8)ulCurrIndex;
        pstAuthPubKeyCtx->ucSettingFlag = VOS_TRUE;
    }
    else
    {
        /* 必须在同一个通道下发命令 */
        if (ucIndex != pstAuthPubKeyCtx->ucClientId)
        {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: port error, ucIndex %d ucClientId, %d", ucIndex, pstAuthPubKeyCtx->ucClientId);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 当前已经在设置中，当前下发的total与之前之前下发的total不同 */
        if ((VOS_UINT8)ulTotal != pstAuthPubKeyCtx->ucTotalNum)
        {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: total %d wrong, %d", ulTotal, pstAuthPubKeyCtx->ucTotalNum);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 当前下发的Index不是之前下发Index+1 */
        if ((VOS_UINT8)ulCurrIndex != (pstAuthPubKeyCtx->ucCurIdx + 1))
        {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: CurrIndex %d wrong, %d", ulCurrIndex, pstAuthPubKeyCtx->ucCurIdx);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 将字符串参数转换为码流 */
        ulResult = AT_ProcAuthPubkeyExData(ulParaLen, pucPubKeyData);
        if (ulResult != AT_SUCCESS)
        {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: AT_ProcAuthPubkeyExData fail %d", ulResult);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return ulResult;
        }

        /* 更新CurrIndex */
        pstAuthPubKeyCtx->ucCurIdx      = (VOS_UINT8)ulCurrIndex;
    }

    /* 如果还未收齐数据，则启动定时器，回复OK */
    if (pstAuthPubKeyCtx->ucCurIdx < pstAuthPubKeyCtx->ucTotalNum)
    {
        (VOS_VOID)AT_StartRelTimer(&(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer),
                                   AT_AUTH_PUBKEY_PROTECT_TIMER_LEN,
                                   ulTimerName,
                                   0, VOS_RELTIMER_NOLOOP);
        return AT_OK;
    }
    else
    {
        /* 已经收齐了数据，转换码流后发给C核 */
        ulResult = At_AsciiNum2HexString(pstAuthPubKeyCtx->pucData, &pstAuthPubKeyCtx->usParaLen);
        if ((ulResult != AT_SUCCESS)
         || (pstAuthPubKeyCtx->usParaLen != (DRV_AGENT_PUBKEY_LEN + DRV_AGENT_PUBKEY_SIGNATURE_LEN)))
        {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: At_AsciiNum2HexString fail ulResult: %d ulParaLen: %d",
                         ulResult,
                         pstAuthPubKeyCtx->usParaLen);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /*lint -save -e516 */
        pstFacAuthPubkeySetReq = (DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU));
        /*lint -restore */
        if (pstFacAuthPubkeySetReq == VOS_NULL_PTR)
        {
            AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: alloc mem fail.");

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_ERROR;
        }

        lMemResult = memcpy_s(pstFacAuthPubkeySetReq, sizeof(DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU), pstAuthPubKeyCtx->pucData, pstAuthPubKeyCtx->usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU), pstAuthPubKeyCtx->usParaLen);

        AT_ClearAuthPubkeyCtx();
        (VOS_VOID)AT_StopRelTimer(ulTimerName, &(pstAuthPubKeyCtx->hAuthPubkeyProtectTimer));
        /* 转换成功, 发送跨核消息到C核, 设置产线公钥 */
        ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                          gastAtClientTab[ucIndex].opId,
                                          DRV_AGENT_FACAUTHPUBKEY_SET_REQ,
                                          pstFacAuthPubkeySetReq,
                                          sizeof(DRV_AGENT_FACAUTHPUBKEY_SET_REQ_STRU),
                                          I0_WUEPS_PID_DRV_AGENT);
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstFacAuthPubkeySetReq);
        /*lint -restore */
        if (ulResult != TAF_SUCCESS)
        {
            AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: AT_FillAndSndAppReqMsg fail.");

            return AT_ERROR;
        }

        /* 由于FACAUTHPUBKEYEX特殊处理，需要手动启动定时器*/
        if (At_StartTimer(AT_SET_PARA_TIME, ucIndex) != AT_SUCCESS)
        {
            AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: At_StartTimer fail.");

            return AT_ERROR;
        }

        g_stParseContext[ucIndex].ucClientStatus = AT_FW_CLIENT_STATUS_PEND;

        /* 设置AT模块实体的状态为等待异步返回 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_FACAUTHPUBKEYEX_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
}


VOS_UINT32 AT_SetIdentifyStartPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    VOS_UINT8                           ucOtaFlag = VOS_FALSE;

    AT_PR_LOGI("Rcv Msg");

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (VOS_StrCmp((VOS_CHAR *)g_stATParseCmd.stCmdName.aucCmdName, "^IDENTIFYOTASTART") == 0)
    {
        ucOtaFlag = VOS_TRUE;
    }

    /* 发送跨核消息到C核, 发起鉴权握手 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      DRV_AGENT_IDENTIFYSTART_SET_REQ,
                                      &ucOtaFlag,
                                      sizeof(VOS_UINT8),
                                      I0_WUEPS_PID_DRV_AGENT);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetIdentifyStartPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IDENTIFYSTART_SET;
    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 AT_SetIdentifyEndPara(VOS_UINT8 ucIndex)
{
    errno_t                                                 lMemResult;
    VOS_UINT32                                              ulResult;
    DRV_AGENT_IDENTIFYEND_OTA_SET_REQ_STRU                  stIdentifyEndSetReq;
    VOS_UINT16                                              usLength;

    AT_PR_LOGI("Rcv Msg");

    /* 局部变量初始化 */
    ulResult = VOS_NULL;
    usLength = gastAtParaList[0].usParaLen;
    memset_s(&stIdentifyEndSetReq, sizeof(stIdentifyEndSetReq), 0x00, sizeof(DRV_AGENT_IDENTIFYEND_OTA_SET_REQ_STRU));

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数错误 */
    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 检查码流参数长度 */
    if (usLength != AT_RSA_CIPHERTEXT_PARA_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串参数转换为码流 */
    ulResult = At_AsciiNum2HexString(gastAtParaList[0].aucPara, &usLength);
    if ( (ulResult != AT_SUCCESS) || (usLength != DRV_AGENT_RSA_CIPHERTEXT_LEN) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    lMemResult = memcpy_s(stIdentifyEndSetReq.stRsa.aucRsaText,
                          sizeof(stIdentifyEndSetReq.stRsa.aucRsaText),
                          gastAtParaList[0].aucPara,
                          DRV_AGENT_RSA_CIPHERTEXT_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stIdentifyEndSetReq.stRsa.aucRsaText), DRV_AGENT_RSA_CIPHERTEXT_LEN);

    if (VOS_StrCmp((VOS_CHAR *)g_stATParseCmd.stCmdName.aucCmdName, "^IDENTIFYOTAEND") == 0)
    {
        stIdentifyEndSetReq.ucOtaFlag = VOS_TRUE;
    }

    /* 发送跨核消息到C核, 完成产线鉴权 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      DRV_AGENT_IDENTIFYEND_SET_REQ,
                                      &stIdentifyEndSetReq,
                                      sizeof(DRV_AGENT_IDENTIFYEND_OTA_SET_REQ_STRU),
                                      I0_WUEPS_PID_DRV_AGENT);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetIdentifyEndPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IDENTIFYEND_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetSimlockDataWritePara(
    VOS_UINT8                           ucIndex,
    AT_SIMLOCKDATAWRITE_SET_REQ_STRU   *pstSimlockDataWrite
)
{
    return AT_OK;
}


VOS_UINT32 AT_CheckPhonePhyNumPara(DRV_AGENT_PH_PHYNUM_TYPE_ENUM_UINT8 *penSetType)
{
    /* <type>参数检查: 支持设置物理号IMEI或SN，否则, 直接返回物理号类型错误 */
    /* 全部格式化为大写字符 */
    if (At_UpString(gastAtParaList[0].aucPara, gastAtParaList[0].usParaLen) == AT_FAILURE)
    {
        return AT_PERSONALIZATION_PH_PHYNUM_TYPE_ERROR;
    }

    if (VOS_StrCmp((VOS_CHAR *)gastAtParaList[0].aucPara, "IMEI") == 0)
    {
        *penSetType = DRV_AGENT_PH_PHYNUM_IMEI;
    }
    else if (VOS_StrCmp((VOS_CHAR *)gastAtParaList[0].aucPara, "SN") == 0)
    {
        *penSetType = DRV_AGENT_PH_PHYNUM_SN;
    }
    else
    {
        AT_NORM_LOG("AT_CheckPhonePhyNumPara: the type of physical is error.");
        return AT_PERSONALIZATION_PH_PHYNUM_TYPE_ERROR;
    }

    /* 参数长度检查 */
    if (gastAtParaList[1].usParaLen != AT_RSA_CIPHERTEXT_PARA_LEN)
    {
        AT_NORM_LOG1("AT_CheckPhonePhyNumPara: rsa para len error.", gastAtParaList[1].usParaLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[2].usParaLen != AT_SET_SIMLOCK_DATA_HMAC_LEN)
    {
        AT_NORM_LOG1("AT_CheckPhonePhyNumPara: hmac len error.", gastAtParaList[2].usParaLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}



VOS_UINT32 AT_SetPhonePhynumPara(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulResult;
    VOS_UINT32                          ulCheckParaRst;
    DRV_AGENT_PHONEPHYNUM_SET_REQ_STRU  stPhonePhynumSetReq;
    VOS_UINT16                          usLength;

    /* 局部变量初始化 */
    ulResult        = VOS_NULL;
    ulCheckParaRst  = VOS_NULL;
    usLength        = gastAtParaList[1].usParaLen;
    memset_s(&stPhonePhynumSetReq, sizeof(stPhonePhynumSetReq), 0x00, sizeof(DRV_AGENT_PHONEPHYNUM_SET_REQ_STRU));

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    AT_PR_LOGI("Rcv Msg");

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数错误 */
    if (gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulCheckParaRst = AT_CheckPhonePhyNumPara(&(stPhonePhynumSetReq.enPhynumType));
    if (ulCheckParaRst != AT_SUCCESS)
    {
        return ulCheckParaRst;
    }

    /* 将RSA字符串参数转换为码流 */
    ulResult = At_AsciiNum2HexString(gastAtParaList[1].aucPara, &usLength);
    if ( (ulResult != AT_SUCCESS) || (usLength != DRV_AGENT_RSA_CIPHERTEXT_LEN) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    lMemResult = memcpy_s(stPhonePhynumSetReq.aucPhynumValue,
                          sizeof(stPhonePhynumSetReq.aucPhynumValue),
                          gastAtParaList[1].aucPara,
                          DRV_AGENT_RSA_CIPHERTEXT_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPhonePhynumSetReq.aucPhynumValue), DRV_AGENT_RSA_CIPHERTEXT_LEN);
    stPhonePhynumSetReq.ulRsaIMEILen = DRV_AGENT_RSA_CIPHERTEXT_LEN;

    /* 将HMAC字符串参数转换为码流 */
    usLength = gastAtParaList[2].usParaLen;
    ulResult = At_AsciiNum2HexString(gastAtParaList[2].aucPara, &usLength);
    if ( (ulResult != AT_SUCCESS) || (usLength != DRV_AGENT_HMAC_DATA_LEN) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    lMemResult = memcpy_s(stPhonePhynumSetReq.aucHmacData,
                          sizeof(stPhonePhynumSetReq.aucHmacData),
                          gastAtParaList[2].aucPara,
                          DRV_AGENT_HMAC_DATA_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stPhonePhynumSetReq.aucHmacData), DRV_AGENT_HMAC_DATA_LEN);
    stPhonePhynumSetReq.ulHmacLen = DRV_AGENT_HMAC_DATA_LEN;

    /* 发送跨核消息到C核, 完成产线鉴权 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      DRV_AGENT_PHONEPHYNUM_SET_REQ,
                                      &stPhonePhynumSetReq,
                                      sizeof(DRV_AGENT_PHONEPHYNUM_SET_REQ_STRU),
                                      I0_WUEPS_PID_DRV_AGENT);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetPhonePhynumPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PHONEPHYNUM_SET;
    return AT_WAIT_ASYNC_RETURN;

}


#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetApSimStPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                              ulResult;
    DRV_AGENT_AP_SIMST_SET_REQ_STRU         stApSimStSetReq;

    /* 局部变量初始化 */
    memset_s(&stApSimStSetReq, sizeof(stApSimStSetReq), 0x00, sizeof(DRV_AGENT_AP_SIMST_SET_REQ_STRU));

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_ERROR;
    }

     /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_ERROR;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    /* 参数设置为1时，目前不支持，直接返回OK */
    if (gastAtParaList[0].ulParaValue == 1)
    {
        stApSimStSetReq.ulUsimState = DRV_AGENT_USIM_OPERATE_ACT;
    }
    else
    {
        stApSimStSetReq.ulUsimState = DRV_AGENT_USIM_OPERATE_DEACT;
    }

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      DRV_AGENT_AP_SIMST_SET_REQ,
                                      &stApSimStSetReq,
                                      sizeof(DRV_AGENT_AP_SIMST_SET_REQ_STRU),
                                      I0_WUEPS_PID_DRV_AGENT);
    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetApSimStPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_APSIMST_SET;

    return AT_WAIT_ASYNC_RETURN;

}
#endif


VOS_VOID AT_ConvertMncToNasType(
    VOS_UINT32                          ulMnc,
    VOS_UINT32                          ulMncLen,
    VOS_UINT32                         *pulNasMnc
)
{
    VOS_UINT32                          aulTmp[3];
    VOS_UINT32                          ulLoop;

    *pulNasMnc  = 0;

    for (ulLoop = 0; ulLoop < 3 ; ulLoop++ )
    {
        aulTmp[ulLoop] = ulMnc & 0x0f;
        ulMnc        >>=  4;
    }

    if (aulTmp[2] == 0x0000000F)
    {
        *pulNasMnc = 0x000F0000 | ((VOS_UINT32)aulTmp[0] << 8) | ((VOS_UINT32)aulTmp[1]);
    }
    else
    {
        *pulNasMnc = aulTmp[2] | ((VOS_UINT32)aulTmp[1] << 8) | ((VOS_UINT32)aulTmp[0] << 16);
    }

    return;
}


VOS_VOID AT_ConvertMccToNasType(
    VOS_UINT32                          ulMcc,
    VOS_UINT32                         *pulNasMcc
)
{
    VOS_UINT32                          aulTmp[3];
    VOS_UINT32                          i;

    *pulNasMcc  = 0;

    for (i = 0; i < 3 ; i++ )
    {
        aulTmp[i]       = ulMcc & 0x0f;
        ulMcc         >>=  4;
    }

    *pulNasMcc  = aulTmp[2]
             |((VOS_UINT32)aulTmp[1] << 8)
             |((VOS_UINT32)aulTmp[0] << 16);

}


VOS_UINT32 AT_SetNvmEccNumPara(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulRst;
    VOS_UINT32                          ulTemp;
    VOS_UINT32                          ulMcc;
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_APP_CUSTOM_ECC_NUM_REQ_STRU stEccNumReq;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stEccNumReq, sizeof(stEccNumReq), 0x00, sizeof(stEccNumReq));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_ERR_LOG("AT_SetNvmEccNumSetPara: Cmd Opt Type is wrong.");
        return AT_ERROR;
    }

    /* 参数过多 */
    if ( (gucAtParaIndex < 6) || (gucAtParaIndex > 7) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数合法性检查, index > total认为设置无效 */
    if (gastAtParaList[0].ulParaValue > gastAtParaList[1].ulParaValue)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<ecc_num>过长，直接返回错误 */
    if(gastAtParaList[2].usParaLen > (MN_CALL_MAX_BCD_NUM_LEN * 2))
    {
        AT_ERR_LOG("AT_SetNvmEccNumSetPara: ecc_num too long.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将ECC NUM转换为BCD码 */
    if (AT_AsciiNumberToBcd((TAF_CHAR*)&gastAtParaList[2].aucPara[0],
                            stEccNumReq.stEccNum.aucBcdNum,
                            &stEccNumReq.stEccNum.ucNumLen) != MN_ERR_NO_ERROR)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulTemp  = 0;
    ulTemp |= (gastAtParaList[5].ulParaValue % 10);
    ulTemp |= (((gastAtParaList[5].ulParaValue /10) % 10) << 4);
    ulTemp |= (((gastAtParaList[5].ulParaValue /100) % 10) << 8);

    /* 将MCC转化为NAS结构 */
    AT_ConvertMccToNasType(ulTemp, &ulMcc);

    stEccNumReq.ucIndex         = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stEccNumReq.ucTotal         = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    stEccNumReq.ucCategory      = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    stEccNumReq.ucSimPresent    = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    stEccNumReq.ulMcc           = ulMcc;

    if (gucAtParaIndex == 7)
    {
        stEccNumReq.ucAbnormalServiceFlg    = (VOS_UINT8)gastAtParaList[6].ulParaValue;
    }
    else
    {
        /* 默认有卡非正常服务状态时紧急呼号码标示默认值为FALSE */
        stEccNumReq.ucAbnormalServiceFlg    = VOS_FALSE;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送消息 */
    ulRst = TAF_CCM_CallCommonReq(&stCtrl,
                                  &stEccNumReq,
                                  ID_TAF_CCM_CUSTOM_ECC_NUM_REQ,
                                  sizeof(stEccNumReq),
                                  enModemId);

    if (ulRst != MN_ERR_NO_ERROR)
    {
        AT_WARN_LOG("AT_SetNvmEccNumPara: TAF_CCM_CallCommonReq fail.");
        return AT_ERROR;
    }

    /* 设置结束直接返回OK */
    return AT_OK;
}


VOS_UINT32 AT_SetCposPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_AGPS_CTX_STRU             *pstAgpsCtx = VOS_NULL_PTR;

    pstAgpsCtx = AT_GetModemAgpsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 为准备输入的XML码流申请内存 */
    pstAgpsCtx->stXml.pcXmlTextHead = (VOS_CHAR *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_XML_MAX_LEN);
    if (pstAgpsCtx->stXml.pcXmlTextHead == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetCposPara: Memory malloc failed!");
        return AT_ERROR;
    }
    pstAgpsCtx->stXml.pcXmlTextCur  = pstAgpsCtx->stXml.pcXmlTextHead;

    /* 切换为AGPS XML码流输入模式 */
    At_SetMode(ucIndex, AT_CMD_MODE, AT_XML_MODE);

    /* 返回提示XML码流输入状态 */
    return AT_WAIT_XML_INPUT;
}


VOS_UINT32 AT_SetCposrPara(VOS_UINT8 ucIndex)
{
    AT_MODEM_AGPS_CTX_STRU             *pstAgpsCtx = VOS_NULL_PTR;

    TAF_NVIM_XCPOSRRPT_CFG_STRU         stXcposrRptCfg;
    memset_s(&stXcposrRptCfg, (VOS_SIZE_T)sizeof(stXcposrRptCfg), 0x00, (VOS_SIZE_T)sizeof(stXcposrRptCfg));

    pstAgpsCtx = AT_GetModemAgpsCtxAddrFromClientId(ucIndex);

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    pstAgpsCtx->enCposrReport = (AT_CPOSR_FLG_ENUM_UNIT8)gastAtParaList[0].ulParaValue;

    /* 读取NV项 */
    if ( TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_XCPOSRRPT_CFG, &stXcposrRptCfg, (VOS_SIZE_T)sizeof(stXcposrRptCfg)) == NV_OK)
    {
        stXcposrRptCfg.ucCposrDefault = pstAgpsCtx->enCposrReport;
        if ( TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_XCPOSRRPT_CFG, &stXcposrRptCfg, (VOS_SIZE_T)sizeof(stXcposrRptCfg)) != NV_OK)
        {
            AT_ERR_LOG("AT_SetCposrPara: write en_NV_Item_XCPOSRRPT_CFG Error");
        }
    }
    else
    {
        AT_ERR_LOG("AT_SetCposrPara: read en_NV_Item_XCPOSRRPT_CFG Error");
    }

    return AT_OK;
}



VOS_UINT32 AT_SetXcposrPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    AT_MTA_SET_XCPOSR_REQ_STRU          stSetXcposr;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if( gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stSetXcposr, sizeof(stSetXcposr), 0x00, sizeof(stSetXcposr));

    stSetXcposr.enXcposrEnableCfg = (AT_MTA_XCPOSR_CFG_ENUM_UNIT8)gastAtParaList[0].ulParaValue;

    /* 发送跨核消息到C核, 设置保存模式 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_XCPOSR_SET_REQ,
                                      &stSetXcposr,
                                      sizeof(stSetXcposr),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetXcposrPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_XCPOSR_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetXcposrRptPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    AT_MTA_SET_XCPOSRRPT_REQ_STRU       stSetXcposrRpt;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if( gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stSetXcposrRpt, sizeof(stSetXcposrRpt), 0x00, sizeof(stSetXcposrRpt));

    stSetXcposrRpt.ucXcposrRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送跨核消息到C核, 设置保存模式 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_XCPOSRRPT_SET_REQ,
                                      &stSetXcposrRpt,
                                      sizeof(stSetXcposrRpt),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetXcposrRptPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_XCPOSRRPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_AGPS == FEATURE_ON)
#if (FEATURE_AGPS_GPIO == FEATURE_ON)

gps_rat_mode_enum AT_SysModeToGpsRatMode(
    TAF_SYS_MODE_ENUM_UINT8             enSysMode
)
{
    gps_rat_mode_enum                   enRatMode;

    enRatMode = gps_rat_mode_butt;

    switch (enSysMode)
    {
        case TAF_PH_INFO_GSM_RAT:
            enRatMode = gps_rat_mode_gsm;
            break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case TAF_PH_INFO_CDMA_1X_RAT:
        case TAF_PH_INFO_HRPD_RAT:
        case TAF_PH_INFO_HYBRID_RAT:
            enRatMode = gps_rat_mode_cdma;
            break;
#endif

        case TAF_PH_INFO_WCDMA_RAT:
            enRatMode = gps_rat_mode_wcdma;
            break;

        case TAF_PH_INFO_TD_SCDMA_RAT:
            enRatMode = gps_rat_mode_tdscdma;
            break;

        case TAF_PH_INFO_LTE_RAT:
        case TAF_PH_INFO_SVLTE_SRLTE_RAT:
            enRatMode = gps_rat_mode_lte;
            break;

        default:
            enRatMode = gps_rat_mode_butt;
            break;
    }

    return enRatMode;
}


gps_rat_mode_enum AT_MtaAtRatModeToGpsRatMode(
    MTA_AT_RAT_MODE_ENUM_UINT8          enMtaAtRatMode
)
{
    gps_rat_mode_enum                   enRatMode;

    enRatMode = gps_rat_mode_butt;

    switch (enMtaAtRatMode)
    {
        case MTA_AT_RAT_MODE_GSM:
            enRatMode = gps_rat_mode_gsm;
            break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case MTA_AT_RAT_MODE_CDMA_1X:
        case MTA_AT_RAT_MODE_HRPD:
            enRatMode = gps_rat_mode_cdma;
            break;
#endif

        case MTA_AT_RAT_MODE_WCDMA:
            enRatMode = gps_rat_mode_wcdma;
            break;

        case MTA_AT_RAT_MODE_TDSCDMA:
            enRatMode = gps_rat_mode_tdscdma;
            break;

        case MTA_AT_RAT_MODE_LTE:
            enRatMode = gps_rat_mode_lte;
            break;

        default:
            enRatMode = gps_rat_mode_butt;
            break;
    }

    return enRatMode;
}
#endif/* #if (FEATURE_AGPS_GPIO == FEATURE_ON) */


VOS_INT AT_SetCgpsClock(
    VOS_BOOL                            bEnableFlg,
    MTA_AT_MODEM_ID_ENUM_UINT8          enModemId,
    MTA_AT_RAT_MODE_ENUM_UINT8          enSysMode
)
{
#if (FEATURE_AGPS_GPIO == FEATURE_ON)
    gps_modem_id_enum                   enGpsModemId;
    gps_rat_mode_enum                   enRatMode;

    switch (enModemId)
    {
        case MTA_AT_MODEM_ID_0:
            enGpsModemId = gps_modem_id_0;
            break;

        case MTA_AT_MODEM_ID_1:
            enGpsModemId = gps_modem_id_1;
            break;

        case MTA_AT_MODEM_ID_2:
            enGpsModemId = gps_modem_id_2;
            break;

        default:
            enGpsModemId = gps_modem_id_0;
            break;
    }

    enRatMode = AT_MtaAtRatModeToGpsRatMode(enSysMode);

    return set_gps_ref_clk_enable((bool)bEnableFlg, enGpsModemId, enRatMode);
#else
    AT_ERR_LOG("AT_SetCgpsClock: MBB not support ^CGPSCLOCK!");
    return VOS_ERR;
#endif
}


VOS_INT AT_CfgGpsRefClk(
    VOS_BOOL                            bEnableFlg,
    MODEM_ID_ENUM_UINT16                enModemId,
    TAF_SYS_MODE_ENUM_UINT8             enSysMode
)
{
#if (FEATURE_AGPS_GPIO == FEATURE_ON)
    gps_modem_id_enum                   enGpsModemId;
    gps_rat_mode_enum                   enRatMode;

    switch (enModemId)
    {
        case MODEM_ID_0:
            enGpsModemId = gps_modem_id_0;
            break;

        case MODEM_ID_1:
            enGpsModemId = gps_modem_id_1;
            break;

        case MODEM_ID_2:
            enGpsModemId = gps_modem_id_2;
            break;

        default:
            enGpsModemId = gps_modem_id_0;
            break;
    }

    enRatMode = AT_SysModeToGpsRatMode(enSysMode);

    return set_gps_ref_clk_enable((bool)bEnableFlg, enGpsModemId, enRatMode);
#else
    AT_ERR_LOG("AT_CfgGpsRefClk: MBB not support ^CGPSCLOCK!");
    return VOS_ERR;
#endif
}


TAF_NV_GPS_CHIP_TYPE_ENUM_UINT8  At_GetGpsTypeFromNv(
    VOS_UINT32                          ulModemId
)
{
    TAF_NVIM_GPS_CUST_CFG_STRU          stNvimGpsCustCfg;
    VOS_UINT32                          ulRet;

    memset_s(&stNvimGpsCustCfg, sizeof(stNvimGpsCustCfg), 0x00, sizeof(TAF_NVIM_GPS_CUST_CFG_STRU));

    ulRet = TAF_ACORE_NV_READ( ulModemId,
                       en_NV_Item_Gps_Cust_CFG,
                       &stNvimGpsCustCfg,
                       sizeof(stNvimGpsCustCfg) );
    if (ulRet != NV_OK)
    {
        AT_WARN_LOG("At_GetGpsTypeFromNv(): Read en_NV_Item_Gps_Cust_CFG failed! ");
        return TAF_NV_GPS_CHIP_BUTT;
    }

    if (stNvimGpsCustCfg.enGpsChipType >= TAF_NV_GPS_CHIP_BUTT)
    {
        AT_WARN_LOG("At_GetGpsTypeFromNv():WARNING: NV parameter Error!");
        return TAF_NV_GPS_CHIP_BUTT;
    }

    return stNvimGpsCustCfg.enGpsChipType;
}


VOS_UINT32 AT_SetCgpsClockForBroadcom(
    VOS_UINT8                           ucIndex,
    MODEM_ID_ENUM_UINT16                enModemId
)
{
    TAF_AGENT_SYS_MODE_STRU             stSysMode;
    VOS_BOOL                            bEnableflg;

    bEnableflg = VOS_FALSE;

    memset_s(&stSysMode, sizeof(stSysMode), 0x00, sizeof(stSysMode));

    if (TAF_AGENT_GetSysMode(gastAtClientTab[ucIndex].usClientId, &stSysMode) != VOS_OK)
    {
        stSysMode.enRatType     = TAF_PH_INFO_NONE_RAT;
        stSysMode.enSysSubMode  = TAF_SYS_SUBMODE_BUTT;
    }

    if (gastAtParaList[0].ulParaValue == 1)
    {
        bEnableflg = VOS_TRUE;
    }
    else if (gastAtParaList[0].ulParaValue == 0)
    {
        bEnableflg = VOS_FALSE;
    }
    else
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_CfgGpsRefClk(bEnableflg, enModemId, stSysMode.enRatType) != VOS_OK)
    {
        AT_ERR_LOG("AT_SetCgpsClockPara: AT_CfgGpsRefClk failed!");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCgpsClockForHisi1102(
    VOS_UINT8                           ucIndex
)
{

    VOS_UINT32                          ulRet;

    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_CGPSCLOCK_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_UEPS_PID_MTA);
    if (ulRet != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CGPSCLOCK_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif/* #if (FEATURE_AGPS == FEATURE_ON) */


VOS_UINT32 AT_SetCgpsClockPara(VOS_UINT8 ucIndex)
{
#if (FEATURE_AGPS == FEATURE_ON)
    VOS_UINT32                          ulRet;
    MODEM_ID_ENUM_UINT16                enModemId;
    TAF_NV_GPS_CHIP_TYPE_ENUM_UINT8     enGpsChipType;

    enModemId     = MODEM_ID_BUTT;
    enGpsChipType = TAF_NV_GPS_CHIP_BUTT;
    ulRet         = AT_ERROR;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if((gucAtParaIndex != 1) && (gucAtParaIndex != 2))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        enModemId = MODEM_ID_0;
    }

    if(gucAtParaIndex == 1)
    {
        enGpsChipType = At_GetGpsTypeFromNv(enModemId);
        if (enGpsChipType == TAF_NV_GPS_CHIP_HISI1102)
        {
            AT_SetCgpsCLockEnableFlgByModemId(enModemId, (VOS_UINT8)gastAtParaList[0].ulParaValue);
            ulRet = AT_SetCgpsClockForHisi1102(ucIndex);
        }
        else
        {
            ulRet = AT_SetCgpsClockForBroadcom(ucIndex, enModemId);
        }
    }
    else
    {
        if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (AT_SetCgpsClock( (VOS_BOOL)gastAtParaList[0].ulParaValue,
                             (MTA_AT_MODEM_ID_ENUM_UINT8)enModemId,
                             (MTA_AT_RAT_MODE_ENUM_UINT8)gastAtParaList[1].ulParaValue) != VOS_OK )
        {
            ulRet = AT_ERROR;
        }
        else
        {
            ulRet = AT_OK;
        }
    }
    return ulRet;
#else
    AT_ERR_LOG("AT_SetCgpsClockPara: AGPS feature not support!");
    return AT_ERROR;
#endif
}


VOS_UINT32 AT_SetGpsInfoPara(VOS_UINT8 ucIndex)
{
    return AT_OK;
}
/*****************************************************************************
 函 数 名  : AT_SetLogCfgParaEx
 功能描述  : (AT^CFG)AP设置CFG信息
 输入参数  : ulParaValue-设置参数
 输出参数  : 无
 返 回 值  :
 调用函数  :
 被调函数  :

*****************************************************************************/
VOS_UINT32 AT_SetLogCfgParaEx(VOS_UINT32 ulParaValue)
{
    VOS_UINT32 ulRet;
    if (ulParaValue == 0)
    {
        ulRet=(VOS_UINT32)mdrv_socp_set_cfg_ind_mode(SOCP_IND_MODE_DIRECT);
        if(ulRet != VOS_OK)
        {
            PS_PRINTF_WARNING("[socp]at^logcfg=0 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }
    }
    else if (ulParaValue == 1)
    {

        ulRet=(VOS_UINT32)mdrv_socp_set_cfg_ind_mode(SOCP_IND_MODE_DELAY);
        if(ulRet != VOS_OK)
        {
            PS_PRINTF_WARNING("[socp]at^logcfg=1 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }

    }
    else
    {
        ulRet=(VOS_UINT32)mdrv_socp_set_cfg_ind_mode(SOCP_IND_MODE_CYCLE);
        if(ulRet != VOS_OK)
        {
            PS_PRINTF_WARNING("[socp]at^logcfg=2 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }
    }
    return AT_OK;

}

VOS_UINT32 AT_SetLogCfgPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32 enLogPort;
    VOS_UINT32 ulRslt;
    VOS_UINT32 ulRet;
    /* add print by cuijunqiang, for socp timer set, 2016.01.21 */

    PS_PRINTF_INFO("at^logcfg= %d, param %d.\n",gastAtParaList[0].ulParaValue ,ucIndex);

    if((gastAtParaList[0].ulParaValue != SOCP_IND_MODE_DIRECT)&&(gastAtParaList[0].ulParaValue != SOCP_IND_MODE_DELAY)
        &&(gastAtParaList[0].ulParaValue != SOCP_IND_MODE_CYCLE))
    {
         PS_PRINTF_WARNING("<AT_SetLogCfgPara> input param error:%d!\n",gastAtParaList[0].ulParaValue);
         return AT_DIAG_CFG_SET_ERROR;
    }
    ulRslt = mdrv_PPM_QueryLogPort(&enLogPort);
    if( ulRslt != VOS_OK)
    {
        PS_PRINTF_WARNING("get port fail!\n");
        return AT_DIAG_GET_PORT_ERROR;

    }
    if(enLogPort == CPM_OM_PORT_TYPE_USB)
    {
         if (gastAtParaList[0].ulParaValue == SOCP_IND_MODE_DIRECT)
         {
            PS_PRINTF_WARNING("[socp]usb at^logcfg=0!\n");
            return AT_OK;
         }
         else
         {
             PS_PRINTF_WARNING("[socp]usb not support at^logcps=%d!\n",gastAtParaList[0].ulParaValue);
             return AT_DIAG_USB_NOT_SUPPORT_CFG;
         }
    }
    else if(enLogPort == CPM_OM_PORT_TYPE_VCOM)
    {


       ulRet = AT_SetLogCfgParaEx(gastAtParaList[0].ulParaValue);
       return ulRet;

    }
    else
    {
        PS_PRINTF_WARNING("at^logcfg get port error!\n");
        return AT_DIAG_GET_PORT_NOT_USB_OR_VCOM;
    }
}
/*****************************************************************************
 函 数 名  : AT_SetLogCpsParaEx
 功能描述  : enLogPort-端口，ulParaValue-模式
 输入参数  : ucIndex - 用户索引
 输出参数  : 无
 返 回 值  :

*****************************************************************************/
VOS_UINT32 AT_SetLogCpsParaEx(VOS_UINT32 enLogPort,VOS_UINT32 ulParaValue)
{
    VOS_UINT32 ulRet;
    if(enLogPort == CPM_OM_PORT_TYPE_USB)
    {
        if(ulParaValue == 0)
        {

             PS_PRINTF_WARNING("[deflate]usb at^logcps=0!\n");
             return AT_OK;
        }
        else
        {

             PS_PRINTF_WARNING("[deflate]usb not support at^logcps=%d!\n",ulParaValue);
             return AT_DIAG_USB_NOT_SUPPORT_CPS;
        }
    }
    else if(enLogPort == CPM_OM_PORT_TYPE_VCOM)
    {
        if (ulParaValue == 0)
        {
            ulRet=(VOS_UINT32)mdrv_socp_set_cps_ind_mode(DEFLATE_IND_NO_COMPRESS);
            if(ulRet != VOS_OK)
            {
                PS_PRINTF_WARNING("[deflate]vcom at^logcps=0 can not config!\n");
                return AT_DIAG_VCOM_SET_CPS_ERROR;
            }
            return AT_OK;
        }
        else
        {
            ulRet=(VOS_UINT32)mdrv_socp_set_cps_ind_mode(DEFLATE_IND_COMPRESS);
            if(ulRet != VOS_OK)
            {
                PS_PRINTF_WARNING("[deflate]vcom at^logcps=1 can not config!\n");
                return AT_DIAG_VCOM_SET_NOCPS_ERROR;
            }
            return AT_OK;
        }
    }
    else
    {
         PS_PRINTF_WARNING("[deflate]vcom at^logcps=1 can not config!\n");
         return AT_ERROR;

    }
}
/*****************************************************************************
 函 数 名  : AT_SetLogCpsPara
 功能描述  : (AT^LOGCPS)设置压缩模式
 输入参数  : ucIndex - 用户索引
 输出参数  : 无
 返 回 值  :

*****************************************************************************/
VOS_UINT32 AT_SetLogCpsPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32 ulRslt;
    VOS_UINT32 enLogPort;
    VOS_UINT32 ulRet;

    PS_PRINTF_INFO("at^logcps=%d!\n",gastAtParaList[0].ulParaValue);
    if((gastAtParaList[0].ulParaValue != DEFLATE_IND_NO_COMPRESS)
                    &&(gastAtParaList[0].ulParaValue != DEFLATE_IND_COMPRESS))
    {
        PS_PRINTF_WARNING("<AT_SetLogCpsPara> input param error:%d!\n",gastAtParaList[0].ulParaValue);
        return AT_DIAG_CPS_SET_ERROR;
    }
    ulRslt = mdrv_PPM_QueryLogPort(&enLogPort);
    if( ulRslt != VOS_OK)
    {
         PS_PRINTF_WARNING("[deflate]get port fail!\n");
         return AT_DIAG_GET_PORT_ERROR;

    }
    ulRet = AT_SetLogCpsParaEx(enLogPort,gastAtParaList[0].ulParaValue);
    return ulRet;
}


VOS_UINT32 AT_SetLogNvePara(VOS_UINT8 ucIndex)
{
    return AT_OK;
}



VOS_UINT32 AT_SetLogSavePara(VOS_UINT8 ucIndex)
{
    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCISAPara(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulLengthValue,
    VOS_UINT8                          *pucCommand,
    VOS_UINT16                          usCommandLength)
{
    SI_PIH_ISDB_ACCESS_COMMAND_STRU     stCommand;
    errno_t                             lMemResult;
    VOS_UINT16                          usCommandHexLen;

    /* 初始化 */
    memset_s(&stCommand, sizeof(stCommand), 0x00, sizeof(stCommand));

    /* 参数检查 */
    if ( (ulLengthValue > (SI_APDU_MAX_LEN * 2))
       ||(ulLengthValue != usCommandLength) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <command>是ASCII码，做输入参数到HEX的转换 */
    usCommandHexLen =   usCommandLength;
    if (At_AsciiNum2HexString(pucCommand, &usCommandHexLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<length> */
    stCommand.ulLen = usCommandHexLen;

    /* 设置<command> */
    lMemResult = memcpy_s((TAF_VOID *)stCommand.aucCommand, sizeof(stCommand.aucCommand), (TAF_VOID *)pucCommand, (VOS_UINT16)stCommand.ulLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stCommand.aucCommand), (VOS_UINT16)stCommand.ulLen);

    /* 执行命令操作 */
    if(SI_PIH_IsdbAccessReq(gastAtClientTab[ucIndex].usClientId, 0, &stCommand) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CISA_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCISAPara: SI_PIH_IsdbAccessReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCmutPara(VOS_UINT8 ucIndex)
{
    APP_VC_MUTE_STATUS_ENUM_UINT8        enMuteStatus;

    /* 无参数 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者错误 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取命令参数, 提取要设置的静音状态 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        enMuteStatus = APP_VC_MUTE_STATUS_UNMUTED;
    }
    else
    {
        enMuteStatus = APP_VC_MUTE_STATUS_MUTED;
    }

    /* 执行命令操作 */
    if (APP_VC_SetMuteStatus(gastAtClientTab[ucIndex].usClientId,
                             0,
                             enMuteStatus) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CMUT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_PHONE_SC == FEATURE_ON)

VOS_UINT32  AT_SetSimlockUnlockPara( VOS_UINT8 ucIndex )
{
    VOS_UINT32                          ulResult;
    AT_MTA_SIMLOCKUNLOCK_REQ_STRU       stSimlockUnlockSetReq;

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析锁网锁卡解锁参数 */
    if ( (gastAtParaList[0].usParaLen == 0)
      || (gastAtParaList[1].usParaLen != AT_SIMLOCKUNLOCK_PWD_PARA_LEN)
      || (gastAtParaList[0].ulParaValue > AT_MTA_PERS_CATEGORY_SERVICE_PROVIDER) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stSimlockUnlockSetReq, sizeof(stSimlockUnlockSetReq), 0x00, sizeof(AT_MTA_SIMLOCKUNLOCK_REQ_STRU));
    stSimlockUnlockSetReq.enCategory = (AT_MTA_PERS_CATEGORY_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    /* 密码的合法性检查，密码为16个“0”-“9”ASCII字符,密码由ASCII码转换为十进制数字 */
    ulResult = At_AsciiNum2Num(stSimlockUnlockSetReq.aucPassword,
                               gastAtParaList[1].aucPara,
                               gastAtParaList[1].usParaLen);
    if ( ulResult != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送跨核消息到C核, 解锁锁网锁卡 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_SIMLOCKUNLOCK_SET_REQ,
                                      &stSimlockUnlockSetReq,
                                      sizeof(AT_MTA_SIMLOCKUNLOCK_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetSimlockUnlockPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SIMLOCKUNLOCK_SET;
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 AT_FillApdsPara(
    VOS_UINT8                           ucIndex,
    MN_CALL_ORIG_PARAM_STRU            *pstOrigParam
)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    errno_t                             lMemResult;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 默认情况是使用CCA设置的默认值 */
    pstOrigParam->enCallMode  = pstSsCtx->enCModType;
    pstOrigParam->stDataCfg   = pstSsCtx->stCbstDataCfg;
    pstOrigParam->enClirCfg   = pstSsCtx->ucClirType;
    pstOrigParam->stCugCfg    = pstSsCtx->stCcugCfg;

    /* 设置<dial_string> */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return VOS_ERR;
    }
    else
    {
        if (AT_FillCalledNumPara(gastAtParaList[0].aucPara,
                                 gastAtParaList[0].usParaLen,
                                 &pstOrigParam->stDialNumber) != VOS_OK)
        {
            return VOS_ERR;
        }
    }

    /* 检查被叫号码子地址的长度 */
    if (gastAtParaList[1].usParaLen > MN_CALL_MAX_SUBADDR_INFO_LEN)
    {
        return VOS_ERR;
    }

    /* 设置<sub_string> */
    if (gastAtParaList[1].usParaLen != 0)
    {
        pstOrigParam->stSubaddr.IsExist       = VOS_TRUE;

        /* 偏移量 = 子地址编码的长度 + Octet3的长度*/
        pstOrigParam->stSubaddr.LastOctOffset = (VOS_UINT8)gastAtParaList[1].usParaLen + sizeof(pstOrigParam->stSubaddr.Octet3);
        pstOrigParam->stSubaddr.Octet3        = (0x80 | (MN_CALL_SUBADDR_NSAP << 4));
        lMemResult = memcpy_s(pstOrigParam->stSubaddr.SubAddrInfo,
                              MN_CALL_MAX_SUBADDR_INFO_LEN,
                              gastAtParaList[1].aucPara,
                              gastAtParaList[1].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, MN_CALL_MAX_SUBADDR_INFO_LEN, gastAtParaList[1].usParaLen);
    }

    /* 设置<I><G><call_type><voice_domain>参数 */
    if (gastAtParaList[2].usParaLen != 0)
    {
        if (gastAtParaList[2].ulParaValue == 0)
        {
            pstOrigParam->enClirCfg = AT_CLIR_INVOKE;
        }
        else if (gastAtParaList[2].ulParaValue == 1)
        {
            pstOrigParam->enClirCfg = AT_CLIR_SUPPRESS;
        }
        else
        {
            return VOS_ERR;
        }
    }

    if (gastAtParaList[3].usParaLen != 0)
    {
        pstOrigParam->stCugCfg.bEnable    = gastAtParaList[3].ulParaValue;
    }

    if (gastAtParaList[4].usParaLen != 0)
    {
        pstOrigParam->enCallType          = (VOS_UINT8)gastAtParaList[4].ulParaValue;
    }

    if (gastAtParaList[5].usParaLen != 0)
    {
        pstOrigParam->enVoiceDomain       = (VOS_UINT8)gastAtParaList[5].ulParaValue;
    }

    if (gastAtParaList[6].usParaLen != 0)
    {
        pstOrigParam->enServiceType = (VOS_UINT8)gastAtParaList[6].ulParaValue;
    }

    return VOS_OK;
}


VOS_UINT32 AT_FillApdsPara_Part2(
    VOS_UINT8                           ucIndex,
    MN_CALL_ORIG_PARAM_STRU            *pstOrigParam
)
{
    if (gastAtParaList[7].usParaLen != 0)
    {
        pstOrigParam->ucRttFlg = (VOS_UINT8)gastAtParaList[7].ulParaValue;
    }

    if (gastAtParaList[8].usParaLen != 0)
    {
        pstOrigParam->ucCallPullDialogId = (VOS_UINT8)gastAtParaList[8].ulParaValue;
        if( pstOrigParam->ucCallPullDialogId == TAF_APDS_CALL_PULL_DIALOG_ID )
        {
            pstOrigParam->ucCallPullFlg = VOS_FALSE;
        }
        else
        {
            pstOrigParam->ucCallPullFlg = VOS_TRUE;
        }
    }

    if (gastAtParaList[9].usParaLen != 0)
    {
        pstOrigParam->ucEncryptFlag = (VOS_UINT8)gastAtParaList[9].ulParaValue;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetApdsPara(VOS_UINT8 ucIndex)
{
    MN_CALL_ORIG_PARAM_STRU             stOrigParam;
    TAF_CTRL_STRU                       stCtrl;
    VOS_UINT32                          ulRelt;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 初始化 */
    memset_s(&stOrigParam, sizeof(stOrigParam), 0x00, sizeof(MN_CALL_ORIG_PARAM_STRU));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }
     /* 参数过多 */
    if (gucAtParaIndex > 10)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查并填写输入的参数 */
    ulRelt = AT_FillApdsPara(ucIndex, &stOrigParam);
    if (ulRelt == VOS_OK)
    {
        ulRelt = AT_FillApdsPara_Part2(ucIndex, &stOrigParam);
    }

    if (ulRelt != VOS_OK)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息原语 */
    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stOrigParam,
                              ID_TAF_CCM_CALL_ORIG_REQ,
                              sizeof(stOrigParam),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_APDS_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetClprPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_QRY_CLPR_PARA_STRU         stQryClprPara;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stQryClprPara.callId                = (MN_CALL_ID_T)gastAtParaList[0].ulParaValue;
    stQryClprPara.enQryClprModeType     = TAF_CALL_QRY_CLPR_MODE_GUL;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送跨核消息ID_TAF_CCM_QRY_CLPR_REQ到C核 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &stQryClprPara,
                                     ID_TAF_CCM_QRY_CLPR_REQ,
                                     sizeof(stQryClprPara),
                                     enModemId);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetClprPara: TAF_CCM_CallCommonReq fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLPR_SET;

    return AT_WAIT_ASYNC_RETURN;

}


#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetCLteRoamAllowPara(VOS_UINT8 ucIndex)
{
    NAS_MMC_NVIM_LTE_INTERNATIONAL_ROAM_CFG_STRU  stNvimLteRoamAllowedFlg;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_ERROR;
    }

    stNvimLteRoamAllowedFlg.ucLteRoamAllowedFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stNvimLteRoamAllowedFlg.aucReserve[0]       = 0x00;

    /* 写NV:en_NV_Item_Lte_Internation_Roam_Config,
       该NV的结构为 NAS_MMC_NVIM_LTE_INTERNATIONAL_ROAM_CFG_STRU, 只写第1个字节 */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Lte_Internation_Roam_Config,
                          &(stNvimLteRoamAllowedFlg),
                          sizeof(VOS_UINT16)))
    {
        AT_ERR_LOG("AT_SetCLteRoamAllowPara:Write NV fail");
        return AT_ERROR;
    }
    else
    {
        return AT_OK;
    }

}
#endif


VOS_UINT32 At_SetWlthresholdcfgPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                                              ulResult;
    AT_MTA_RESEL_OFFSET_CFG_SET_NTF_STRU                    stReselOffsetCfgNtf;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stReselOffsetCfgNtf, sizeof(stReselOffsetCfgNtf), 0x00, sizeof(stReselOffsetCfgNtf));

    stReselOffsetCfgNtf.ucOffsetFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送消息AT_MTA_RESEL_OFFSET_CFG_SET_REQ_STRU*/
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_RESEL_OFFSET_CFG_SET_NTF,
                                      &stReselOffsetCfgNtf,
                                      sizeof(stReselOffsetCfgNtf),
                                      I0_UEPS_PID_MTA);

#if  (FEATURE_LTE == FEATURE_ON)
    /*L使用参数*/
    At_SetLWThresholdCfgPara(ucIndex);
#endif

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("At_SetWlthresholdcfgPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    return AT_OK;

}



VOS_UINT32 At_SetSwverPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;

    AT_PR_LOGI("Rcv Msg");

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        AT_WARN_LOG("At_SetSwverPara: ucCmdOptType error.");

        return AT_ERROR;
    }

    /* 发消息到C核获取充电状态和电池电量 */
    ulRet = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   DRV_AGENT_SWVER_SET_REQ,
                                   VOS_NULL_PTR,
                                   0,
                                   I0_WUEPS_PID_DRV_AGENT);
    if (ulRet != TAF_SUCCESS)
    {
        AT_WARN_LOG("At_SetSwverPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SWVER_SET;
    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 AT_SetCbgPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    APP_VC_MSG_ENUM_U16                 usMsgName;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取下发VC的消息头名称 */
    if ( gastAtParaList[0].ulParaValue == 0 )
    {
        usMsgName = APP_VC_MSG_SET_FOREGROUND_REQ;
    }
    else
    {
        usMsgName = APP_VC_MSG_SET_BACKGROUND_REQ;
    }

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      usMsgName,
                                      VOS_NULL_PTR,
                                      0,
                                      I0_WUEPS_PID_VC);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetCbgPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CBG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SndMtaBodySarPara(
    VOS_UINT8                           ucIndex,
    AT_MTA_BODY_SAR_STATE_ENUM_UINT16   enBodySarState,
    MTA_BODY_SAR_PARA_STRU             *pstBodySarPara)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulResult;
    AT_MTA_BODY_SAR_SET_REQ_STRU        stBodySarSetReq;

    memset_s(&stBodySarSetReq, sizeof(stBodySarSetReq), 0x00, sizeof(stBodySarSetReq));

    /* 填充消息结构体 */
    stBodySarSetReq.enState = enBodySarState;
    lMemResult = memcpy_s(&stBodySarSetReq.stBodySARPara, sizeof(stBodySarSetReq.stBodySARPara), pstBodySarPara, sizeof(MTA_BODY_SAR_PARA_STRU));
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stBodySarSetReq.stBodySARPara), sizeof(MTA_BODY_SAR_PARA_STRU));

    /* 发送消息AT_MTA_BODY_SAR_SET_REQ_STRU */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_BODY_SAR_SET_REQ,
                                      &stBodySarSetReq,
                                      sizeof(AT_MTA_BODY_SAR_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SndMtaBodySarPara: AT_FillAndSndAppReqMsg fail.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetBodySarOnPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    MTA_BODY_SAR_PARA_STRU              stBodySarPara;

    memset_s(&stBodySarPara, sizeof(stBodySarPara), 0x00, sizeof(stBodySarPara));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 判断BODYSAR当前状态 */
    if (g_enAtBodySarState == gastAtParaList[0].ulParaValue)
    {
        return AT_OK;
    }

    /* 读取BODYSAR NV项 */
    ulResult = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_BODY_SAR_PARA,
                         &stBodySarPara,
                         sizeof(MTA_BODY_SAR_PARA_STRU));

    if (ulResult != NV_OK)
    {
        AT_ERR_LOG("AT_SetBodySarOnPara: Read NV fail");
        return AT_ERROR;
    }

    /* 发送消息给MTA */
    ulResult = AT_SndMtaBodySarPara(ucIndex,
                                    (AT_MTA_BODY_SAR_STATE_ENUM_UINT16)gastAtParaList[0].ulParaValue,
                                    &stBodySarPara);
    if (ulResult != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_BODYSARON_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckBodySarWcdmaPara(
    AT_BODYSARWCDMA_SET_PARA_STRU      *pstBodySarWcdmaPara)
{
    AT_NV_WG_RF_MAIN_BAND_STRU          stWGBand;
    VOS_UINT8                           ucLoop;
    VOS_UINT32                          ulLen;
    errno_t                             lMemResult;

    memset_s(&stWGBand, sizeof(stWGBand), 0x00, sizeof(stWGBand));

    /* 参数个数检查 */
    if ( (gucAtParaIndex < 1)
      || (gucAtParaIndex > AT_BODYSARWCDMA_MAX_PARA_NUM) )
    {
        AT_WARN_LOG1("AT_CheckBodySarWcdmaPara: Para Num Incorrect!", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当参数个数为1时，补充默认值 */
    if (gucAtParaIndex == 1)
    {
        ulLen = VOS_StrLen(AT_RF_BAND_ANY_STR);
        lMemResult = memcpy_s(gastAtParaList[1].aucPara,
                              sizeof(gastAtParaList[1].aucPara),
                              AT_RF_BAND_ANY_STR,
                              ulLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(gastAtParaList[1].aucPara), ulLen);
        gastAtParaList[1].aucPara[ulLen]    = '\0';
        gastAtParaList[1].usParaLen         = (VOS_UINT16)ulLen;
        gucAtParaIndex                      = 2;
    }

    /* 参数个数必须为偶数 */
    if ((gucAtParaIndex % 2) != 0)
    {
        AT_WARN_LOG1("AT_CheckBodySarWcdmaPara: Para Num is not Even!", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取WCDMA Band能力值 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WG_RF_MAIN_BAND,
                           &stWGBand,
                           sizeof(stWGBand)))
    {
        AT_ERR_LOG("AT_CheckBodySarWcdmaPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 循环检查Band频段是否支持，并填充参数结构体 */
    pstBodySarWcdmaPara->ucParaNum = 0;
    for (ucLoop = 0; ucLoop < (gucAtParaIndex / 2); ucLoop++)
    {
        /* 将用户输入的频段参数由16进制字符串转换为数字 */
        if (At_String2Hex(gastAtParaList[ucLoop * 2 + 1].aucPara,
                          gastAtParaList[ucLoop * 2 + 1].usParaLen,
                          &gastAtParaList[ucLoop * 2 + 1].ulParaValue) != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果用户输入的是任意Band频段，则替换为当前支持的Band频段值 */
        if (gastAtParaList[ucLoop * 2 + 1].ulParaValue == AT_RF_BAND_ANY)
        {
            gastAtParaList[ucLoop * 2 + 1].ulParaValue = stWGBand.unWcdmaBand.ulBand;
        }

        /* 检查用户输入的频段当前是否支持，如果不支持返回参数错误 */
        if ((gastAtParaList[ucLoop * 2 + 1].ulParaValue & (~stWGBand.unWcdmaBand.ulBand)) != 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pstBodySarWcdmaPara->asPower[pstBodySarWcdmaPara->ucParaNum]    = (VOS_INT16)gastAtParaList[ucLoop * 2].ulParaValue;
        pstBodySarWcdmaPara->aulBand[pstBodySarWcdmaPara->ucParaNum]    = gastAtParaList[ucLoop * 2 + 1].ulParaValue;
        pstBodySarWcdmaPara->ucParaNum++;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillBodySarWcdmaPara(
    AT_BODYSARWCDMA_SET_PARA_STRU      *pstBodySarWcdmaPara,
    MTA_BODY_SAR_PARA_STRU             *pstBodySarPara)
{
    VOS_UINT8                           ucLoop1;
    MTA_WCDMA_BAND_ENUM_UINT16          enLoop2;
    VOS_UINT8                           ucLoop3;

    /* 遍历命令所有的参数 */
    for (ucLoop1 = 0; ucLoop1 < pstBodySarWcdmaPara->ucParaNum; ucLoop1++)
    {
        /* 按照WCDMA Band来填充参数 */
        for (enLoop2 = MTA_WCDMA_I_2100; enLoop2 < MTA_WCDMA_BAND_BUTT; enLoop2++)
        {
            if ((pstBodySarWcdmaPara->aulBand[ucLoop1] & (0x00000001UL << (enLoop2 - 1))) == 0)
            {
                continue;
            }

            for (ucLoop3 = 0; ucLoop3 < pstBodySarPara->usWBandNum; ucLoop3++)
            {
                if (enLoop2 == pstBodySarPara->astWBandPara[ucLoop3].enBand)
                {
                    break;
                }
            }

            if (ucLoop3 == pstBodySarPara->usWBandNum)
            {
                /* 若超出W Band最大支持个数，则回复失败 */
                if (pstBodySarPara->usWBandNum >= MTA_BODY_SAR_WBAND_MAX_NUM)
                {
                    AT_ERR_LOG("AT_FillBodySarWcdmaPara: Too Many W Band!");
                    return VOS_ERR;
                }

                pstBodySarPara->usWBandNum++;
            }

            pstBodySarPara->astWBandPara[ucLoop3].enBand = enLoop2;
            pstBodySarPara->astWBandPara[ucLoop3].sPower = pstBodySarWcdmaPara->asPower[ucLoop1];
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetBodySarWcdmaPara(VOS_UINT8 ucIndex)
{
    MTA_BODY_SAR_PARA_STRU              stBodySarPara;
    AT_BODYSARWCDMA_SET_PARA_STRU       stBodySarWcdmaPara;
    VOS_UINT32                          ulResult;

    memset_s(&stBodySarPara, sizeof(stBodySarPara), 0x00, sizeof(stBodySarPara));
    memset_s(&stBodySarWcdmaPara, sizeof(stBodySarWcdmaPara), 0x00, sizeof(stBodySarWcdmaPara));

    /* 检查参数有效性 */
    ulResult = AT_CheckBodySarWcdmaPara(&stBodySarWcdmaPara);
    if (ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    /* 从NV项中读取Body SAR功率门限值 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_BODY_SAR_PARA,
                           &stBodySarPara,
                           sizeof(stBodySarPara)))
    {
        AT_ERR_LOG("AT_SetBodysarWcdmaPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 将WCDMA的频段参数填充到Body SAR参数结构体中 */
    if (AT_FillBodySarWcdmaPara(&stBodySarWcdmaPara, &stBodySarPara) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 将Body SAR功率门限值保存到NV */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_BODY_SAR_PARA,
                            &(stBodySarPara),
                            sizeof(stBodySarPara)))
    {
        AT_ERR_LOG("AT_SetBodysarWcdmaPara: Write NV fail!");
        return AT_ERROR;
    }

    /* 如果当前开启了Body SAR功能，则通知物理层新的Body SAR参数 */
    if (g_enAtBodySarState == AT_MTA_BODY_SAR_ON)
    {
        if (AT_SndMtaBodySarPara(ucIndex,
                                 g_enAtBodySarState,
                                 &stBodySarPara) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetBodySarWcdmaPara: AT_SndMtaBodySarPara fail!");
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_GetGsmBandCapa(VOS_UINT32 *pulGBand)
{
    AT_NV_WG_RF_MAIN_BAND_STRU          stWGBand;

    memset_s(&stWGBand, sizeof(stWGBand), 0x00, sizeof(stWGBand));
    *pulGBand = 0;

    /* 从NV项中读取单板支持的频段 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WG_RF_MAIN_BAND,
                           &stWGBand,
                           sizeof(stWGBand)))
    {
        AT_ERR_LOG("AT_GetGsmBandCapa: Read NV fail!");
        return VOS_ERR;
    }

    if (stWGBand.unGsmBand.BitBand.BandGsm850 == VOS_TRUE)
    {
        *pulGBand |= AT_BODY_SAR_GBAND_GPRS_850_MASK;
        *pulGBand |= AT_BODY_SAR_GBAND_EDGE_850_MASK;
    }

    if ( (stWGBand.unGsmBand.BitBand.BandGsmP900 == VOS_TRUE)
      || (stWGBand.unGsmBand.BitBand.BandGsmR900 == VOS_TRUE)
      || (stWGBand.unGsmBand.BitBand.BandGsmE900 == VOS_TRUE) )
    {
        *pulGBand |= AT_BODY_SAR_GBAND_GPRS_900_MASK;
        *pulGBand |= AT_BODY_SAR_GBAND_EDGE_900_MASK;
    }

    if (stWGBand.unGsmBand.BitBand.BandGsm1800 == VOS_TRUE)
    {
        *pulGBand |= AT_BODY_SAR_GBAND_GPRS_1800_MASK;
        *pulGBand |= AT_BODY_SAR_GBAND_EDGE_1800_MASK;
    }

    if (stWGBand.unGsmBand.BitBand.BandGsm1900 == VOS_TRUE)
    {
        *pulGBand |= AT_BODY_SAR_GBAND_GPRS_1900_MASK;
        *pulGBand |= AT_BODY_SAR_GBAND_EDGE_1900_MASK;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckBodySarGsmPara(
    AT_BODYSARGSM_SET_PARA_STRU        *pstBodySarGsmPara)
{
    VOS_UINT32                          ulGBand;
    VOS_UINT8                           ucLoop;
    VOS_UINT32                          ulLen;
    errno_t                             lMemResult;

    ulGBand         = 0;

    /* 参数个数检查 */
    if ( (gucAtParaIndex < 1)
      || (gucAtParaIndex > AT_BODYSARGSM_MAX_PARA_NUM) )
    {
        AT_WARN_LOG1("AT_CheckBodySarGsmPara: Para Num Incorrect!", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当参数个数为1时，补充默认值 */
    if (gucAtParaIndex == 1)
    {
        ulLen = VOS_StrLen(AT_RF_BAND_ANY_STR);
        lMemResult = memcpy_s(gastAtParaList[1].aucPara,
                              sizeof(gastAtParaList[1].aucPara),
                              AT_RF_BAND_ANY_STR,
                              ulLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(gastAtParaList[1].aucPara), ulLen);
        gastAtParaList[1].aucPara[ulLen]    = '\0';
        gastAtParaList[1].usParaLen         = (VOS_UINT16)ulLen;
        gucAtParaIndex                      = 2;
    }

    /* 参数个数必须为偶数 */
    if ((gucAtParaIndex % 2) != 0)
    {
        AT_WARN_LOG1("AT_CheckBodySarGsmPara: Para Num is not Even!", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取GSM Band能力值 */
    if (AT_GetGsmBandCapa(&ulGBand) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 循环检查Band频段是否支持，并填充参数结构体 */
    pstBodySarGsmPara->ucParaNum = 0;
    for (ucLoop = 0; ucLoop < (gucAtParaIndex / 2); ucLoop++)
    {
        /* 将用户输入的频段参数由16进制字符串转换为数字 */
        if (At_String2Hex(gastAtParaList[ucLoop * 2 + 1].aucPara,
                          gastAtParaList[ucLoop * 2 + 1].usParaLen,
                          &gastAtParaList[ucLoop * 2 + 1].ulParaValue) != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果用户输入的是任意Band频段，则替换为当前支持的Band频段值 */
        if (gastAtParaList[ucLoop * 2 + 1].ulParaValue == AT_RF_BAND_ANY)
        {
            gastAtParaList[ucLoop * 2 + 1].ulParaValue = ulGBand;
        }

        /* 检查用户输入的频段当前是否支持，如果不支持返回参数错误 */
        if ((gastAtParaList[ucLoop * 2 + 1].ulParaValue & (~ulGBand)) != 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pstBodySarGsmPara->asPower[pstBodySarGsmPara->ucParaNum]    = (VOS_INT16)gastAtParaList[ucLoop * 2].ulParaValue;
        pstBodySarGsmPara->aulBand[pstBodySarGsmPara->ucParaNum]    = gastAtParaList[ucLoop * 2 + 1].ulParaValue;
        pstBodySarGsmPara->ucParaNum++;
    }

    return AT_SUCCESS;
}


VOS_VOID AT_FillBodySarGsmPara(
    AT_BODYSARGSM_SET_PARA_STRU        *pstBodySarGsmPara,
    MTA_BODY_SAR_PARA_STRU             *pstBodySarPara)
{
    VOS_UINT8                           ucLoop;

    /* 遍历命令所有的参数 */
    for (ucLoop = 0; ucLoop < pstBodySarGsmPara->ucParaNum; ucLoop++)
    {
        if ((AT_BODY_SAR_GBAND_GPRS_850_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_GPRS_850_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_850].sGPRSPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_850_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_EDGE_850_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_850].sEDGEPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_900_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_GPRS_900_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_900].sGPRSPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_900_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_EDGE_900_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_900].sEDGEPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_1800_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_GPRS_1800_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_1800].sGPRSPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_1800_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_EDGE_1800_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_1800].sEDGEPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_1900_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_GPRS_1900_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_1900].sGPRSPower = pstBodySarGsmPara->asPower[ucLoop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_1900_MASK & pstBodySarGsmPara->aulBand[ucLoop]) != 0)
        {
            pstBodySarPara->ulGBandMask |= AT_BODY_SAR_GBAND_EDGE_1900_MASK;
            pstBodySarPara->astGBandPara[AT_GSM_1900].sEDGEPower = pstBodySarGsmPara->asPower[ucLoop];
        }
    }

    return;
}


VOS_UINT32 AT_SetBodySarGsmPara(VOS_UINT8 ucIndex)
{
    MTA_BODY_SAR_PARA_STRU              stBodySarPara;
    AT_BODYSARGSM_SET_PARA_STRU         stBodySarGsmPara;
    VOS_UINT32                          ulResult;

    memset_s(&stBodySarPara, sizeof(stBodySarPara), 0x00, sizeof(stBodySarPara));
    memset_s(&stBodySarGsmPara, sizeof(stBodySarGsmPara), 0x00, sizeof(stBodySarGsmPara));

    /* 检查参数有效性 */
    ulResult = AT_CheckBodySarGsmPara(&stBodySarGsmPara);
    if (ulResult != AT_SUCCESS)
    {
        return ulResult;
    }

    /* 从NV项中读取Body SAR功率门限值 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_BODY_SAR_PARA,
                           &stBodySarPara,
                           sizeof(stBodySarPara)))
    {
        AT_ERR_LOG("AT_SetBodySarGsmPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 将GSM的频段参数填充到Body SAR参数结构体中 */
    AT_FillBodySarGsmPara(&stBodySarGsmPara, &stBodySarPara);

    /* 将Body SAR功率门限值保存到NV */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_BODY_SAR_PARA,
                            &(stBodySarPara),
                            sizeof(stBodySarPara)))
    {
        AT_ERR_LOG("AT_SetBodySarGsmPara: Write NV fail!");
        return AT_ERROR;
    }

    /* 如果当前开启了Body SAR功能，则通知物理层新的Body SAR参数 */
    if (g_enAtBodySarState == AT_MTA_BODY_SAR_ON)
    {
        if (AT_SndMtaBodySarPara(ucIndex,
                                 g_enAtBodySarState,
                                 &stBodySarPara) != VOS_OK)
        {
            AT_WARN_LOG("AT_SetBodySarGsmPara: AT_SndMtaBodySarPara fail!");
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCopnPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRet;
    VOS_UINT16                          usFromIndex = 0;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }
    ulRet = TAF_MMA_QryCopnInfoReq(WUEPS_PID_AT,
                                   gastAtClientTab[ucIndex].usClientId,
                                   usFromIndex,
                                   0);
    if (ulRet != VOS_TRUE)
    {
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COPN_QRY;

    return AT_WAIT_ASYNC_RETURN;

}

VOS_UINT32 AT_SetHistoryFreqPara(VOS_UINT8 ucIndex)
{
    AT_MTA_CLEAR_HISTORY_FREQ_REQ_STRU                      stAtCmd;
    VOS_UINT32                                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_WARN_LOG("AT_SetHistoryFreqPara: WARNING:Input Len invalid!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enMode    = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^CHISFREQ设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_CLEAR_HISTORY_FREQ_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_CLEAR_HISTORY_FREQ_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CLEAR_HISTORY_FREQ;

    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 AT_CommBoosterParaCheck(VOS_VOID)
{
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return VOS_ERR;
    }

    if (gucAtParaIndex != 4)
    {
        return VOS_ERR;
    }

    if ((gastAtParaList[1].usParaLen == 0)
     || (gastAtParaList[2].usParaLen == 0)
     || (gastAtParaList[3].usParaLen == 0))
    {
        return VOS_ERR;
    }

    /* gastAtParaList[1]记录字节数，gastAtParaList[2]是字符个数，一个字节占2个字符，这里做一下校验 */
    if ((gastAtParaList[2].ulParaValue != gastAtParaList[3].usParaLen / 2)
     || (gastAtParaList[3].usParaLen % 2 != 0))
    {
        return VOS_ERR;
    }

    /* 字符的个数大于500都是错误参数 */
    if (gastAtParaList[3].usParaLen > AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH)
    {
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetCommBoosterPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_COMM_BOOSTER_SET_REQ_STRU    stCommBoosterSet;
    AT_MTA_COMM_BOOSTER_QUERY_REQ_STRU  stCommBoosterQuery;
    VOS_UINT32                          ulResult;

    if (AT_CommBoosterParaCheck() != VOS_OK)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue == 1)
    {
        memset_s(&stCommBoosterSet, sizeof(stCommBoosterSet), 0x00, sizeof(stCommBoosterSet));
        stCommBoosterSet.usPidIndex = (VOS_UINT16)gastAtParaList[1].ulParaValue;
        stCommBoosterSet.ulLen = gastAtParaList[2].ulParaValue;
        memset_s(stCommBoosterSet.aucDate, AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH, 0x00, sizeof(stCommBoosterSet.aucDate));

        if (At_AsciiString2HexSimple(stCommBoosterSet.aucDate, gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                               0,
                               ID_AT_MTA_COMM_BOOSTER_SET_REQ,
                               &stCommBoosterSet,
                               sizeof(AT_MTA_COMM_BOOSTER_SET_REQ_STRU),
                               I0_UEPS_PID_MTA);
    }
    else
    {
        memset_s(&stCommBoosterQuery, sizeof(stCommBoosterQuery), 0x00, sizeof(stCommBoosterQuery));
        stCommBoosterQuery.usPidIndex = (VOS_UINT16)gastAtParaList[1].ulParaValue;
        stCommBoosterQuery.ulLen = gastAtParaList[2].ulParaValue;
        memset_s(stCommBoosterQuery.aucDate, AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH, 0x00, sizeof(stCommBoosterQuery.aucDate));

        if (At_AsciiString2HexSimple(stCommBoosterQuery.aucDate, gastAtParaList[3].aucPara, gastAtParaList[3].usParaLen) == AT_FAILURE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                           0,
                           ID_AT_MTA_COMM_BOOSTER_QRY_REQ,
                           &stCommBoosterQuery,
                           sizeof(AT_MTA_COMM_BOOSTER_QUERY_REQ_STRU),
                           I0_UEPS_PID_MTA);
    }

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    if (gastAtParaList[0].ulParaValue == 1)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COMM_BOOSTER_SET;
    }
    else
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_COMM_BOOSTER_QRY;
    }

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetNvLoadPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_NVLOAD_SET_REQ_STRU          stAtCmd;
    VOS_UINT32                          ulResult;

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数应为1个，否则返回AT_CME_INCORRECT_PARAMETERS */
    if (gucAtParaIndex != 1)
    {
        AT_WARN_LOG("AT_SetNvLoadPara: At Para Num Error.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

     /* 第1个参数长度不为0，否则返回AT_CME_INCORR ECT_PARAMETERS */
    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_WARN_LOG("AT_SetNvLoadPara: Length = 0");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stAtCmd.ulReqType = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_NVLOAD_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_NVLOAD_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != AT_SUCCESS)
    {
        AT_WARN_LOG("AT_SetNvLoadPara: AT_FillAndSndAppReqMsg Failed!");
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NVLOAD_SET;
    return AT_WAIT_ASYNC_RETURN;

}




VOS_UINT32 AT_SetNCellMonitorPara(VOS_UINT8 ucIndex)
{
    AT_MTA_NCELL_MONITOR_SET_REQ_STRU                       stAtCmd;
    VOS_UINT32                                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.ucSwitch    = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^NCELLMONITOR设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_NCELL_MONITOR_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_NCELL_MONITOR_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NCELL_MONITOR_SET;

    return AT_WAIT_ASYNC_RETURN;

}


#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetSimInsertPara(VOS_UINT8 ucIndex)
{
    TAF_SIM_INSERT_STATE_ENUM_UINT32    enSimInsertState;
    VOS_UINT32                          ulResult;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enSimInsertState = (TAF_SIM_INSERT_STATE_ENUM_UINT32)gastAtParaList[0].ulParaValue;


    ulResult = TAF_MMA_SimInsertReq(WUEPS_PID_AT,
                                    gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    enSimInsertState);
    if (ulResult == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SIMINSERT_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }

}
#endif


VOS_UINT32 At_SetModemLoopPara(VOS_UINT8 ucIndex)
{

    VOS_UINT32                          ulResult;
    VOS_UINT8                           ucModemLoop;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucModemLoop = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    ulResult = APP_VC_SetModemLoop(gastAtClientTab[ucIndex].usClientId,
                                   gastAtClientTab[ucIndex].opId,
                                   ucModemLoop);
    if (ulResult == TAF_SUCCESS)
    {
        return AT_OK;    /* 此命令不需要等待C核回复，直接返回OK */
    }
    else
    {
        return AT_ERROR;
    }

}


VOS_UINT32 At_SetReleaseRrc(VOS_UINT8 ucIndex)
{
    VOS_UINT8                              *pucSystemAppConfig = VOS_NULL_PTR;

    /* 读取NV项中当前产品形态 */
    pucSystemAppConfig = AT_GetSystemAppConfigAddr();

    /* 非ANDROID系统不支持 */
    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID)
    {
        return AT_CMD_NOT_SUPPORT;
    }

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 下发请求 */
    if (At_SndReleaseRrcReq(gastAtClientTab[ucIndex].usClientId,
                            gastAtClientTab[ucIndex].opId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_RELEASE_RRC_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetRefclkfreqPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    AT_MTA_REFCLKFREQ_SET_REQ_STRU      stRefClockReq;

    /* 通道检查 */
    if (AT_IsApPort(ucIndex) == VOS_FALSE)
    {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_ERROR;
    }

    /* 初始化 */
    memset_s(&stRefClockReq, sizeof(stRefClockReq), 0x00, sizeof(stRefClockReq));

    stRefClockReq.enRptFlg = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送跨核消息到C核, 设置GPS参考时钟状态是否主动上报 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_REFCLKFREQ_SET_REQ,
                                      &stRefClockReq,
                                      sizeof(stRefClockReq),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetRefclkfreqPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_REFCLKFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}



VOS_UINT32 At_SetPullomlogrrcPara(VOS_UINT8 ucIndex)
{
    (VOS_VOID)DIAG_LogShowToFile((VOS_BOOL)VOS_TRUE);

    return AT_OK;
}


VOS_UINT32 At_SetDieSNPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           aucDieSN[AT_DIE_SN_LEN];
    VOS_INT32                           i;
    VOS_UINT16                          usLength;

    AT_PR_LOGI("Rcv Msg");

    memset_s(aucDieSN, sizeof(aucDieSN), 0x00, sizeof(aucDieSN));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        AT_WARN_LOG("At_SetDieSNPara: ucCmdOptType error!");

        return AT_ERROR;
    }

    /* 获取DIE SN */
    if (mdrv_efuse_get_dieid(aucDieSN, AT_DIE_SN_LEN) != VOS_OK)
    {
        AT_WARN_LOG("At_SetDieSNPara: Get Die Sn Failed!");

        return AT_ERROR;
    }

    /* 最高位,高4 BIT置0 */
    aucDieSN[AT_DIE_SN_LEN -1] = (aucDieSN[AT_DIE_SN_LEN -1] & 0x0F);

    /* 格式化输出查询结果 */
    usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      "%s: 0x",
                                      g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

    for (i = (AT_DIE_SN_LEN-1); i>=0; i--)
    {
        usLength += (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr + usLength,
                                      "%02x",
                                      aucDieSN[i]);
    }

    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}


VOS_UINT32 At_SetHandleDect(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    VOS_UINT8                           ucHandleType;
    VOS_UINT8                          *pucSystemAppConfig = VOS_NULL_PTR;

    /* 读取NV项中当前产品形态 */
    pucSystemAppConfig = AT_GetSystemAppConfigAddr();

    /* 该命令用来配置phone和pad形态cp侧手持位置，非ANDROID系统不支持 */
    if ( *pucSystemAppConfig != SYSTEM_APP_ANDROID )
    {
        return AT_CMD_NOT_SUPPORT;
    }

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_ERROR;
    }

    /* handletype 取值错误 */
    if (gastAtParaList[0].ulParaValue > AT_MTA_HANDLEDECT_MAX_TYPE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucHandleType = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 发送消息 ID_AT_MTA_HANDLEDECT_SET_REQ 给MTA处理，该消息带参数(VOS_UINT8)gastAtParaList[0].ulParaValue */
    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   ID_AT_MTA_HANDLEDECT_SET_REQ,
                                   (VOS_VOID*)&ucHandleType,
                                   sizeof(ucHandleType),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_HANDLEDECT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

#if (FEATURE_IMS == FEATURE_ON)

TAF_UINT32 AT_SetCiregPara(TAF_UINT8 ucIndex)
{

    AT_IMSA_CIREG_SET_REQ_STRU          stCireg;
    VOS_UINT32                          ulResult;

    memset_s(&stCireg, sizeof(stCireg), 0x00, sizeof(AT_IMSA_CIREG_SET_REQ_STRU));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        stCireg.enCireg = gastAtParaList[0].ulParaValue;

    }
    else
    {
        /* 如果参数为空，默认设置为不主动上报 */
        stCireg.enCireg = AT_IMSA_IMS_REG_STATE_DISABLE_REPORT;
    }


    /* 给IMSA发送+CIREG设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                     0,
                                     ID_AT_IMSA_CIREG_SET_REQ,
                                     &stCireg.enCireg,
                                     sizeof(AT_IMSA_IMS_REG_STATE_REPORT_ENUM_UINT32),
                                     PS_PID_IMSA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CIREG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCirepPara(TAF_UINT8 ucIndex)
{

    AT_IMSA_CIREP_SET_REQ_STRU          stCirep;
    VOS_UINT32                          ulResult;

    memset_s(&stCirep, sizeof(stCirep), 0x00, sizeof(AT_IMSA_CIREP_SET_REQ_STRU));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if(gastAtParaList[0].usParaLen != 0)
    {
        stCirep.enReport = gastAtParaList[0].ulParaValue;

    }
    else
    {
        /* 如果参数为空，默认设置为不主动上报 */
        stCirep.enReport = AT_IMSA_CIREP_REPORT_DISENABLE;
    }


    /* 给IMSA发送+CIREG设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                     0,
                                     ID_AT_IMSA_CIREP_SET_REQ,
                                     &stCirep.enReport,
                                     sizeof(AT_IMSA_CIREP_REPORT_ENUM_UINT32),
                                     PS_PID_IMSA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CIREP_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetVolteimpuPara(TAF_UINT8 ucIndex)
{
    AT_IMSA_VOLTEIMPU_QRY_REQ_STRU      stImpu;
    VOS_UINT32                          ulResult;

    memset_s(&stImpu, sizeof(stImpu), 0x00, sizeof(AT_IMSA_VOLTEIMPU_QRY_REQ_STRU));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 给IMSA发送^VOLTEIMPU设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                     0,
                                     ID_AT_IMSA_VOLTEIMPU_QRY_REQ,
                                     stImpu.aucContent,
                                     sizeof(stImpu.aucContent),
                                     PS_PID_IMSA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IMPU_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCacmimsPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                          i;
    VOS_UINT32                          ulCallNum;
    MN_CALL_ORIG_PARAM_STRU             stOrigParam;
    TAF_CALL_ECONF_DIAL_INFO_STRU       stEconfDialInfo;
    TAF_CTRL_STRU                       stCtrl;
    AT_MODEM_SS_CTX_STRU               *pstSsCtx    = VOS_NULL_PTR;
    VOS_UINT32                          ulResult;
    VOS_UINT32                          ulIndex;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 初始化 */
    memset_s(&stOrigParam, sizeof(stOrigParam), 0x00, sizeof(MN_CALL_ORIG_PARAM_STRU));
    memset_s(&stEconfDialInfo, sizeof(stEconfDialInfo), 0x00, sizeof(stEconfDialInfo));

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不对 */
    /* 参数的个数应该是total_callnum+2 */
    if ((gastAtParaList[0].ulParaValue + 2) != gucAtParaIndex)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 普通多方通话邀请 */
    if (gastAtParaList[1].ulParaValue == 0)
    {
        /* 普通多方通话只能邀请一个用户 */
        if (gastAtParaList[0].ulParaValue != 1)
        {
            AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<dial_string> */
        if (AT_FillCalledNumPara(gastAtParaList[2].aucPara,
                                 gastAtParaList[2].usParaLen,
                                 &stOrigParam.stDialNumber) != VOS_OK)
        {
            AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        stOrigParam.enCallType              = MN_CALL_TYPE_VOICE;
        stOrigParam.enCallMode              = pstSsCtx->enCModType;
        stOrigParam.stDataCfg               = pstSsCtx->stCbstDataCfg;
        stOrigParam.ucImsInvitePtptFlag     = VOS_TRUE;

        stOrigParam.enVoiceDomain           = TAF_CALL_VOICE_DOMAIN_AUTO;


        /* AT向CCM发送呼叫消息 */
        if (TAF_CCM_CallCommonReq(&stCtrl,
                                  &stOrigParam,
                                  ID_TAF_CCM_CALL_ORIG_REQ,
                                  sizeof(stOrigParam),
                                  enModemId) == VOS_OK)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CACMIMS_SET;
            return AT_WAIT_ASYNC_RETURN;
        }
        else
        {
            AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
            return AT_ERROR;
        }
    }
    /* 增强型多方通话邀请 */
    else
    {
        ulCallNum = gastAtParaList[0].ulParaValue;

        /* 默认情况是使用CCA设置的默认值 */
        stEconfDialInfo.enCallMode  = pstSsCtx->enCModType;
        stEconfDialInfo.stDataCfg   = pstSsCtx->stCbstDataCfg;
        stEconfDialInfo.enClirCfg   = pstSsCtx->ucClirType;
        stEconfDialInfo.stCugCfg    = pstSsCtx->stCcugCfg;

        for (i = 0; i < ulCallNum; i++)
        {
            ulIndex = 2 + i;

            if (gastAtParaList[ulIndex].usParaLen == 0)
            {
                AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);

                return AT_CME_INCORRECT_PARAMETERS;
            }

            if (AT_FillCalledNumPara(gastAtParaList[ulIndex].aucPara,
                                     gastAtParaList[ulIndex].usParaLen,
                                     &stEconfDialInfo.stEconfCalllist.astDialNumber[i]) != VOS_OK)
            {
                AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        stEconfDialInfo.stEconfCalllist.ulCallNum = ulCallNum;
        stEconfDialInfo.enCallType                = MN_CALL_TYPE_VOICE;
        stEconfDialInfo.enVoiceDomain             = TAF_CALL_VOICE_DOMAIN_IMS;
        stEconfDialInfo.ucImsInvitePtptFlag       = VOS_TRUE;


        /* AT向CCM发送增强多方通话消息 */
        ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                         &stEconfDialInfo,
                                         ID_TAF_CCM_ECONF_DIAL_REQ,
                                         sizeof(stEconfDialInfo),
                                         enModemId);

        if (ulResult == VOS_OK)
        {
            gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CACMIMS_SET;
            return AT_WAIT_ASYNC_RETURN;
        }
        else
        {
            AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
            return AT_ERROR;
        }

    }
}


VOS_VOID At_MapInputValueToCcwaiMode(
    VOS_UINT32                          ulValue,
    TAF_CALL_CCWAI_MODE_ENUM_UINT8     *penMode
)
{
    switch (ulValue)
    {
        case 0:
            *penMode = TAF_CALL_CCWAI_MODE_DISABLE;
            break;

        case 1:
            *penMode = TAF_CALL_CCWAI_MODE_ENABLE;
            break;

        default:
            *penMode = TAF_CALL_CCWAI_MODE_BUTT;
            break;
    }

    return;
}


VOS_VOID At_MapInputValueToCcwaiSrvClass(
    VOS_UINT32                                              ulValue,
    TAF_CALL_CCWAI_SRV_CLASS_ENUM_UINT8                    *penSrvClass
)
{
    switch (ulValue)
    {
        case 1:
            *penSrvClass = TAF_CALL_CCWAI_SRV_CLASS_VOICE;
            break;

        case 2:
            *penSrvClass = TAF_CALL_CCWAI_SRV_CLASS_VIDEO;
            break;

        case 3:
            *penSrvClass = TAF_CALL_CCWAI_SRV_CLASS_SET_NW;
            break;

        default:
            *penSrvClass = TAF_CALL_CCWAI_SRV_CLASS_BUTT;
            break;
    }

    return;
}

TAF_UINT32 AT_SetCcwaiPara(TAF_UINT8 ucIndex)
{
    VOS_UINT32                      ulResult;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_CCWAI_SET_REQ_STRU         stCcwaiSet;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stCcwaiSet, sizeof(stCcwaiSet), 0x00, sizeof(stCcwaiSet));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    /* 参数过多 */
    if(gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充消息结构体 */
    At_MapInputValueToCcwaiMode(gastAtParaList[0].ulParaValue, &stCcwaiSet.enMode);
    At_MapInputValueToCcwaiSrvClass(gastAtParaList[1].ulParaValue, &stCcwaiSet.enSrvClass);

    if ((stCcwaiSet.enMode == TAF_CALL_CCWAI_MODE_BUTT)
     || (stCcwaiSet.enSrvClass == TAF_CALL_CCWAI_SRV_CLASS_BUTT))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 给CCM发送^CCWAI设置请求 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &stCcwaiSet,
                                     ID_TAF_CCM_CCWAI_SET_REQ,
                                     sizeof(stCcwaiSet),
                                     enModemId);

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCWAI_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetUiccAuthPara(VOS_UINT8 ucIndex)
{
    SI_PIH_UICCAUTH_STRU                stAuthData;
    errno_t                             lMemResult;

    if ((gucAtParaIndex != 3)
        ||(gastAtParaList[1].usParaLen == 0)
        ||(gastAtParaList[2].usParaLen == 0))
    {
        AT_ERR_LOG("AT_SetUiccAuthPara: para check fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[1].aucPara,
                             &gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("AT_SetUiccAuthPara: At_AsciiNum2HexString para1 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[2].aucPara,
                             &gastAtParaList[2].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("AT_SetUiccAuthPara: At_AsciiNum2HexString para2 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[1].usParaLen > SI_AUTH_DATA_MAX)
        ||(gastAtParaList[2].usParaLen > SI_AUTH_DATA_MAX))
    {
        AT_ERR_LOG("AT_SetUiccAuthPara: String Len fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue == SI_PIH_ATUICCAUTH_USIMAKA)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_AKA;
        stAuthData.enAppType    = SI_PIH_UICCAPP_USIM;
    }
    else if (gastAtParaList[0].ulParaValue == SI_PIH_ATUICCAUTH_ISIMAKA)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_AKA;
        stAuthData.enAppType    = SI_PIH_UICCAPP_ISIM;
    }
    else if (gastAtParaList[0].ulParaValue == SI_PIH_ATUICCAUTH_USIMGBA)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_GBA;
        stAuthData.enAppType    = SI_PIH_UICCAPP_USIM;
    }
    else if (gastAtParaList[0].ulParaValue == SI_PIH_ATUICCAUTH_ISIMGBA)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_GBA;
        stAuthData.enAppType    = SI_PIH_UICCAPP_ISIM;
    }
    else
    {
        AT_ERR_LOG("AT_SetUiccAuthPara: Para 1 value fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stAuthData.uAuthData.stAka.ulRandLen = gastAtParaList[1].usParaLen;

    stAuthData.uAuthData.stAka.ulAuthLen = gastAtParaList[2].usParaLen;

    /* GBA和AKA鉴权数据结构是一样的 */
    lMemResult = memcpy_s(stAuthData.uAuthData.stAka.aucRand,
                          sizeof(stAuthData.uAuthData.stAka.aucRand),
                          gastAtParaList[1].aucPara,
                          gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthData.uAuthData.stAka.aucRand), gastAtParaList[1].usParaLen);

    lMemResult = memcpy_s(stAuthData.uAuthData.stAka.aucAuth,
                          sizeof(stAuthData.uAuthData.stAka.aucAuth),
                          gastAtParaList[2].aucPara,
                          gastAtParaList[2].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthData.uAuthData.stAka.aucAuth), gastAtParaList[2].usParaLen);

    if(SI_PIH_UiccAuthReq(gastAtClientTab[ucIndex].usClientId,
                          0,
                          &stAuthData) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UICCAUTH_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
       AT_ERR_LOG("AT_SetUiccAuthPara: SI_PIH_UiccAuthReq fail.");

       return AT_ERROR;
    }
}


VOS_UINT32 AT_SetURSMPara(VOS_UINT8 ucIndex)
{
    SI_PIH_ACCESSFILE_STRU              stCommand;
    errno_t                             lMemResult;
    VOS_UINT16                          usFileID;

    /* 参数过多 */
    if ((gucAtParaIndex > 6)
        ||(gucAtParaIndex < 4))
    {
        AT_ERR_LOG("AT_SetURSMPara: too many para");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[1].ulParaValue == SI_PIH_ACCESS_WRITE)
        &&(gastAtParaList[4].usParaLen == 0))
    {
        AT_ERR_LOG("AT_SetURSMPara: Write para wrong");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[1].ulParaValue == SI_PIH_ACCESS_READ)
        &&(gastAtParaList[4].usParaLen != 0))
    {
        AT_ERR_LOG("AT_SetURSMPara: Read para wrong");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取文件ID前两位 */
    usFileID   = (gastAtParaList[2].ulParaValue >> 8) & (0x00FF);

    /* 输入的文件ID必须是EF文件，前两位不可以是3F/5F/7F */
    if ((usFileID == MFLAB)
       || (usFileID == DFUNDERMFLAB)
       || (usFileID == DFUNDERDFLAB))
    {
        AT_ERR_LOG("AT_SetURSMPara: File Id error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[4].usParaLen != 0)
    {
        if(At_AsciiNum2HexString(gastAtParaList[4].aucPara,
                                 &gastAtParaList[4].usParaLen) == AT_FAILURE)
        {
            AT_ERR_LOG("AT_SetURSMPara: At_AsciiNum2HexString para4 fail.");

            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if (gastAtParaList[5].usParaLen != 0)
    {
        if(At_AsciiNum2HexString(gastAtParaList[5].aucPara,
                                 &gastAtParaList[5].usParaLen) == AT_FAILURE)
        {
            AT_ERR_LOG("AT_SetURSMPara: At_AsciiNum2HexString para5 fail.");

            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if ((gastAtParaList[4].usParaLen > USIMM_T0_APDU_MAX_LEN)
        ||(gastAtParaList[5].usParaLen > USIMM_MAX_PATH_LEN)
        ||(gastAtParaList[0].ulParaValue >= SI_PIH_UICCAPP_BUTT))
    {
        AT_ERR_LOG("AT_SetURSMPara: AT para 4 or 5 is fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCommand.usEfId        = (VOS_UINT16)gastAtParaList[2].ulParaValue;
    stCommand.enAppType     = gastAtParaList[0].ulParaValue;
    stCommand.enCmdType     = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    stCommand.ucRecordNum   = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    stCommand.ulDataLen     = gastAtParaList[4].usParaLen;
    stCommand.usPathLen     = gastAtParaList[5].usParaLen;

    lMemResult = memcpy_s(stCommand.aucCommand, sizeof(stCommand.aucCommand), gastAtParaList[4].aucPara, gastAtParaList[4].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stCommand.aucCommand), gastAtParaList[4].usParaLen);
    lMemResult = memcpy_s(stCommand.ausPath, sizeof(stCommand.ausPath), gastAtParaList[5].aucPara, gastAtParaList[5].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stCommand.ausPath), gastAtParaList[5].usParaLen);

    /* 执行命令操作 */
    if(SI_PIH_AccessUICCFileReq(gastAtClientTab[ucIndex].usClientId,
                                0,
                                &stCommand) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CURSM_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        AT_ERR_LOG("AT_SetURSMPara: SI_PIH_AccessUICCFileReq error.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetKsNafAuthPara(VOS_UINT8 ucIndex)
{
    SI_PIH_UICCAUTH_STRU                stAuthData;
    errno_t                             lMemResult;

    if ((gucAtParaIndex != 3)
        ||(gastAtParaList[1].usParaLen == 0)
        ||(gastAtParaList[2].usParaLen == 0))
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: check para fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[1].aucPara, &gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: At_AsciiNum2HexString para1 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(At_AsciiNum2HexString(gastAtParaList[2].aucPara, &gastAtParaList[2].usParaLen) == AT_FAILURE)
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: At_AsciiNum2HexString para2 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[1].usParaLen > SI_AUTH_DATA_MAX)
        ||(gastAtParaList[2].usParaLen > SI_AUTH_DATA_MAX))
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: Str Len check fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue == SI_PIH_ATKSNAFAUTH_USIM)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_NAF;
        stAuthData.enAppType    = SI_PIH_UICCAPP_USIM;
    }
    else if (gastAtParaList[0].ulParaValue == SI_PIH_ATKSNAFAUTH_ISIM)
    {
        stAuthData.enAuthType   = SI_PIH_UICCAUTH_NAF;
        stAuthData.enAppType    = SI_PIH_UICCAPP_ISIM;
    }
    else
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: Auth type fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stAuthData.uAuthData.stKsNAF.ulNAFIDLen = gastAtParaList[1].usParaLen;

    stAuthData.uAuthData.stKsNAF.ulIMPILen  = gastAtParaList[2].usParaLen;

    lMemResult = memcpy_s(stAuthData.uAuthData.stKsNAF.aucNAFID, sizeof(stAuthData.uAuthData.stKsNAF.aucNAFID), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthData.uAuthData.stKsNAF.aucNAFID), gastAtParaList[1].usParaLen);

    lMemResult = memcpy_s(stAuthData.uAuthData.stKsNAF.aucIMPI, sizeof(stAuthData.uAuthData.stKsNAF.aucIMPI), gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stAuthData.uAuthData.stKsNAF.aucIMPI), gastAtParaList[2].usParaLen);

    if(SI_PIH_UiccAuthReq(gastAtClientTab[ucIndex].usClientId, 0, &stAuthData) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_KSNAFAUTH_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        AT_ERR_LOG("AT_SetKsNafAuthPara: SI_PIH_UiccAuthReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetRoamImsServicePara(VOS_UINT8 ucIndex)
{
    TAF_MMA_ROAM_IMS_SUPPORT_ENUM_UINT32    enRoamImsSupport;

    enRoamImsSupport = TAF_MMA_ROAM_IMS_BUTT;

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((gastAtParaList[0].usParaLen != 1) || (gucAtParaIndex != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].ulParaValue == 0)
    {
        enRoamImsSupport    = TAF_MMA_ROAM_IMS_UNSUPPORT;
    }
    else
    {
        enRoamImsSupport    = TAF_MMA_ROAM_IMS_SUPPORT;
    }


    if (TAF_MMA_SetRoamImsSupportReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, enRoamImsSupport) == VOS_TRUE)
    {
        /* 设置AT模块实体的状态为等待异步返回 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ROAM_IMS_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetRoamImsServicePara: TAF_MMA_SetRoamImsSupportReq fail.");

        return AT_ERROR;
    }
}

#endif


VOS_UINT32 AT_SetEOPlmnParaCheck(VOS_VOID)
{

    /*参数有效性检查*/
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不为TAF_AT_EOPLMN_PARA_NUM，返回AT_CME_INCORRECT_PARAMETERS*/
    if ( gucAtParaIndex != TAF_AT_EOPLMN_PARA_NUM )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第1个参数检查,version长度不能大于TAF_MAX_USER_CFG_OPLMN_VERSION_LEN */
    if (gastAtParaList[0].usParaLen >= TAF_MAX_USER_CFG_OPLMN_VERSION_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第2个参数检查，组Index值不能大于5 */
    if (gastAtParaList[1].ulParaValue > TAF_MAX_USER_CFG_OPLMN_GROUP_INDEX)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数检查，pduLen值不能大于500 */
    if (gastAtParaList[2].ulParaValue > TAF_AT_PLMN_WITH_RAT_LEN * TAF_MAX_GROUP_CFG_OPLMN_NUM)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数检查，pduLen值必须为TAF_AT_PLMN_WITH_RAT_LEN的整数倍 */
    if ((gastAtParaList[2].ulParaValue % TAF_AT_PLMN_WITH_RAT_LEN) != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 最大只允许设置256个，因此最后的第6组(index=5)最大允许用户设置6个OPLMN */
    if ((gastAtParaList[2].ulParaValue > 6 * TAF_AT_PLMN_WITH_RAT_LEN)
     && (gastAtParaList[1].ulParaValue == TAF_MAX_USER_CFG_OPLMN_GROUP_INDEX))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第4个参数检查，PDU的实际长度必须与指定的pdulen相同 */
    if (gastAtParaList[3].usParaLen != gastAtParaList[2].ulParaValue)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第4个参数检查，PDU数据必须可以完成16进制字符串转换 */
    if (At_AsciiNum2HexString(gastAtParaList[3].aucPara, &gastAtParaList[3].usParaLen) != AT_SUCCESS)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}



VOS_UINT32 AT_SetUserCfgOPlmnPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_SET_EOPLMN_LIST_STRU        stEOPlmnSetPara;
    VOS_UINT32                          ulRst;
    errno_t                             lMemResult;

    memset_s(&stEOPlmnSetPara, sizeof(stEOPlmnSetPara), 0x00, sizeof(TAF_MMA_SET_EOPLMN_LIST_STRU));


    /* 参数个数和合法性检查,不合法直接返回失败 */
    ulRst = AT_SetEOPlmnParaCheck();
    if (ulRst != AT_SUCCESS)
    {
        return ulRst;
    }

    /* 将设置的AT参数封装成TAF_MMA_SET_EOPLMN_LIST_STRU的形式 */
    lMemResult = memcpy_s(stEOPlmnSetPara.aucVersion,
                          sizeof(stEOPlmnSetPara.aucVersion),
                          gastAtParaList[0].aucPara,
                          TAF_MAX_USER_CFG_OPLMN_VERSION_LEN);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stEOPlmnSetPara.aucVersion), TAF_MAX_USER_CFG_OPLMN_VERSION_LEN);

    if (gastAtParaList[3].usParaLen > TAF_MAX_GROUP_CFG_OPLMN_DATA_LEN)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(stEOPlmnSetPara.aucOPlmnWithRat,
                          sizeof(stEOPlmnSetPara.aucOPlmnWithRat),
                          gastAtParaList[3].aucPara,
                          gastAtParaList[3].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stEOPlmnSetPara.aucOPlmnWithRat), gastAtParaList[3].usParaLen);

    stEOPlmnSetPara.ucIndex      = (VOS_UINT8)gastAtParaList[1].ulParaValue;
    stEOPlmnSetPara.ucOPlmnCount = (VOS_UINT8)(gastAtParaList[2].ulParaValue / TAF_AT_PLMN_WITH_RAT_LEN);

    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    ulRst = TAF_MMA_SetEOPlmnReq(WUEPS_PID_AT,
                                 gastAtClientTab[ucIndex].usClientId,
                                 0,
                                 &stEOPlmnSetPara);
    if (ulRst == VOS_TRUE)
    {
        /* 指示当前用户的命令操作类型为设置命令 */
        g_stParseContext[ucIndex].ucClientStatus = AT_FW_CLIENT_STATUS_PEND;
        gastAtClientTab[ucIndex].CmdCurrentOpt   = AT_CMD_EOPLMN_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_SetEcidPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    AT_MTA_ECID_SET_REQ_STRU            stEcidSetReq;

    /* 参数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stEcidSetReq, sizeof(stEcidSetReq), 0x00, sizeof(stEcidSetReq));

    stEcidSetReq.ulVersion = gastAtParaList[0].ulParaValue;

    /* 发送跨核消息到C核, 设置GPS参考时钟状态是否主动上报 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_ECID_SET_REQ,
                                      &stEcidSetReq,
                                      sizeof(stEcidSetReq),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetEcidPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECID_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_AT_HSUART == FEATURE_ON)

VOS_VOID AT_UpdateUartCfgNV(VOS_VOID)
{
    AT_UART_CTX_STRU                   *pstUartCtx = VOS_NULL_PTR;
    TAF_NV_UART_CFG_STRU                stUartNvCfg;

    /* 初始化 */
    memset_s(&stUartNvCfg, sizeof(stUartNvCfg), 0x00, sizeof(TAF_NV_UART_CFG_STRU));

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_UART_CFG,
                           &stUartNvCfg,
                           sizeof(TAF_NV_UART_CFG_STRU)))
    {
        AT_ERR_LOG("AT_UpdateUartCfgNV: Read NV fail!");
        AT_HSUART_DBG_NV_READ_ERR(1);
        return;
    }

    /* 获取UART参数 */
    pstUartCtx                   = AT_GetUartCtxAddr();
    stUartNvCfg.ulBaudRate       = pstUartCtx->stPhyConfig.enBaudRate;
    stUartNvCfg.stFrame.ucFormat = pstUartCtx->stPhyConfig.stFrame.enFormat;
    stUartNvCfg.stFrame.ucParity = pstUartCtx->stPhyConfig.stFrame.enParity;

    /* 更新UART参数NV */
    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_UART_CFG,
                            &stUartNvCfg,
                            sizeof(TAF_NV_UART_CFG_STRU)))
    {
        AT_ERR_LOG("AT_UpdateUartCfgNV: Write NV fail!");
        AT_HSUART_DBG_NV_WRITE_ERR(1);
    }

    return ;
}


VOS_UINT32 AT_SetIprPara(VOS_UINT8 ucIndex)
{
    AT_UART_PHY_CFG_STRU               *pstPhyCfg = VOS_NULL_PTR;
    AT_UART_BAUDRATE_ENUM_UINT32        enBaudRate;

    pstPhyCfg = AT_GetUartPhyCfgInfo();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 参数检查 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空, 使用等效值115200 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        enBaudRate = AT_UART_DEFAULT_BAUDRATE;
    }
    else
    {
        if (gastAtParaList[0].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        enBaudRate = gastAtParaList[0].ulParaValue;
    }

    /* 波特率有效性检查 */
    if (AT_HSUART_IsBaudRateValid(enBaudRate) != VOS_TRUE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新波特率参数 */
    pstPhyCfg->enBaudRate = enBaudRate;

    /* 刷新UART配置NV */
    AT_UpdateUartCfgNV();

    /* 先上报OK */
    At_FormatResultData(ucIndex, AT_OK);

    /* 配置波特率参数 */
    AT_HSUART_ConfigBaudRate(ucIndex, enBaudRate);

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetIcfPara(VOS_UINT8 ucIndex)
{
    AT_UART_PHY_CFG_STRU               *pstPhyCfg = VOS_NULL_PTR;
    AT_UART_FORMAT_ENUM_UINT8           enFormat;
    AT_UART_PARITY_ENUM_UINT8           enParity;

    pstPhyCfg = AT_GetUartPhyCfgInfo();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 参数检查 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数有效性检查 */
    /* 参数为空，使用等效值(3,3),即:8个数据位1个停止位无校验位 */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        enFormat = AT_UART_DEFAULT_FORMAT;
        enParity = AT_UART_DEFAULT_PARITY;
    }
    else
    {
        /* AT_CMD_OPT_SET_PARA_CMD */
        /* AT+ICF= */
        if (gucAtParaIndex == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* AT+ICF=, */
        if (gastAtParaList[0].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        enFormat = (VOS_UINT8)gastAtParaList[0].ulParaValue;

        if (gucAtParaIndex > 1)
        {
            if (gastAtParaList[1].usParaLen != 0)
            {
                /* AT+ICF=<format>,<parity> */
                enParity = (VOS_UINT8)gastAtParaList[1].ulParaValue;
            }
            else
            {
                /* AT+ICF=<format>, */
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
        else
        {
            /* AT+ICF=<format> */
            enParity = AT_UART_DEFAULT_PARITY;
        }
    }

    /* 检查帧格式参数有效性 */
    if (AT_HSUART_ValidateCharFrameParam(enFormat, enParity) == VOS_FALSE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新帧格式参数 */
    pstPhyCfg->stFrame.enFormat = enFormat;
    pstPhyCfg->stFrame.enParity = enParity;

    /* 刷新UART配置NV */
    AT_UpdateUartCfgNV();

    /* 先上报OK */
    At_FormatResultData(ucIndex, AT_OK);

    /* 配置帧格式参数 */
    AT_HSUART_ConfigCharFrame(ucIndex, enFormat, enParity);

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetIfcPara(VOS_UINT8 ucIndex)
{
    AT_UART_FLOW_CTRL_STRU             *pstUartFlowCtrl = VOS_NULL_PTR;
    AT_UART_FC_DCE_BY_DTE_ENUM_UINT8    enFcDceByDte;
    AT_UART_FC_DTE_BY_DCE_ENUM_UINT8    enFcDteByDce;
    VOS_UINT32                          ulRtsFlag;
    VOS_UINT32                          ulCtsFlag;

    pstUartFlowCtrl = AT_GetUartFlowCtrlInfo();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(ucIndex) != VOS_TRUE)
    {
        return AT_OK;
    }

    /* 命令参数个数检查 */
    if (gucAtParaIndex > 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AT+IFC等效于AT+IFC=0,0
     * 注: 该处理为产品线要求, IUT-T-V.250中规定AT+IFC等效于AT+IFC=2,2
     */
    if (g_stATParseCmd.ucCmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        enFcDceByDte = AT_UART_DEFAULT_FC_DCE_BY_DTE;
        enFcDteByDce = AT_UART_DEFAULT_FC_DTE_BY_DCE;
    }
    else
    {
        /* AT+IFC= */
        if (gucAtParaIndex == 0)
        {
            /* AT+IFC= */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* AT+IFC=, */
        if (gastAtParaList[0].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (gucAtParaIndex > 1)
        {
            if (gastAtParaList[1].usParaLen != 0)
            {
                /* AT+IFC=<DCE_by_DTE>,<DTE_by_DCE> */
                enFcDteByDce = (VOS_UINT8)gastAtParaList[1].ulParaValue;
            }
            else
            {
                /* AT+IFC=<DCE_by_DTE>, */
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
        else
        {
            /* AT+IFC=<DCE_by_DTE> */
            enFcDteByDce = AT_UART_DEFAULT_FC_DTE_BY_DCE;
        }

        enFcDceByDte = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    }

    /* 检查流控参数有效性 */
    if (AT_HSUART_ValidateFlowCtrlParam(enFcDceByDte, enFcDteByDce) == VOS_FALSE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新流控参数 */
    pstUartFlowCtrl->enDceByDte = enFcDceByDte;
    pstUartFlowCtrl->enDteByDce = enFcDteByDce;

    /* 转换硬件流控参数 */
    ulRtsFlag  = (AT_UART_FC_DCE_BY_DTE_RTS == enFcDceByDte) ?
                 VOS_TRUE : VOS_FALSE;

    ulCtsFlag  = (AT_UART_FC_DTE_BY_DCE_CTS == enFcDteByDce) ?
                 VOS_TRUE : VOS_FALSE;

    /* 配置硬件流控参数 */
    AT_HSUART_ConfigFlowCtrl(ucIndex, ulRtsFlag, ulCtsFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetOPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRslt;
    AT_DATA_MODE_TYPE                   ucDataMode;

    /* 获取当前数据模式 */
    ucDataMode = gastAtClientTab[ucIndex].DataMode;

    /* 如果当前通道模式为ONLINE-COMMAND模式, 直接恢复当前数据模式 */
    if (gastAtClientTab[ucIndex].Mode == AT_ONLINE_CMD_MODE)
    {
        At_SetMode(ucIndex, AT_DATA_MODE, ucDataMode);
        ulRslt = AT_CONNECT;
    }
    else
    {
        ulRslt = AT_NO_CARRIER;
    }

    return ulRslt;
}


VOS_UINT32 AT_SetSwitchUart(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulmode;

    if(ucIndex != AT_CLIENT_ID_HSUART)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 1\n");
        return AT_ERROR;
    }

    /* 判断CK是否校验通过 */
    if (g_stSpWordCtx.ucShellPwdCheckFlag != VOS_TRUE)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 2\n");
        AT_WARN_LOG("AT_SetSwitchUart:WARNING: datalock check faild!");
        return AT_ERROR;
    }

     /* 参数检查 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 3\n");
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 4\n");
        return AT_ERROR;
    }

    /* 切换到 A shell*/
    if (gastAtParaList[0].ulParaValue == AT_UART_MODE_ASHELL)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 5\n");
        ulmode = UART_A_SHELL;
    }
    else if(gastAtParaList[0].ulParaValue == AT_UART_MODE_CSHELL)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 6\n");
        ulmode = UART_C_SHELL;
    }
    else
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 7\n");
        AT_WARN_LOG("AT_SetSwitchUart: unknown value!");
        return AT_ERROR;
    }

    if (mdrv_udi_ioctl(g_alAtUdiHandle[ucIndex], UART_IOCTL_SET_AC_SHELL, &ulmode) != VOS_OK)
    {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 8\n");
        AT_WARN_LOG("AT_SetSwitchUart:DRV_UDI_IOCTL faild!");
        return AT_ERROR;
    }

    AT_INFO_LOG("AT_SetSwitchUart: success and leave!!");
    PS_PRINTF_INFO("<AT_SetSwitchUart> success and leave!!\n");

    return AT_OK;

}
#endif



VOS_UINT32 AT_SetRATCombinePara(VOS_UINT8 ucIndex)
{
    return AT_CME_OPERATION_NOT_ALLOWED;
}

#if (FEATURE_IMS == FEATURE_ON)

VOS_UINT32 AT_SetCallModifyInitPara(VOS_UINT8 ucIndex)
{
    TAF_CTRL_STRU                       stCtrl;
    TAF_CCM_CALL_MODIFY_PARA_STRU       stCallMdfPara;
    VOS_UINT32                          ulResult;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_CTRL_STRU));
    memset_s(&stCallMdfPara, sizeof(stCallMdfPara), 0x00, sizeof(stCallMdfPara));

    /* 参数检查 */
    if(gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0)
     || (gastAtParaList[2].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stCallMdfPara.callId                = (MN_CALL_ID_T)gastAtParaList[0].ulParaValue;
    stCallMdfPara.enCurrCallType        = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[1].ulParaValue;
    stCallMdfPara.enExpectCallType      = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[2].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &stCallMdfPara,
                                     ID_TAF_CCM_CALL_MODIFY_REQ,
                                     sizeof(stCallMdfPara),
                                     enModemId);

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CALL_MODIFY_INIT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCallModifyAnsPara(VOS_UINT8 ucIndex)
{
    TAF_CTRL_STRU                                           stCtrl;
    TAF_CCM_CALL_ANSWER_REMOTE_MODIFY_PARA_STRU             stAnsRemoteMdfPara;
    VOS_UINT32                                              ulResult;
    MODEM_ID_ENUM_UINT16                                    enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stAnsRemoteMdfPara, sizeof(stAnsRemoteMdfPara), 0x00, sizeof(stAnsRemoteMdfPara));

    /* 参数检查 */
    if(gucAtParaIndex != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0)
     || (gastAtParaList[2].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stAnsRemoteMdfPara.callId           = (MN_CALL_ID_T)gastAtParaList[0].ulParaValue;
    stAnsRemoteMdfPara.enCurrCallType   = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[1].ulParaValue;
    stAnsRemoteMdfPara.enExpectCallType = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[2].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &stAnsRemoteMdfPara,
                                     ID_TAF_CCM_CALL_ANSWER_REMOTE_MODIFY_REQ,
                                     sizeof(stAnsRemoteMdfPara),
                                     enModemId);

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CALL_MODIFY_ANS_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_FillEconfDialPara(
    VOS_UINT8                           ucIndex,
    TAF_CALL_ECONF_DIAL_INFO_STRU      *pstDialParam
)
{
    AT_MODEM_SS_CTX_STRU               *pstSsCtx = VOS_NULL_PTR;
    VOS_UINT32                          ulCallNum;
    VOS_UINT32                          i;
    VOS_UINT32                          ulIndex;

    pstSsCtx = AT_GetModemSsCtxAddrFromClientId(ucIndex);

    /* 默认情况是使用CCA设置的默认值 */
    pstDialParam->enCallMode  = pstSsCtx->enCModType;
    pstDialParam->stDataCfg   = pstSsCtx->stCbstDataCfg;
    pstDialParam->enClirCfg   = pstSsCtx->ucClirType;
    pstDialParam->stCugCfg    = pstSsCtx->stCcugCfg;

    /* 第二个参数为会议中心号码，目前不关注 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[2].usParaLen == 0)
     || (gastAtParaList[3].usParaLen == 0)
     || (gastAtParaList[4].usParaLen == 0)
     || (gastAtParaList[5].usParaLen == 0))
    {
        return VOS_ERR;
    }
    else
    {
        /* 从第7个参数开始为与会者号码，第一个参数指明与会者人数 */
        ulCallNum = gastAtParaList[0].ulParaValue;

        for (i = 0; i < ulCallNum; i++)
        {
            ulIndex = 6 + i;

            if (gastAtParaList[ulIndex].usParaLen == 0)
            {
                return VOS_ERR;
            }

            if (AT_FillCalledNumPara(gastAtParaList[ulIndex].aucPara,
                                     gastAtParaList[ulIndex].usParaLen,
                                     &pstDialParam->stEconfCalllist.astDialNumber[i]) != VOS_OK)
            {
                return VOS_ERR;
            }
        }

        pstDialParam->stEconfCalllist.ulCallNum = ulCallNum;
    }

    /* 设置<I>参数 */
    if (gastAtParaList[2].ulParaValue == 0)
    {
        pstDialParam->enClirCfg = AT_CLIR_INVOKE;
    }
    else if (gastAtParaList[2].ulParaValue == 1)
    {
        pstDialParam->enClirCfg = AT_CLIR_SUPPRESS;
    }
    else
    {
        return VOS_ERR;
    }

    pstDialParam->enCallType            = (MN_CALL_TYPE_ENUM_U8)gastAtParaList[3].ulParaValue;
    pstDialParam->enVoiceDomain         = (TAF_CALL_VOICE_DOMAIN_ENUM_UINT8)gastAtParaList[4].ulParaValue;
    pstDialParam->ucImsInvitePtptFlag   = VOS_FALSE;

    return VOS_OK;

}


VOS_UINT32 AT_SetEconfDialPara(VOS_UINT8 ucIndex)
{
    TAF_CALL_ECONF_DIAL_INFO_STRU       stEconfDialInfo;
    TAF_CTRL_STRU                       stCtrl;
    VOS_UINT32                          ulResult;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stEconfDialInfo, sizeof(stEconfDialInfo), 0x00, sizeof(stEconfDialInfo));

    /* 参数检查 */
    if ((gucAtParaIndex < AT_CMD_ECONF_DIAL_MIN_PARA_NUM)
     || (gucAtParaIndex > AT_CMD_ECONF_DIAL_MAX_PARA_NUM))
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不对 */
    /* 参数的个数应该是total_callnum+6 */
    if ((gastAtParaList[0].ulParaValue + 6) != gucAtParaIndex)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查并填写输入的参数 */
    ulResult = AT_FillEconfDialPara(ucIndex, &stEconfDialInfo);
    if (ulResult != VOS_OK)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* AT向CCM发送增强多方通话消息 */
    ulResult = TAF_CCM_CallCommonReq(&stCtrl,
                                     &(stEconfDialInfo),
                                     ID_TAF_CCM_ECONF_DIAL_REQ,
                                     sizeof(stEconfDialInfo),
                                     enModemId);

    if (ulResult == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECONF_DIAL_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetImsSwitchPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                                  ulRst;
    TAF_MMA_IMS_SWITCH_INFO_STRU                stImsSwitchInfo;
    TAF_NV_IMS_SWITCH_RAT_RELATION_CFG_STRU     stImsSwitchRatRelationCfg;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex > 3)
    {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stImsSwitchInfo, sizeof(stImsSwitchInfo), 0, sizeof(TAF_MMA_IMS_SWITCH_INFO_STRU));
    memset_s(&stImsSwitchRatRelationCfg, sizeof(stImsSwitchRatRelationCfg), 0, sizeof(TAF_NV_IMS_SWITCH_RAT_RELATION_CFG_STRU));

    stImsSwitchInfo.bitOpImsSwitch              = VOS_TRUE;

    if (TAF_ACORE_NV_READ(MODEM_ID_0,
                          en_NV_Item_IMS_SWITCH_RAT_RELATION_CFG,
                          &stImsSwitchRatRelationCfg,
                          sizeof(stImsSwitchRatRelationCfg)) != NV_OK)
    {
        AT_WARN_LOG("AT_SetImsSwitchPara: Read NV fail!");
        memset_s(&stImsSwitchRatRelationCfg, sizeof(stImsSwitchRatRelationCfg), 0, sizeof(TAF_NV_IMS_SWITCH_RAT_RELATION_CFG_STRU));
    }

    stImsSwitchInfo.stImsSwitchRat.enLteEnable  = (TAF_MMA_IMS_SWITCH_SET_ON == gastAtParaList[0].ulParaValue) ?
        TAF_MMA_IMS_SWITCH_SET_ON : TAF_MMA_IMS_SWITCH_SET_OFF;

    if (gucAtParaIndex > 1)
    {
        stImsSwitchInfo.stImsSwitchRat.enUtranEnable    =
            ((gastAtParaList[1].usParaLen > 0) && (TAF_MMA_IMS_SWITCH_SET_ON == gastAtParaList[1].ulParaValue)) ?
            TAF_MMA_IMS_SWITCH_SET_ON : TAF_MMA_IMS_SWITCH_SET_OFF;
    }
    else
    {
        if (stImsSwitchRatRelationCfg.ucUtranRelationLteFlg == VOS_TRUE)
        {
            stImsSwitchInfo.stImsSwitchRat.enUtranEnable = stImsSwitchInfo.stImsSwitchRat.enLteEnable;
        }
    }

    if (gucAtParaIndex > 2)
    {
        stImsSwitchInfo.stImsSwitchRat.enGsmEnable      =
            ((gastAtParaList[2].usParaLen > 0) && (TAF_MMA_IMS_SWITCH_SET_ON == gastAtParaList[2].ulParaValue)) ?
            TAF_MMA_IMS_SWITCH_SET_ON : TAF_MMA_IMS_SWITCH_SET_OFF;
    }
    else
    {
        if (stImsSwitchRatRelationCfg.ucGsmRelationLteFlg == VOS_TRUE)
        {
            stImsSwitchInfo.stImsSwitchRat.enGsmEnable = stImsSwitchInfo.stImsSwitchRat.enLteEnable;
        }
    }

    ulRst = TAF_MMA_SetImsSwitchReq(WUEPS_PID_AT,
                                    gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    &stImsSwitchInfo);
    if (ulRst != VOS_TRUE)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IMS_SWITCH_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_InputValueTransToVoiceDomain(
    VOS_UINT32                          ulValue,
    TAF_MMA_VOICE_DOMAIN_ENUM_UINT32   *penVoiceDomain
)
{
    VOS_UINT32                          ulRst;

    ulRst = VOS_TRUE;

    switch (ulValue)
    {
        case AT_VOICE_DOMAIN_TYPE_CS_ONLY:
            *penVoiceDomain = TAF_MMA_VOICE_DOMAIN_CS_ONLY;
            break;

        case AT_VOICE_DOMAIN_TYPE_CS_PREFERRED:
            *penVoiceDomain = TAF_MMA_VOICE_DOMAIN_CS_PREFERRED;
            break;

        case AT_VOICE_DOMAIN_TYPE_IMS_PS_PREFERRED:
            *penVoiceDomain = TAF_MMA_VOICE_DOMAIN_IMS_PS_PREFERRED;
            break;

       case AT_VOICE_DOMAIN_TYPE_IMS_PS_ONLY:
            *penVoiceDomain = TAF_MMA_VOICE_DOMAIN_IMS_PS_ONLY;
            break;

        default:
            *penVoiceDomain = TAF_MMA_VOICE_DOMAIN_BUTT;
            ulRst = VOS_FALSE;
            break;
    }

    return ulRst;
}


VOS_UINT32 AT_SetCevdpPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_VOICE_DOMAIN_ENUM_UINT32    enVoiceDomain;
    VOS_UINT32                          ulRst;

    ulRst         = VOS_FALSE;
    enVoiceDomain = TAF_MMA_VOICE_DOMAIN_BUTT;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空，协议没有明确规定默认值，此处默认设置为CS ONLY */
    if (gastAtParaList[0].usParaLen == 0)
    {
        enVoiceDomain = TAF_MMA_VOICE_DOMAIN_CS_ONLY;
    }
    else
    {
        if (AT_InputValueTransToVoiceDomain(gastAtParaList[0].ulParaValue, &enVoiceDomain) != VOS_TRUE)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    ulRst = TAF_MMA_SetVoiceDomainReq(WUEPS_PID_AT,
                                      gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      enVoiceDomain);
    if (ulRst != VOS_TRUE)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VOICE_DOMAIN_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetImsctrlmsgPara(VOS_UINT8 ucIndex)
{
    AT_IMS_CTRL_MSG_STRU               *pstAtImsaMsgPara = VOS_NULL_PTR;
    VOS_UINT8                          *pucMsg           = VOS_NULL_PTR;
    VOS_UINT32                          ulAtImsaMsgParaLen;
    VOS_UINT32                          ulMsgSubStrCount;
    VOS_UINT32                          i;
    VOS_UINT32                          ulIndex;
    errno_t                             lMemResult;
    VOS_UINT16                          usMsgStrLen;
    VOS_UINT16                          usLength;
    VOS_UINT32                          ulResult;

    /* 参数检查 */
    if (gucAtParaIndex < 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulMsgSubStrCount = gucAtParaIndex - 2;
    usMsgStrLen = 0;

    for (i = 0; i < ulMsgSubStrCount; i++)
    {
        ulIndex = i + 2;

        if (gastAtParaList[ulIndex].usParaLen == 0)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        usMsgStrLen += gastAtParaList[ulIndex].usParaLen;
    }
    /*lint -save -e516 */
    pucMsg = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, usMsgStrLen + 1);
    /*lint -restore */
    if (pucMsg == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetImsctrlmsgPara: Memory malloc failed!");
        return AT_ERROR;
    }

    usLength = 0;
    for (i = 0; i < ulMsgSubStrCount; i++)
    {
        ulIndex = i + 2;

        usLength += (VOS_UINT16)At_sprintf(usMsgStrLen + 1,
                                           (VOS_CHAR *)pucMsg,
                                           (VOS_CHAR *)pucMsg + usLength,
                                           "%s",
                                           gastAtParaList[ulIndex].aucPara);
    }

    /* 将字符串参数转换为码流 */
    ulResult = At_AsciiNum2HexString(pucMsg, &usLength);

    if ((ulResult != AT_SUCCESS)
     || (gastAtParaList[1].ulParaValue != usLength))
    {
        PS_MEM_FREE(WUEPS_PID_AT, pucMsg);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 申请内存空间，大小为Mapcon给IMSA发送的消息的长度 */
    ulAtImsaMsgParaLen = sizeof(VOS_UINT32) + gastAtParaList[1].ulParaValue;
    pstAtImsaMsgPara   = (AT_IMS_CTRL_MSG_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, ulAtImsaMsgParaLen);

    if (pstAtImsaMsgPara == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetImsctrlmsgPara: Memory malloc failed!");
        PS_MEM_FREE(WUEPS_PID_AT, pucMsg);

        return AT_ERROR;
    }

    memset_s(pstAtImsaMsgPara, ulAtImsaMsgParaLen, 0x00, ulAtImsaMsgParaLen);

    /* 填充AT_IMSA_IMS_CTRL_MSG_STRU */
    pstAtImsaMsgPara->ulMsgLen = gastAtParaList[1].ulParaValue;
    lMemResult = memcpy_s(pstAtImsaMsgPara->ucMsgContext, pstAtImsaMsgPara->ulMsgLen, pucMsg, pstAtImsaMsgPara->ulMsgLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, pstAtImsaMsgPara->ulMsgLen, pstAtImsaMsgPara->ulMsgLen);

    /* 转发MAPCON给IMSA的消息 */
    if (gastAtParaList[0].ulParaValue == 0)
    {
        ulResult = AT_SndImsaImsCtrlMsg(gastAtClientTab[ucIndex].usClientId, 0, pstAtImsaMsgPara);
    }
    else
    {
        ulResult = AT_PS_ProcMapconMsg(gastAtClientTab[ucIndex].usClientId, (AT_MAPCON_CTRL_MSG_STRU *)pstAtImsaMsgPara);
    }

    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pucMsg);
    PS_MEM_FREE(WUEPS_PID_AT, pstAtImsaMsgPara);
    /*lint -restore */
    if (ulResult != VOS_OK)
    {
        return AT_ERROR;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetImsDomainCfgPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                                   ulRst;
    TAF_MMA_IMS_DOMAIN_CFG_TYPE_ENUM_UINT32      enImsDomainCfg;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

     /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enImsDomainCfg = (TAF_MMA_IMS_DOMAIN_CFG_TYPE_ENUM_UINT32)gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    ulRst = TAF_MMA_SetImsDomainCfgReq(WUEPS_PID_AT,
                                       gastAtClientTab[ucIndex].usClientId,
                                       0,
                                       enImsDomainCfg);

    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_IMSDOMAINCFG_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCallEncryptPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    AT_IMSA_CALL_ENCRYPT_SET_REQ_STRU   stCallEncrypt;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCallEncrypt.ucEncrypt = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给IMSA发送^CALLENCRYPT设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_IMSA_CALL_ENCRYPT_SET_REQ,
                                      &stCallEncrypt.ucEncrypt,
                                      sizeof(VOS_UINT8),
                                      PS_PID_IMSA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CALLENCRYPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif

#if (FEATURE_HUAWEI_VP == FEATURE_ON)

VOS_UINT32 AT_SetVoicePreferPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32      ulVoicePreferAct;
    VOS_UINT32      ulRslt;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulVoicePreferAct = gastAtParaList[0].ulParaValue;

    ulRslt = AT_SndSetVoicePrefer(gastAtClientTab[ucIndex].usClientId,
                               gastAtClientTab[ucIndex].opId,
                               ulVoicePreferAct);
    if (ulRslt == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_VOICEPREFER_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCrmPara(VOS_UINT8 ucIndex)
{
    /* 参数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#if (FEATURE_PPP == FEATURE_ON)

    if (gastAtParaList[0].ulParaValue == TAF_PS_CDATA_DIAL_MODE_RELAY)
    {
        PPP_SetRawDataByPassMode(VOS_TRUE);
    }
    else
    {
        PPP_SetRawDataByPassMode(VOS_FALSE);
    }
#endif

    if ( TAF_PS_SetCdataDialModeInfo(WUEPS_PID_AT,
                                     AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                     gastAtParaList[0].ulParaValue) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CRM_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}




VOS_UINT32 AT_SetCcmgsPara(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulLengthValue,
    VOS_UINT8                          *pucCommand,
    VOS_UINT16                          usCommandLength)
{
    TAF_XSMS_MESSAGE_STRU               stSmsPdu;
    errno_t                             lMemResult;
    VOS_UINT16                          usCommandHexLen;
    TAF_UINT8                           ucSmSFormat;

    ucSmSFormat = AT_GetModemSmsCtxAddrFromClientId(ucIndex)->enCmgfMsgFormat;

    if (ucSmSFormat != AT_CMGF_MSG_FORMAT_PDU)
    {
        AT_WARN_LOG("AT_SetCcmgsPara: current format is not PDU!");
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&stSmsPdu, sizeof(stSmsPdu), 0x00, sizeof(stSmsPdu));

    /* 参数检查 */
    if ((ulLengthValue > (2*sizeof(TAF_XSMS_MESSAGE_STRU)))
       || (ulLengthValue != usCommandLength)
       || ((ulLengthValue%2) != VOS_NULL))
    {
        AT_WARN_LOG("AT_SetCcmgsPara: incorrect parameters!");
        AT_WARN_LOG1("AT_SetCcmgsPara: ulLengthValue:", ulLengthValue);
        AT_WARN_LOG1("AT_SetCcmgsPara: usCommandLength:", usCommandLength);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PDU>是ASCII码，做输入参数到HEX的转换 */
    usCommandHexLen = usCommandLength;
    if (At_AsciiNum2HexString(pucCommand, &usCommandHexLen) == AT_FAILURE)
    {
        AT_WARN_LOG("AT_SetCcmgsPara: ascii2hex fail!");
        AT_WARN_LOG1("AT_SetCcmgsPara: usCommandLength:", usCommandLength);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将PDU的码流拷贝到数据结构 */
    lMemResult = memcpy_s(&stSmsPdu, sizeof(stSmsPdu), pucCommand, usCommandHexLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSmsPdu), usCommandHexLen);

    /* 执行命令操作 */
    if (TAF_XSMS_SendSmsReq(gastAtClientTab[ucIndex].usClientId,
                            0,
                            TAF_XSMS_SEND_OPTION_SINGLE,
                            (VOS_UINT8 *)&stSmsPdu) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCMGS_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCcmgsPara: CNAS_XSMS_SendSmsReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCcmgwPara(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulLengthValue,
    VOS_UINT32                          ulStatValue,
    VOS_UINT8                          *pucCommand,
    VOS_UINT16                          usCommandLength)
{
    TAF_XSMS_MESSAGE_STRU               stSmsPdu;
    errno_t                             lMemResult;
    VOS_UINT16                          usCommandHexLen;
    TAF_UINT8                           ucSmSFormat;

    ucSmSFormat = AT_GetModemSmsCtxAddrFromClientId(ucIndex)->enCmgfMsgFormat;

    if (ucSmSFormat != AT_CMGF_MSG_FORMAT_PDU)
    {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    memset_s(&stSmsPdu, sizeof(stSmsPdu), 0x00, sizeof(stSmsPdu));

    /* 参数检查 */
    if ((ulLengthValue > (2*sizeof(TAF_XSMS_MESSAGE_STRU)))
       || (ulLengthValue != usCommandLength)
       || ((ulLengthValue % 2) != VOS_NULL))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数2合法性检查 */
    if (ulStatValue > TAF_XSMS_STATUS_STO_SEND)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PDU>是ASCII码，做输入参数到HEX的转换 */
    usCommandHexLen = usCommandLength;
    if (At_AsciiNum2HexString(pucCommand, &usCommandHexLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将PDU的码流拷贝到数据结构 */
    lMemResult = memcpy_s(&stSmsPdu, sizeof(stSmsPdu), pucCommand, usCommandHexLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(stSmsPdu), usCommandHexLen);

    /* 执行命令操作 */
    if (TAF_XSMS_WriteSmsReq(gastAtClientTab[ucIndex].usClientId,
                             0,
                             (VOS_UINT8)ulStatValue,
                             (VOS_UINT8 *)&stSmsPdu) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCMGW_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCcmgwPara: CNAS_XSMS_WriteSmsReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCcmgdPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucSmsIndex;

    /* 参数不合法，返回错误 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucSmsIndex = (VOS_UINT8)gastAtParaList[0].ulParaValue;


    /* 执行命令操作 */
    if (TAF_XSMS_DeleteSmsReq(gastAtClientTab[ucIndex].usClientId,
                              0,
                              ucSmsIndex) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CCMGD_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}


VOS_UINT32 AT_CheckCFreqLockEnablePara(VOS_VOID)
{
    VOS_UINT8                    ucLoop;

    for (ucLoop = 1; ucLoop < AT_CFREQLOCK_PARA_NUM_MAX; ucLoop++)
    {
        if (gastAtParaList[ucLoop].usParaLen == 0)
        {
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetCFreqLockPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_CFREQ_LOCK_SET_PARA_STRU    stCFreqLockPara;
    VOS_UINT32                          ulRst;

    /*参数有效性检查*/
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果第一个参数是开启锁频,但参数个数不为9，或第一个参数是解除锁频，但参数个数不为1，都不合法 */
    if ((  (gastAtParaList[0].ulParaValue == 1)
         && (gucAtParaIndex != AT_CFREQLOCK_PARA_NUM_MAX))
      || ( (gastAtParaList[0].ulParaValue == 0)
         && (gucAtParaIndex != AT_CFREQLOCK_PARA_NUM_MIN)))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果第一个参数是锁频，则1X/EVDO的锁频参数需同时设置，并需判断<cdma_pn>和<evdo_pn>的有效范围 */
    if (gastAtParaList[0].ulParaValue == 1)
    {
        if(AT_CheckCFreqLockEnablePara() == VOS_FALSE)
        {
             return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 发送消息赋值 */
    memset_s(&stCFreqLockPara, sizeof(stCFreqLockPara), 0x00, sizeof(TAF_MMA_CFREQ_LOCK_SET_PARA_STRU));

    if ((VOS_UINT8)gastAtParaList[0].ulParaValue == 1)
    {
        stCFreqLockPara.enFreqLockMode  = TAF_MMA_CFREQ_LOCK_MODE_ON;
        stCFreqLockPara.usSid           = (VOS_UINT16)gastAtParaList[1].ulParaValue;
        stCFreqLockPara.usNid           = (VOS_UINT16)gastAtParaList[2].ulParaValue;
        stCFreqLockPara.usCdmaBandClass = (VOS_UINT16)gastAtParaList[3].ulParaValue;
        stCFreqLockPara.usCdmaFreq      = (VOS_UINT16)gastAtParaList[4].ulParaValue;
        stCFreqLockPara.usCdmaPn        = (VOS_UINT16)gastAtParaList[5].ulParaValue;
        stCFreqLockPara.usEvdoBandClass = (VOS_UINT16)gastAtParaList[6].ulParaValue;
        stCFreqLockPara.usEvdoFreq      = (VOS_UINT16)gastAtParaList[7].ulParaValue;
        stCFreqLockPara.usEvdoPn        = (VOS_UINT16)gastAtParaList[8].ulParaValue;
    }
    else
    {
        stCFreqLockPara.enFreqLockMode = TAF_MMA_CFREQ_LOCK_MODE_OFF;
    }

    /* 发送TAF_MMA_CFREQ_LOCK_SET_REQ消息 */
    ulRst = TAF_MMA_ProcCFreqLockSetReq(WUEPS_PID_AT,
                                        gastAtClientTab[ucIndex].usClientId,
                                        gastAtClientTab[ucIndex].opId,
                                        &stCFreqLockPara);
    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CFREQLOCK_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;

}
#endif

VOS_UINT32 AT_SetCdmaCsqPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_CDMACSQ_PARA_STRU          stCdmaCsqPara;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gucAtParaIndex != 4)
        ||(gastAtParaList[0].usParaLen == 0)
        ||(gastAtParaList[1].usParaLen == 0)
        ||(gastAtParaList[2].usParaLen == 0)
        ||(gastAtParaList[3].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stCdmaCsqPara, sizeof(stCdmaCsqPara), 0x00, sizeof(TAF_MMA_CDMACSQ_PARA_STRU));
    stCdmaCsqPara.enMode              = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    stCdmaCsqPara.ucTimeInterval      = (TAF_UINT8)gastAtParaList[1].ulParaValue;
    stCdmaCsqPara.ucRssiRptThreshold  = (TAF_UINT8)gastAtParaList[2].ulParaValue;
    stCdmaCsqPara.ucEcIoRptThreshold  = (TAF_UINT8)gastAtParaList[3].ulParaValue;

    if (TAF_MMA_ProcCdmaCsqSetReq(WUEPS_PID_AT,
                                  gastAtClientTab[ucIndex].usClientId,
                                  0,
                                  &stCdmaCsqPara) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CDMACSQ_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;

}
#endif



VOS_UINT32 AT_SetTTYModePara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;
    APP_VC_SET_TTYMODE_REQ_STRU         stSetTTYMode;

    memset_s(&stSetTTYMode, sizeof(stSetTTYMode), 0x00, sizeof(APP_VC_SET_TTYMODE_REQ_STRU));

    /* 参数检查 */
    if ( g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((gastAtParaList[0].usParaLen != 1) || (gucAtParaIndex != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stSetTTYMode.enTTYMode = (TAF_VC_TTYMODE_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    /* 获取下发VC的消息头名称 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      APP_VC_MSG_SET_TTYMODE_REQ,
                                      &stSetTTYMode,
                                      sizeof(APP_VC_SET_TTYMODE_REQ_STRU),
                                      I0_WUEPS_PID_VC);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetTTYModePara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_TTYMODE_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 At_SetCustomDial(VOS_UINT8 ucIndex)
{
    TAF_CALL_CUSTOM_DIAL_PARA_STRU      stCustomDialPara;
    TAF_CTRL_STRU                       stCtrl;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCustomDialPara, sizeof(stCustomDialPara), 0x00, sizeof(TAF_CALL_CUSTOM_DIAL_PARA_STRU));
    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_CTRL_STRU));

    /* 将输入第一个参数转成呼叫号码 */
    if (AT_FillCalledNumPara(gastAtParaList[0].aucPara,
                             gastAtParaList[0].usParaLen,
                             &stCustomDialPara.stDialNumber) != VOS_OK)
    {
        AT_UpdateCallErrInfo(ucIndex, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将输入第二个参数转成SO */
    stCustomDialPara.ulSo       = gastAtParaList[1].ulParaValue;
    stCustomDialPara.enCallType = MN_CALL_TYPE_VOICE;

    stCtrl.ulModuleId           = WUEPS_PID_AT;
    stCtrl.usClientId           = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId               = 0;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stCustomDialPara,
                              ID_TAF_CCM_CUSTOM_DIAL_REQ,
                              sizeof(stCustomDialPara),
                              enModemId) == VOS_OK)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CUSTOMDIAL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_IsPlatformSupportHrpdMode(
    PLATAFORM_RAT_CAPABILITY_STRU      *pstPlatform
)
{
    VOS_UINT16                          i;

    for (i = 0; i < AT_MIN(pstPlatform->usRatNum, PLATFORM_MAX_RAT_NUM); i++)
    {
        if (pstPlatform->aenRatList[i] == PLATFORM_RAT_HRPD)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_IsPlatformSupport1XMode(
    PLATAFORM_RAT_CAPABILITY_STRU      *pstPlatform
)
{
    VOS_UINT16                          i;

    for (i = 0; i < AT_MIN(pstPlatform->usRatNum, PLATFORM_MAX_RAT_NUM); i++)
    {
        if (pstPlatform->aenRatList[i] == PLATFORM_RAT_1X)
        {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_AddSpecRatIntoPlatform(
    PLATFORM_RAT_TYPE_ENUM_UINT16       enRatType,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstPlatform
)
{
    if (pstPlatform->usRatNum >= PLATFORM_MAX_RAT_NUM)
    {
        return VOS_FALSE;
    }

    pstPlatform->aenRatList[pstPlatform->usRatNum] = enRatType;
    pstPlatform->usRatNum++;

    return VOS_TRUE;
}


VOS_UINT32 AT_RemoveSpecRatFromPlatform(
    PLATFORM_RAT_TYPE_ENUM_UINT16       enRatType,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstPlatform
)
{
    VOS_UINT16                          i;
    VOS_UINT16                          usRatNum;

    usRatNum = 0;

    for (i = 0; i < AT_MIN(pstPlatform->usRatNum, PLATFORM_MAX_RAT_NUM); i++)
    {
        if (enRatType != pstPlatform->aenRatList[i])
        {
            pstPlatform->aenRatList[usRatNum++] = pstPlatform->aenRatList[i];
        }
    }

    pstPlatform->usRatNum = usRatNum;

    return VOS_TRUE;
}


VOS_UINT32 AT_IsPlatformValidRemovingXCap(
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModemPlatform
)
{
    VOS_UINT32                          ulModemSupport1XFlg;
    VOS_UINT32                          ulModemSupportHrpdFlg;

    ulModemSupport1XFlg   = AT_IsPlatformSupport1XMode(pstModemPlatform);
    ulModemSupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModemPlatform);

    /* 判断满足切换的条件:modem切换后，如果它的平台能力个数为0的话，则不切换 */
    if ( ( (ulModemSupport1XFlg
         && ulModemSupportHrpdFlg) )
      && (pstModemPlatform->usRatNum == 2) )
    {
        return VOS_FALSE;
    }

    if ( ( (ulModemSupport1XFlg
         || ulModemSupportHrpdFlg) )
      && (pstModemPlatform->usRatNum == 1) )
    {
        return VOS_FALSE;
    }

    return VOS_TRUE;
}





VOS_UINT32 AT_CheckSwitchCdmaModePara(
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem0PlatRat,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem1PlatRat,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem2PlatRat,
    VOS_UINT32                          ulModemId
)
{
    VOS_UINT32                          ulModem0Support1XFlg;
    VOS_UINT32                          ulModem0SupportHrpdFlg;
    VOS_UINT32                          ulModem1Support1XFlg;
    VOS_UINT32                          ulModem1SupportHrpdFlg;
    VOS_UINT32                          ulModem2Support1XFlg;
    VOS_UINT32                          ulModem2SupportHrpdFlg;
    VOS_UINT32                          ulModem0SupportCMode;
    VOS_UINT32                          ulModem1SupportCMode;
    VOS_UINT32                          ulModem2SupportCMode;

    ulModem0Support1XFlg   = AT_IsPlatformSupport1XMode(pstModem0PlatRat);
    ulModem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModem0PlatRat);
    ulModem1Support1XFlg   = AT_IsPlatformSupport1XMode(pstModem1PlatRat);
    ulModem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModem1PlatRat);
    ulModem2Support1XFlg   = AT_IsPlatformSupport1XMode(pstModem2PlatRat);
    ulModem2SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModem2PlatRat);

    ulModem0SupportCMode = (ulModem0Support1XFlg || ulModem0SupportHrpdFlg);
    ulModem1SupportCMode = (ulModem1Support1XFlg || ulModem1SupportHrpdFlg);
    ulModem2SupportCMode = (ulModem2Support1XFlg || ulModem2SupportHrpdFlg);

    /* 如果modem0和modem1同时满足支持，则认为设置失败 */
    if ( (ulModem0SupportCMode == VOS_TRUE)
      && (ulModem1SupportCMode == VOS_TRUE) )
    {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem0 and Modem1 Support CMode");
        return AT_ERROR;
    }

    /* 如果modem0和modem2同时满足支持，则认为设置失败 */
    if ( (ulModem0SupportCMode == VOS_TRUE)
      && (ulModem2SupportCMode == VOS_TRUE) )
    {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem0 and Modem2 Support CMode");

        return AT_ERROR;
    }

    /* 如果modem1和modem2同时满足支持，则认为设置失败 */
    if ( (ulModem1SupportCMode == VOS_TRUE)
      && (ulModem2SupportCMode == VOS_TRUE) )
    {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem2 and Modem1 Support CMode");
        return AT_ERROR;
    }

    /* 如果需要将CDMA modem切换的目标modem0，而modem0已经支持，则直接返回OK */
    if ( (ulModemId == MODEM_ID_0)
      && (ulModem0SupportCMode) )
    {
        return AT_OK;
    }

    /* 如果需要将CDMA modem切换的目标modem1，而modem1已经支持，则直接返回OK */
    if ( (ulModemId == MODEM_ID_1)
      && (ulModem1SupportCMode) )
    {
        return AT_OK;
    }

    /* 如果需要将CDMA modem切换的目标modem2，而modem2已经支持，则直接返回OK */
    if ( (ulModemId == MODEM_ID_2)
      && (ulModem2SupportCMode) )
    {
        return AT_OK;
    }

    return AT_SUCCESS;
}

VOS_UINT32 AT_SwitchCdmaMode(
    VOS_UINT8                           ucIndex,
    VOS_UINT32                          ulModemId,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem0Platform,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem1Platform,
    PLATAFORM_RAT_CAPABILITY_STRU      *pstModem2Platform
)
{
    MODEM_ID_ENUM_UINT16                enSourceModemId;
    MODEM_ID_ENUM_UINT16                enDestinationModemId;
    PLATAFORM_RAT_CAPABILITY_STRU      *pstSourceModemPlatform = VOS_NULL_PTR;
    PLATAFORM_RAT_CAPABILITY_STRU      *pstDestinationModemPlatform = VOS_NULL_PTR;
    VOS_UINT32                          ulModem0Support1XFlg;
    VOS_UINT32                          ulModem0SupportHrpdFlg;
    VOS_UINT32                          ulModem1Support1XFlg;
    VOS_UINT32                          ulModem1SupportHrpdFlg;
    VOS_UINT32                          ulModem0SupportCMode;
    VOS_UINT32                          ulModem1SupportCMode;
    VOS_UINT32                          ulSourceSupport1XFlg;
    VOS_UINT32                          ulSourceSupportHrpdFlg;

    ulModem0Support1XFlg   = AT_IsPlatformSupport1XMode(pstModem0Platform);
    ulModem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModem0Platform);
    ulModem1Support1XFlg   = AT_IsPlatformSupport1XMode(pstModem1Platform);
    ulModem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstModem1Platform);

    ulModem0SupportCMode = (ulModem0Support1XFlg || ulModem0SupportHrpdFlg);
    ulModem1SupportCMode = (ulModem1Support1XFlg || ulModem1SupportHrpdFlg);

    if (ulModemId == 0)
    {
        enDestinationModemId        = MODEM_ID_0;
        pstDestinationModemPlatform = pstModem0Platform;
    }
    else if (ulModemId == 1)
    {
        enDestinationModemId        = MODEM_ID_1;
        pstDestinationModemPlatform = pstModem1Platform;
    }
    else
    {
        enDestinationModemId        = MODEM_ID_2;
        pstDestinationModemPlatform = pstModem2Platform;
    }

    if (ulModem0SupportCMode == VOS_TRUE)
    {
        enSourceModemId             = MODEM_ID_0;
        pstSourceModemPlatform      = pstModem0Platform;
    }
    else if (ulModem1SupportCMode == VOS_TRUE)
    {
        enSourceModemId             = MODEM_ID_1;
        pstSourceModemPlatform      = pstModem1Platform;
    }
    else
    {
        enSourceModemId             = MODEM_ID_2;
        pstSourceModemPlatform      = pstModem2Platform;
    }

    ulSourceSupport1XFlg   = AT_IsPlatformSupport1XMode(pstSourceModemPlatform);
    ulSourceSupportHrpdFlg = AT_IsPlatformSupportHrpdMode(pstSourceModemPlatform);

    if ( AT_IsPlatformValidRemovingXCap(pstSourceModemPlatform) == VOS_FALSE )
    {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_IsPlatformValidRemovingXCap return  FALSE !");
        return VOS_FALSE;
    }

    if (ulSourceSupport1XFlg == VOS_TRUE )
    {
        (VOS_VOID)AT_RemoveSpecRatFromPlatform(PLATFORM_RAT_1X, pstSourceModemPlatform);
    }

    if (ulSourceSupportHrpdFlg == VOS_TRUE )
    {
        (VOS_VOID)AT_RemoveSpecRatFromPlatform(PLATFORM_RAT_HRPD, pstSourceModemPlatform);
    }

    (VOS_VOID)AT_AddSpecRatIntoPlatform(PLATFORM_RAT_1X, pstDestinationModemPlatform);
    (VOS_VOID)AT_AddSpecRatIntoPlatform(PLATFORM_RAT_HRPD, pstDestinationModemPlatform);


    if (AT_SetCdmaModemCapPara(pstSourceModemPlatform, pstDestinationModemPlatform,
                               enSourceModemId, enDestinationModemId, ucIndex) == AT_ERROR)
    {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_SetCdmaModemCapPara return Error!");

        return VOS_FALSE;
    }
    else
    {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_SetCdmaModemCapPara return Ok!");
    }

    return VOS_TRUE;
}



VOS_UINT32 At_SetCdmaModemSwitch(VOS_UINT8 ucIndex)
{
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (2 <= MULTI_MODEM_NUMBER)
    PLATAFORM_RAT_CAPABILITY_STRU       stModem0PlatRat;
    PLATAFORM_RAT_CAPABILITY_STRU       stModem1PlatRat;
    PLATAFORM_RAT_CAPABILITY_STRU       stModem2PlatRat;
    VOS_UINT32                          ulModemId;
    AT_MTA_MODEM_CAP_UPDATE_REQ_STRU    stAtMtaModemCapUpdate;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT8                           ucIsCdmaModemSwitchNotResetFlg;
    VOS_UINT32                          ulCheckParaRlt;
    VOS_UINT32                          ulResult;

    enModemId                           = MODEM_ID_BUTT;
    memset_s(&stAtMtaModemCapUpdate, (VOS_UINT32)sizeof(AT_MTA_MODEM_CAP_UPDATE_REQ_STRU), 0x00, (VOS_UINT32)sizeof(AT_MTA_MODEM_CAP_UPDATE_REQ_STRU));

    memset_s(&stModem0PlatRat, sizeof(stModem0PlatRat), 0x00, sizeof(stModem0PlatRat));
    memset_s(&stModem1PlatRat, sizeof(stModem1PlatRat), 0x00, sizeof(stModem1PlatRat));
    memset_s(&stModem2PlatRat, sizeof(stModem2PlatRat), 0x00, sizeof(stModem2PlatRat));

    ulModemId = gastAtParaList[0].ulParaValue;

    /* 改命令仅支持在Modem0上发起 */
    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Get modem id fail!");

        return AT_ERROR;
    }

    ucIsCdmaModemSwitchNotResetFlg = AT_GetModemCdmaModemSwitchCtxAddrFromModemId(enModemId)->ucEnableFlg;

    if ((enModemId != MODEM_ID_0)
     && (ucIsCdmaModemSwitchNotResetFlg == VOS_TRUE))
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: This Command Only Support On Modem0!");

        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Platform_RAT_CAP, &stModem0PlatRat,
                           sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem0!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_0, stModem0PlatRat);
    /* 先打印便于分析，后边界保护 */
    stModem0PlatRat.usRatNum = AT_MIN(stModem0PlatRat.usRatNum, PLATFORM_MAX_RAT_NUM);

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_1, en_NV_Item_Platform_RAT_CAP, &stModem1PlatRat,
                           sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem1!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_1, stModem1PlatRat);
    /* 先打印便于分析，后边界保护 */
    stModem1PlatRat.usRatNum = AT_MIN(stModem1PlatRat.usRatNum, PLATFORM_MAX_RAT_NUM);


#if (3 == MULTI_MODEM_NUMBER)
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_2, en_NV_Item_Platform_RAT_CAP, &stModem2PlatRat,
                           sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem2!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_2, stModem2PlatRat);
    /* 先打印便于分析，后边界保护 */
    stModem2PlatRat.usRatNum = AT_MIN(stModem2PlatRat.usRatNum, PLATFORM_MAX_RAT_NUM);

#endif

#if (2 == MULTI_MODEM_NUMBER)
    /* 双modem时，设置为2的时候返回错误 */
    if (ulModemId == 2)
    {
        AT_ERR_LOG1("At_SetCdmaModemSwitch: ulModemId id Error! ulModemId: ", ulModemId);

        return AT_ERROR;
    }
#endif

    /* CDMA支持切换需满足以下条件:
       1、CDMA能力只能在一个MODEM;
       2、目标modem上不存在CDMA，如果已经存在CDMA则直接返回OK
       3、进行C模切换后的modem平台支持接入技术个数不为0
    */
    ulCheckParaRlt =  AT_CheckSwitchCdmaModePara(&stModem0PlatRat,
                                                 &stModem1PlatRat,
                                                 &stModem2PlatRat,
                                                 ulModemId);
    if (ulCheckParaRlt == AT_ERROR)
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: AT_CheckSwitchCdmaModePara return Error!");

        return AT_ERROR;
    }
    else if (ulCheckParaRlt == AT_OK)
    {
        return AT_OK;
    }
    else
    {
        /* pclint */
    }

    ulResult = AT_SwitchCdmaMode(ucIndex, ulModemId, &stModem0PlatRat,
                                  &stModem1PlatRat, &stModem2PlatRat);
    if (ulResult == VOS_FALSE)
    {
        AT_ERR_LOG("At_SetCdmaModemSwitch: AT_SwitchCdmaMode return Error!");
        return AT_ERROR;
    }
    else
    {
        AT_ERR_LOG1("At_SetCdmaModemSwitch: AT_SwitchCdmaMode return Result : ", ulResult);
        return AT_WAIT_ASYNC_RETURN;
    }

#else
    return AT_OK;
#endif
#else
    return AT_OK;
#endif

}

#if (2 <= MULTI_MODEM_NUMBER)

LOCAL VOS_UINT32  At_QryCdmaModemSwitchCdmaCapCheck(
    VOS_UINT32                          ulModem0SupportCMode,
    VOS_UINT32                          ulModem1SupportCMode,
#if (3 == MULTI_MODEM_NUMBER)
    VOS_UINT32                          ulModem2SupportCMode,
#endif
    VOS_UINT32                         *pulAllModemNotSupportCMode
)
{
    VOS_UINT32                          ulCheckRlt;

    ulCheckRlt = AT_SUCCESS;

    /* 如果modem0和modem1同时满足支持，则认为设置失败 */
    if ( (ulModem0SupportCMode == VOS_TRUE)
      && (ulModem1SupportCMode == VOS_TRUE) )
    {
        ulCheckRlt = AT_ERROR;
    }

#if (3 == MULTI_MODEM_NUMBER)
    /* 如果modem0和modem2同时满足支持，则认为设置失败 */
    if ( (ulModem0SupportCMode == VOS_TRUE)
      && (ulModem2SupportCMode == VOS_TRUE) )
    {
        ulCheckRlt = AT_ERROR;
    }

    /* 如果modem1和modem2同时满足支持，则认为设置失败 */
    if ( (ulModem1SupportCMode == VOS_TRUE)
      && (ulModem2SupportCMode == VOS_TRUE) )
    {
        ulCheckRlt = AT_ERROR;
    }
#endif

    if ( (ulModem0SupportCMode == VOS_FALSE)
      && (ulModem1SupportCMode == VOS_FALSE)
#if (3 == MULTI_MODEM_NUMBER)
      && (ulModem2SupportCMode == VOS_FALSE) )
#else
                                             )
#endif
    {
        ulCheckRlt                = AT_ERROR;
       *pulAllModemNotSupportCMode = VOS_TRUE;
    }

    return ulCheckRlt;
}
#endif

VOS_UINT32 At_QryCdmaModemSwitch(VOS_UINT8 ucIndex)
{
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (2 <= MULTI_MODEM_NUMBER)
    PLATAFORM_RAT_CAPABILITY_STRU       stModem0PlatRat;
    PLATAFORM_RAT_CAPABILITY_STRU       stModem1PlatRat;
    VOS_UINT32                          ulModem0Support1XFlg;
    VOS_UINT32                          ulModem0SupportHrpdFlg;
    VOS_UINT32                          ulModem1Support1XFlg;
    VOS_UINT32                          ulModem1SupportHrpdFlg;
    VOS_UINT32                          ulModem0SupportCMode;
    VOS_UINT32                          ulModem1SupportCMode;
    VOS_UINT32                          ulCheckRlt;
    VOS_UINT32                          ulAllModemNotSupportCMode;
#if (3 == MULTI_MODEM_NUMBER)
    PLATAFORM_RAT_CAPABILITY_STRU       stModem2PlatRat;
    VOS_UINT32                          ulModem2Support1XFlg;
    VOS_UINT32                          ulModem2SupportHrpdFlg;
    VOS_UINT32                          ulModem2SupportCMode;
#endif
    VOS_UINT16                          usLength;

    memset_s(&stModem0PlatRat, sizeof(stModem0PlatRat), 0x00, sizeof(stModem0PlatRat));
    memset_s(&stModem1PlatRat, sizeof(stModem1PlatRat), 0x00, sizeof(stModem1PlatRat));
    ulCheckRlt                = AT_SUCCESS;
    ulAllModemNotSupportCMode = VOS_FALSE;

#if (3 == MULTI_MODEM_NUMBER)
    memset_s(&stModem2PlatRat, sizeof(stModem2PlatRat), 0x00, sizeof(stModem2PlatRat));
#endif
    /*  查询读取nv，修改为从使用区读取，不从工作区读取 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Platform_RAT_CAP, &stModem0PlatRat,
                              sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        return AT_ERROR;
    }
    else
    {
        AT_NORM_LOG("Read PlatForm from success: ");
        AT_ReadPlatFormPrint(MODEM_ID_0, stModem0PlatRat);
    }

    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_1, en_NV_Item_Platform_RAT_CAP, &stModem1PlatRat,
                              sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        return AT_ERROR;
    }
    else
    {
        AT_NORM_LOG("Read PlatForm from success: ");
        AT_ReadPlatFormPrint(MODEM_ID_1, stModem1PlatRat);
    }

#if (3 == MULTI_MODEM_NUMBER)
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_2, en_NV_Item_Platform_RAT_CAP, &stModem2PlatRat,
                           sizeof(PLATAFORM_RAT_CAPABILITY_STRU)))
    {
        return AT_ERROR;
    }
#endif

    ulModem0Support1XFlg   = AT_IsPlatformSupport1XMode(&stModem0PlatRat);
    ulModem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&stModem0PlatRat);
    ulModem1Support1XFlg   = AT_IsPlatformSupport1XMode(&stModem1PlatRat);
    ulModem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&stModem1PlatRat);
#if (3 == MULTI_MODEM_NUMBER)
    ulModem2Support1XFlg   = AT_IsPlatformSupport1XMode(&stModem2PlatRat);
    ulModem2SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&stModem2PlatRat);
#endif
    ulModem0SupportCMode = (ulModem0Support1XFlg || ulModem0SupportHrpdFlg);
    ulModem1SupportCMode = (ulModem1Support1XFlg || ulModem1SupportHrpdFlg);
#if (3 == MULTI_MODEM_NUMBER)
    ulModem2SupportCMode = (ulModem2Support1XFlg || ulModem2SupportHrpdFlg);
#endif

    ulCheckRlt = At_QryCdmaModemSwitchCdmaCapCheck(ulModem0SupportCMode,
                                                ulModem1SupportCMode,
#if (3 == MULTI_MODEM_NUMBER)
                                                ulModem2SupportCMode,
#endif
                                                &ulAllModemNotSupportCMode);


    if (ulCheckRlt == AT_ERROR)
    {
        if (ulAllModemNotSupportCMode == VOS_TRUE)
        {
            usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     "%s: -1",
                                     g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

            gstAtSendData.usBufLen = usLength;

            return AT_OK;
        }

        return AT_ERROR;
    }

    /* 1X,DO在Modem0 */
    if (ulModem0SupportCMode == VOS_TRUE)
    {
        usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                         (VOS_CHAR *)pgucAtSndCodeAddr,
                                         (VOS_CHAR *)pgucAtSndCodeAddr,
                                         "%s: 0",
                                         g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

        gstAtSendData.usBufLen = usLength;

        return AT_OK;
    }

    /* 1X,DO在Modem1 */
    if (ulModem1SupportCMode == VOS_TRUE)
    {
        usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                         (VOS_CHAR *)pgucAtSndCodeAddr,
                                         (VOS_CHAR *)pgucAtSndCodeAddr,
                                         "%s: 1",
                                         g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

        gstAtSendData.usBufLen = usLength;

        return AT_OK;
    }

#if (3 == MULTI_MODEM_NUMBER)
    /* 1X,DO在Modem2 */
    if (ulModem2SupportCMode == VOS_TRUE)
    {
        usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     (VOS_CHAR *)pgucAtSndCodeAddr,
                                     "%s: 2",
                                     g_stParseContext[ucIndex].pstCmdElement->pszCmdName);

        gstAtSendData.usBufLen = usLength;

        return AT_OK;
    }
#endif

#endif
#endif

    return AT_OK;
}



VOS_UINT32 AT_SetCtaPara(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucTimeLen;

    /* 参数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucTimeLen = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    if (TAF_PS_SetCtaInfo(WUEPS_PID_AT,
                          AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                          0,
                          ucTimeLen) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CTA_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 At_SetFemCtrl(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_SET_FEMCTRL_REQ_STRU         stFemctrlReq;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (gucAtParaIndex > 4)
    {
        return AT_TOO_MANY_PARA;
    }

    if ((gastAtParaList[0].usParaLen == 0)
      ||(gastAtParaList[1].usParaLen == 0)
      ||(gastAtParaList[2].usParaLen == 0)
      ||(gastAtParaList[3].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stFemctrlReq.ulCtrlType     = gastAtParaList[0].ulParaValue;
    stFemctrlReq.ulPara1        = gastAtParaList[1].ulParaValue;
    stFemctrlReq.ulPara2        = gastAtParaList[2].ulParaValue;
    stFemctrlReq.ulPara3        = gastAtParaList[3].ulParaValue;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   At_GetOpId(),
                                   ID_AT_MTA_SET_FEMCTRL_REQ,
                                   (VOS_VOID*)&stFemctrlReq,
                                   sizeof(stFemctrlReq),
                                   I0_UEPS_PID_MTA);

    if (ulRst == AT_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_FEMCTRL_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }

}

VOS_UINT32 At_SetRatRfSwitch(VOS_UINT8 ucIndex)
{
    NAS_NV_TRI_MODE_ENABLE_STRU                     stTriModeEnableStru;
    NAS_NV_TRI_MODE_FEM_PROFILE_ID_STRU             stTriModeFemProfileIdStru;

    memset_s(&stTriModeEnableStru, sizeof(stTriModeEnableStru), 0x00, sizeof(stTriModeEnableStru));
    memset_s(&stTriModeFemProfileIdStru, sizeof(stTriModeFemProfileIdStru), 0x00, sizeof(stTriModeFemProfileIdStru));

    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen == 0)
     || (gucAtParaIndex != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*查询是否支持全网通功能*/
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_TRI_MODE_ENABLE, &stTriModeEnableStru, sizeof(stTriModeEnableStru)) != NV_OK)
    {
        AT_WARN_LOG("At_SetRatRfSwitch:read en_NV_Item_TRI_MODE_ENABLE failed");
        return AT_ERROR;
    }

    /*不支持，返回*/
    if(stTriModeEnableStru.usEnable == 0)
    {
        AT_WARN_LOG("At_SetRatRfSwitch:uhwEnable is not enabled");
        return AT_CME_OPERATION_NOT_ALLOWED;
    }

    stTriModeFemProfileIdStru.ulProfileId=gastAtParaList[0].ulParaValue;

    /* 配置Profile Id*/
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_TRI_MODE_FEM_PROFILE_ID, &stTriModeFemProfileIdStru, sizeof(stTriModeFemProfileIdStru)) != NV_OK)
    {
        AT_WARN_LOG("At_SetRatRfSwitch: MODEM_ID_0 write en_NV_Item_TRI_MODE_FEM_PROFILE_ID failed");
        return AT_ERROR;
    }

    return AT_OK;
}



VOS_UINT32 AT_SetQuitCallBack( VOS_UINT8 ucIndex  )
{
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)
    {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetQuitCallBack (WUEPS_PID_AT,
                                             gastAtClientTab[ucIndex].usClientId,
                                             0) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_QCCB_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}


#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_Set1xChanPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_CFREQ_LOCK_SET_PARA_STRU    stCFreqLockPara;
    VOS_UINT32                          ulRst;

    /*参数有效性检查*/
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数合法性判断 */
    if ((gucAtParaIndex != 1)
      ||(gastAtParaList[0].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息赋值 */
    memset_s(&stCFreqLockPara, sizeof(stCFreqLockPara), 0x00, sizeof(TAF_MMA_CFREQ_LOCK_SET_PARA_STRU));

    /* 复用锁频接口，除channel外，其他填0或者通配符 */
    stCFreqLockPara.enFreqLockMode  = TAF_MMA_CFREQ_LOCK_MODE_ON;
    stCFreqLockPara.usSid           = 0x0000;
    stCFreqLockPara.usNid           = 0xFFFF;
    stCFreqLockPara.usCdmaBandClass = 0x0000;
    stCFreqLockPara.usCdmaFreq      = (VOS_UINT16)gastAtParaList[0].ulParaValue;
    stCFreqLockPara.usCdmaPn        = 0xFFFF;
    stCFreqLockPara.usEvdoBandClass = 0x0000;
    stCFreqLockPara.usEvdoFreq      = 0x0000;
    stCFreqLockPara.usEvdoPn        = 0xFFFF;

    /* 发送TAF_MMA_CFREQ_LOCK_SET_REQ消息 */
    ulRst = TAF_MMA_Proc1xChanSetReq(WUEPS_PID_AT,
                                     gastAtClientTab[ucIndex].usClientId,
                                     gastAtClientTab[ucIndex].opId,
                                    &stCFreqLockPara);
    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_1XCHAN_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif


VOS_UINT32 AT_SetCSidEnable(VOS_UINT8 ucIndex )
{

    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU     stAtCmd;
    VOS_UINT32                              ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].ulParaValue > 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType       = AT_MTA_SET_CSID_RPT_TYPE;
    stAtCmd.u.ucCsidRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^CSID设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                   &stAtCmd,
                                   sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

/* 移出CDMA编译开关 */


VOS_UINT32 AT_ConvertCSidListMcc(
    VOS_UINT8                          *pucPara,
    VOS_UINT16                          usLen,
    VOS_UINT32                         *pstMcc
)
{
    VOS_UINT32                          ulRslt;

    ulRslt                              = 0;

    /* 如果Mcc为空，返回失败*/
    if (usLen != 3)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRslt |= (*pucPara - '0');
    ulRslt |= ((VOS_UINT32)(*(pucPara + 1) - '0') << 8);
    ulRslt |= ((VOS_UINT32)(*(pucPara + 2) - '0') << 16);

   *pstMcc = ulRslt;

    return AT_SUCCESS;
}
#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 AT_SetCSidList( VOS_UINT8 ucIndex   )
{
    TAF_MMA_OPER_LOCK_WHITE_SID_STRU    stWhiteSidList;
    VOS_UINT8                           ucListNum;
    VOS_UINT32                          ulRslt;
    VOS_UINT32                          i;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_ERROR;
    }

    /* 入参检查 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*参数个数为3N+1 */
    if ((gucAtParaIndex - 1)%3 != 0)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*参数过多 AT命令最大参数个数为16个 即5组白名单*/
    if (gucAtParaIndex > AT_MAX_PARA_NUMBER)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stWhiteSidList, sizeof(stWhiteSidList), 0x00, sizeof(stWhiteSidList));

    if (gastAtParaList[0].ulParaValue != 0)
    {
        stWhiteSidList.ucEnable = VOS_TRUE;
    }
    else
    {
        stWhiteSidList.ucEnable = VOS_FALSE;
    }

    stWhiteSidList.usWhiteSysNum = (gucAtParaIndex - 1)/3;
    i = 0;
    for ( ucListNum = 1; ucListNum < gucAtParaIndex; ucListNum += 3)
    {
        /* startSid value must less then endSid value */
        if (gastAtParaList[ucListNum].ulParaValue > gastAtParaList[ucListNum + 1].ulParaValue)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        stWhiteSidList.astSysInfo[i].usStartSid = (VOS_UINT16)gastAtParaList[ucListNum].ulParaValue;
        stWhiteSidList.astSysInfo[i].usEndSid = (VOS_UINT16)gastAtParaList[ucListNum + 1].ulParaValue;

        /* 转换 mcc */
        ulRslt = AT_ConvertCSidListMcc(gastAtParaList[ucListNum + 2].aucPara,
                                       gastAtParaList[ucListNum + 2].usParaLen,
                                      &stWhiteSidList.astSysInfo[i].ulMcc);

        i++;

        if (i >= TAF_MMA_MAX_WHITE_LOCK_SID_NUM)
        {
            break;
        }

        if (ulRslt != AT_SUCCESS)
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }


    /* 执行命令操作 */
    if (TAF_MMA_SetCSidList (WUEPS_PID_AT,
                             gastAtClientTab[ucIndex].usClientId,
                             0,
                             &stWhiteSidList) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CSIDLIST_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    else
    {
        return AT_ERROR;
    }
}
#endif
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT == FEATURE_ON)

VOS_UINT32 AT_SetEncryptCall(VOS_UINT8 ucIndex)
{
    errno_t                             lMemResult;
    VOS_UINT8                           aucCallNum[AT_CMD_ECCALL_MAX_NUM_LENGTH + 1];
    VOS_UINT32                          ulStartIndex;
    TAF_CTRL_STRU                       stCtrl;
    TAF_CCM_ENCRYPT_VOICE_PARA_STRU     stEncrypVoicePara;
    MODEM_ID_ENUM_UINT16                enModemId;
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)
    TAF_CHAR                           *pFile = VOS_NULL_PTR;
    TAF_CHAR                            acNewDocName[AT_TEST_ECC_FILE_NAME_MAX_LEN];
    VOS_INT32                           lLength;

    memset_s(acNewDocName, (VOS_SIZE_T)sizeof(acNewDocName), 0x00, (VOS_SIZE_T)sizeof(acNewDocName));

    lLength = 0;
#endif

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stEncrypVoicePara, sizeof(stEncrypVoicePara), 0x00, sizeof(stEncrypVoicePara));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((gastAtParaList[0].usParaLen != 1)||(gastAtParaList[1].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    lMemResult = memset_s(aucCallNum, (VOS_UINT32)sizeof(aucCallNum), 0x00, AT_CMD_ECCALL_MAX_NUM_LENGTH + 1);
    TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_UINT32)sizeof(aucCallNum), AT_CMD_ECCALL_MAX_NUM_LENGTH + 1);
    /* 如果呼叫号码大于11位，则仅取最后的11位 */
    ulStartIndex = 0;
    if (gastAtParaList[1].usParaLen > AT_CMD_ECCALL_MAX_NUM_LENGTH)
    {
        ulStartIndex = gastAtParaList[1].usParaLen - AT_CMD_ECCALL_MAX_NUM_LENGTH;
    }
    lMemResult = memcpy_s(aucCallNum, (VOS_UINT32)sizeof(aucCallNum), &gastAtParaList[1].aucPara[ulStartIndex], AT_CMD_ECCALL_MAX_NUM_LENGTH);
    TAF_MEM_CHK_RTN_VAL(lMemResult, (VOS_UINT32)sizeof(aucCallNum), AT_CMD_ECCALL_MAX_NUM_LENGTH);

    /* 检查并转换电话号码 */
    if (AT_AsciiNumberToBcd ((VOS_CHAR *)aucCallNum,
                             stEncrypVoicePara.stDialNumber.aucBcdNum,
                             &stEncrypVoicePara.stDialNumber.ucNumLen) != MN_ERR_NO_ERROR)
    {
        return AT_ERROR;
    }

    /* 执行命令操作 */

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stEncrypVoicePara.enEccVoiceType    = gastAtParaList[0].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SEND_FLASH_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stEncrypVoicePara,
                              ID_TAF_CCM_ENCRYPT_VOICE_REQ,
                              sizeof(stEncrypVoicePara),
                              enModemId) == VOS_OK)
    {
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)

        /* 密话测试模式写文件path下标 */
        gucCurrEncVoiceDataWriteFileNum++;

        /* 最大写密话数据文件数为5,超过的话循环写文件1，同时需要删掉文件中的内容 */
        if (gucCurrEncVoiceDataWriteFileNum > ENCRYPT_VOICE_DATA_FILE_MAX_NUM)
        {
            gucCurrEncVoiceDataWriteFileNum = 1;
        }
        gulAtCurrEncVoiceDataCount = 0;

        gucAtCurrEncVoiceTestFileNum++;

        memset_s(gacAtCurrDocName, (VOS_SIZE_T)sizeof(gacAtCurrDocName), 0x00, (VOS_SIZE_T)sizeof(gacAtCurrDocName));

        lLength = VOS_sprintf_s(acNewDocName, (VOS_SIZE_T)sizeof(acNewDocName), MODEM_LOG_ROOT"/ECC_TEST/Encrypted_call_execute_time%d.txt", gucAtCurrEncVoiceTestFileNum);
        if (lLength <= 0)
        {
            AT_WARN_LOG("AT_SetEncryptCall(): VOS_sprintf_s len <= 0");

            return AT_ERROR;
        }

        /* 清除待写入文件中的内容 */
        pFile = mdrv_file_open(g_pacCurrEncVoiceDataWriteFilePath[gucCurrEncVoiceDataWriteFileNum], "w");
        if(pFile != VOS_NULL_PTR)
        {
            AT_WARN_LOG("AT_SetEncryptCall: file is not exist!!!\n");

            mdrv_file_close(pFile);
        }

        pFile = mdrv_file_open(acNewDocName, "w");
        if (pFile != VOS_NULL_PTR)
        {
            AT_WARN_LOG("AT_SetEncryptCall: file is not exist!!!\n");

            mdrv_file_close(pFile);
        }
#endif
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECCALL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    return AT_ERROR;

}


VOS_UINT32 AT_SetEncryptCallRemoteCtrl(
    VOS_UINT8                           ucIndex
)
{
    TAF_CTRL_STRU                                           stCtrl;
    TAF_CCM_REMOTE_CTRL_ANSWER_INFO_STRU                    stRemoteCtrlAnswerInfo;
    MODEM_ID_ENUM_UINT16                                    enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stRemoteCtrlAnswerInfo, sizeof(stRemoteCtrlAnswerInfo), 0x00, sizeof(stRemoteCtrlAnswerInfo));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((gastAtParaList[0].usParaLen != 1)||(gastAtParaList[1].usParaLen != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stRemoteCtrlAnswerInfo.enRemoteCtrlEvtType = gastAtParaList[0].ulParaValue;
    stRemoteCtrlAnswerInfo.enResult            = gastAtParaList[1].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stRemoteCtrlAnswerInfo,
                              ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ,
                              sizeof(stRemoteCtrlAnswerInfo),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECCTRL_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }
    return AT_ERROR;


}


VOS_UINT32 AT_SetEncryptCallCap( VOS_UINT8 ucIndex )
{

    TAF_CTRL_STRU                                           stCtrl;
    TAF_CCM_ECC_SRV_CAP_CFG_PARA_STRU                       stEncryptCallCapPara;
    MODEM_ID_ENUM_UINT16                                    enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stEncryptCallCapPara, sizeof(stEncryptCallCapPara), 0x00, sizeof(stEncryptCallCapPara));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((gastAtParaList[0].usParaLen != 1)||(gastAtParaList[1].usParaLen != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 用户不允许enalbe密话业务能力，只允许disable密话能力 */
    if (gastAtParaList[0].ulParaValue == TAF_CALL_ECC_SRV_CAP_ENABLE)
    {
        return AT_CME_OPERATION_NOT_ALLOWED;
    }


    /* 执行命令操作 */
    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stEncryptCallCapPara.enEccSrvCap    = gastAtParaList[0].ulParaValue;
    stEncryptCallCapPara.enEccSrvStatus = gastAtParaList[1].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 给CCM发送ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stEncryptCallCapPara,
                              ID_TAF_CCM_ECC_SRV_CAP_CFG_REQ,
                              sizeof(stEncryptCallCapPara),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECCAP_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;

}

#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)

VOS_UINT32 AT_SetEncryptCallKmc( VOS_UINT8 ucIndex )
{
    TAF_CTRL_STRU                       stCtrl;
    MN_CALL_APP_EC_KMC_DATA_STRU        stKmcData;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stKmcData, sizeof(stKmcData), 0x00, sizeof(stKmcData));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 入参长度检查 */
    if ((gastAtParaList[1].usParaLen > AT_CMD_ECKMC_MAX_KMC_LENGTH)
     || (gastAtParaList[1].usParaLen == 0)
     || (gastAtParaList[0].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stKmcData.ucEccKmcVer = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    if (gastAtParaList[1].usParaLen%2 == 0)
    {
        stKmcData.usEccKmcLength = gastAtParaList[1].usParaLen/2;
    }
    else
    {
        stKmcData.usEccKmcLength = gastAtParaList[1].usParaLen/2 + 1;
    }

    /*lint -e516 */
    /*  把kmc data转换为hex保存 */
    if (At_AsciiString2HexSimple(stKmcData.aucEccKmcData,
                                 gastAtParaList[1].aucPara,
                                 gastAtParaList[1].usParaLen) == AT_FAILURE)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SET_EC_KMC_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stKmcData,
                              ID_TAF_CCM_SET_EC_KMC_REQ,
                              sizeof(stKmcData),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECKMC_SET;

        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

VOS_UINT32 AT_SetEccTestMode( VOS_UINT8 ucIndex )
{
    TAF_CTRL_STRU                                           stCtrl;
    TAF_CALL_SET_EC_TEST_MODE_ENUM_UINT32                   enEccTestModeStatus;
    MODEM_ID_ENUM_UINT16                                    enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为1 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 入参长度检查 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gucAtCurrEncVoiceTestFileNum = 0;

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    enEccTestModeStatus                 = gastAtParaList[0].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SET_EC_TEST_MODE_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &enEccTestModeStatus,
                              ID_TAF_CCM_SET_EC_TEST_MODE_REQ,
                              sizeof(enEccTestModeStatus),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_ECCTEST_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;

}


#endif
#endif

VOS_UINT32 AT_SetClocinfoEnable(VOS_UINT8 ucIndex )
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU stAtCmd;
    VOS_UINT32                          ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].ulParaValue > 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType           = AT_MTA_SET_CLOCINFO_RPT_TYPE;
    stAtCmd.u.ucClocinfoRptFlg  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^CLOCINFO设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 AT_SetPrivacyModePreferred(VOS_UINT8 ucIndex)
{

    TAF_CTRL_STRU                       stCtrl;
    TAF_CALL_PRIVACY_MODE_SET_PARA_STRU stPrivacyMode;
    MODEM_ID_ENUM_UINT16                enModemId;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(stCtrl));
    memset_s(&stPrivacyMode, sizeof(stPrivacyMode), 0x00, sizeof(stPrivacyMode));

    /* 检查命令类型是否匹配 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查入参长度检查 */
    if (gastAtParaList[0].usParaLen != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数值范围 */
    if ((gastAtParaList[0].ulParaValue != 0)
     && (gastAtParaList[0].ulParaValue != 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */

    stCtrl.ulModuleId                   = WUEPS_PID_AT;
    stCtrl.usClientId                   = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId                       = gastAtClientTab[ucIndex].opId;

    stPrivacyMode.enPrivacyMode         = (TAF_CALL_PRIVACY_MODE_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    if (AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_PRIVACY_MODE_SET_REQ消息 */
    if (TAF_CCM_CallCommonReq(&stCtrl,
                              &stPrivacyMode,
                              ID_TAF_CCM_PRIVACY_MODE_SET_REQ,
                              sizeof(stPrivacyMode),
                              enModemId) == VOS_OK)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CPMP_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCtOosCount(VOS_UINT8 ucIndex)
{
    /* 检查命令类型是否匹配 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (gucAtParaIndex != 2)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetCtOosCount(WUEPS_PID_AT,
                              gastAtClientTab[ucIndex].usClientId,
                              0,
                              gastAtParaList[0].ulParaValue,
                              gastAtParaList[1].ulParaValue) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CTOOSCOUNT_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCtRoamInfo(VOS_UINT8 ucIndex)
{
    /* 检查命令类型是否匹配 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetCtRoamInfo(WUEPS_PID_AT,
                              gastAtClientTab[ucIndex].usClientId,
                              0,
                              (VOS_UINT8)gastAtParaList[0].ulParaValue) == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CTROAMINFO_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetNoCardMode(VOS_UINT8 ucIndex )
{
    AT_MTA_NO_CARD_MODE_SET_REQ_STRU    stNoCardModeCfg = {0};
    VOS_UINT32                          ulRslt;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if ((gastAtParaList[0].usParaLen == 0) || (gastAtParaList[0].ulParaValue > 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stNoCardModeCfg, sizeof(stNoCardModeCfg), 0x00, sizeof(stNoCardModeCfg));

    stNoCardModeCfg.ulEnableFlag  = gastAtParaList[0].ulParaValue;

    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    0,
                                    ID_AT_MTA_NO_CARD_MODE_SET_REQ,
                                    &stNoCardModeCfg,
                                    sizeof(stNoCardModeCfg),
                                    I0_UEPS_PID_MTA);

    if (ulRslt == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_NOCARDMODE_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetNoCardMode: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}


#endif


VOS_UINT32 AT_CheckMccFreqPara(VOS_VOID)
{
    VOS_UINT32                          ulLoop;
    VOS_UINT32                          ulLength;

    /* 参数个数不正确,4~7个参数 */
    if((gucAtParaIndex > 7)
    || (gucAtParaIndex < 4))
    {
       AT_ERR_LOG("AT_CheckMccFreqPara:number of parameter error.");

       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数长度不对 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen != MCC_INFO_VERSION_LEN)
     || (gastAtParaList[2].usParaLen == 0)
     || (gastAtParaList[3].usParaLen == 0))
    {
        AT_ERR_LOG("AT_CheckMccFreqPara:para len error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是删除所有的运营商预制频点和频段信息，不需要携带BS1、BS2、BS3，且length必须为0 */
    if ((gastAtParaList[2].ulParaValue == AT_CSS_SET_MCC_TYPE_DELETE_ALL_MCC)
     && ((gucAtParaIndex > 4)
      || (gastAtParaList[3].ulParaValue != 0)))
    {
       AT_ERR_LOG("AT_CheckMccFreqPara:too mang para when delete all mcc.");

       return AT_CME_INCORRECT_PARAMETERS;
    }

    ulLength = 0;

    /* 获取携带BS1、BS2、BS3码流总长度,BS1是第五个参数，即gastAtParaList[4]保存着BS1相关信息 */
    for (ulLoop = 4; ulLoop < gucAtParaIndex; ulLoop++)
    {
        /*  如果输入的BS1、或者BS2、或者BS3存在空洞或者长度大于500，直接返回错误
            例如AT^MCCFREQ=255,"00.00.001",0,100,,BS2(其中BS1存在空洞,长度为0)
            AT^MCCFREQ=255,"00.00.001",0,100,BS1,    (其中BS2存在空洞,长度为0) */
        if ((gastAtParaList[ulLoop].usParaLen == 0)
         || (gastAtParaList[ulLoop].usParaLen > AT_CMD_MCCFREQ_BS_MAX_LENGTH))
        {
            AT_ERR_LOG("AT_CheckMccFreqPara: string BS format is error");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulLength += gastAtParaList[ulLoop].usParaLen;
    }

    /* 如果BS1、BS2、BS3码流总长度与AT命令中携带的LENGTH长度不相同，直接返回错误 */
    if (ulLength != gastAtParaList[3].ulParaValue)
    {
        AT_ERR_LOG("AT_CheckMccFreqPara: total length is error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetMccFreqPara(
    VOS_UINT8                           ucIndex
)
{
    AT_CSS_MCC_INFO_SET_REQ_STRU       *pstMsg = VOS_NULL_PTR;
    VOS_UINT32                          ulBufLen;
    MODEM_ID_ENUM_UINT16                enModemId;
    VOS_UINT32                          ulRet;
    VOS_UINT32                          ulResult;
    errno_t                             lMemResult;

    enModemId = MODEM_ID_0;

    ulRet = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRet != VOS_OK)
    {
        AT_ERR_LOG("AT_SetMccFreqPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 命令类型检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_ERR_LOG("AT_SetMccFreqPara:Cmd Opt Type is wrong.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    ulResult = AT_CheckMccFreqPara();
    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("AT_SetMccFreqPara:check mcc freq para error.");

        return ulResult;
    }

    /* 预制频点信息长度 */
    ulBufLen = sizeof(AT_CSS_MCC_INFO_SET_REQ_STRU);

    if (gastAtParaList[3].ulParaValue > 4)
    {
        ulBufLen += gastAtParaList[3].ulParaValue - 4;
    }

    /* 申请消息包AT_CSS_MCC_INFO_SET_REQ_STRU */
    pstMsg = (AT_CSS_MCC_INFO_SET_REQ_STRU*)AT_ALLOC_MSG_WITH_HDR(ulBufLen);

    /* 内存申请失败，返回 */
    if (pstMsg == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetMccFreqPara:memory alloc fail.");
        return AT_ERROR;
    }

    lMemResult = memset_s((VOS_INT8 *)pstMsg + VOS_MSG_HEAD_LENGTH, (VOS_SIZE_T)ulBufLen - VOS_MSG_HEAD_LENGTH, 0x00, (VOS_SIZE_T)ulBufLen - VOS_MSG_HEAD_LENGTH);
    TAF_MEM_CHK_RTN_VAL(lMemResult, ulBufLen - VOS_MSG_HEAD_LENGTH, ulBufLen - VOS_MSG_HEAD_LENGTH);

    /* 填写消息头 */
    AT_CFG_MSG_HDR(pstMsg, PS_PID_CSS, ID_AT_CSS_MCC_INFO_SET_REQ);

    /* 填写消息内容 */
    pstMsg->usModemId                   = enModemId;
    pstMsg->usClientId                  = gastAtClientTab[ucIndex].usClientId;
    pstMsg->ucSeq                       = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    pstMsg->ucOperateType               = (VOS_UINT8)gastAtParaList[2].ulParaValue;
    pstMsg->ulMccInfoBuffLen            = gastAtParaList[3].ulParaValue;

    lMemResult = memcpy_s(pstMsg->aucVersionId, sizeof(pstMsg->aucVersionId), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstMsg->aucVersionId), gastAtParaList[1].usParaLen);

    if (pstMsg->ulMccInfoBuffLen > 0)
    {
        /* BS1 */
        lMemResult = memcpy_s(pstMsg->aucMccInfoBuff, pstMsg->ulMccInfoBuffLen, gastAtParaList[4].aucPara, gastAtParaList[4].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulMccInfoBuffLen, gastAtParaList[4].usParaLen);

        /* BS1 未携带完所有的频点频段信息，BS2 携带了部分信息 */
        if (pstMsg->ulMccInfoBuffLen > gastAtParaList[4].usParaLen)
        {
            lMemResult = memcpy_s(pstMsg->aucMccInfoBuff + gastAtParaList[4].usParaLen,
                                  pstMsg->ulMccInfoBuffLen - gastAtParaList[4].usParaLen,
                                  gastAtParaList[5].aucPara,
                                  gastAtParaList[5].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulMccInfoBuffLen - gastAtParaList[4].usParaLen, gastAtParaList[5].usParaLen);

            /* BS1 & BS2 未携带完所有的频点频段信息，BS3 携带了部分信息 */
            if (pstMsg->ulMccInfoBuffLen > ((VOS_UINT32)gastAtParaList[4].usParaLen + gastAtParaList[5].usParaLen))
            {
                lMemResult = memcpy_s(pstMsg->aucMccInfoBuff + gastAtParaList[4].usParaLen + gastAtParaList[5].usParaLen,
                                      pstMsg->ulMccInfoBuffLen - gastAtParaList[4].usParaLen - gastAtParaList[5].usParaLen,
                                      gastAtParaList[6].aucPara,
                                      gastAtParaList[6].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulMccInfoBuffLen - gastAtParaList[4].usParaLen - gastAtParaList[5].usParaLen, gastAtParaList[6].usParaLen);
            }
        }
    }
    /* 发送消息，返回命令处理挂起状态 */

    AT_SEND_MSG(pstMsg);

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_MCCFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckBlackCellListBsPara(VOS_VOID)
{
    VOS_UINT32                          ulLoop;
    VOS_UINT32                          ulLength;

    ulLength = 0;

    /* 获取携带BS1、BS2、BS3码流总长度,BS1是第六个参数，即gastAtParaList[5]保存着BS1相关信息 */
    for (ulLoop = 5; ulLoop < gucAtParaIndex; ulLoop++)
    {
        /* 如果输入的BS1、或者BS2、或者BS3存在空洞或者长度大于500，直接返回错误
           例如AT^CLOUDBLACKLIST=255,"00.00.001",0,0,504,,BS2 (其中BS1存在空洞,长度为0),
           AT^CLOUDBLACKLIST=255,"00.00.001",0,0,504,BS1,     (其中BS2存在空洞,长度为0) */
        if ((gastAtParaList[ulLoop].usParaLen == 0)
         || (gastAtParaList[ulLoop].usParaLen > AT_CMD_BLACK_CELL_BS_MAX_LENGTH))
        {
            AT_ERR_LOG("AT_CheckBlackCellListBsPara: input BS format is error");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        ulLength += gastAtParaList[ulLoop].usParaLen;
    }

    /* 如果BS1、BS2、BS3码流总长度与AT命令中携带的LENGTH长度不相同，直接返回错误 */
    if (ulLength != gastAtParaList[4].ulParaValue)
    {
        AT_ERR_LOG("AT_CheckBlackCellListBsPara: total length is error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_CheckBlackCellListPara(VOS_VOID)
{
    /* 参数个数不正确,5~8个参数 */
    if((gucAtParaIndex > 8)
    || (gucAtParaIndex < 5))
    {
       AT_ERR_LOG("AT_CheckBlackCellListPara:number of parameter error.");

       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数长度不对 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen != AT_CSS_BLACK_CELL_LIST_VERSION_LEN)
     || (gastAtParaList[2].usParaLen == 0)
     || (gastAtParaList[3].usParaLen == 0)
     || (gastAtParaList[4].usParaLen == 0))
    {
        AT_ERR_LOG("AT_CheckBlackCellListPara:para len error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是删除所有的云通信黑小区信息，不需要携带BS1、BS2、BS3，且length必须为0 */
    if ((gastAtParaList[2].ulParaValue == AT_CSS_BLACK_CELL_LIST_DELETE_ALL)
     && ((gucAtParaIndex > 5)
      || (gastAtParaList[4].ulParaValue != 0)))
    {
       AT_ERR_LOG("AT_CheckBlackCellListPara:too mang para when delete all cloud black list.");

       return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 输入的BS格式不正确，包括存在空洞、BS总长度不等于length长度 */
    if (AT_CheckBlackCellListBsPara() != AT_SUCCESS)
    {
        AT_ERR_LOG("AT_CheckBlackCellListPara:input BS para is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetBlackCellListPara(
    VOS_UINT8                           ucIndex
)
{
    AT_CSS_BLACK_CELL_LIST_SET_REQ_STRU                    *pstMsg = VOS_NULL_PTR;
    VOS_UINT32                                              ulBufLen;
    VOS_UINT32                                              ulResult;
    errno_t                                                 lMemResult;

    /* 命令类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_ERR_LOG("AT_SetBlackCellListPara:Cmd Opt Type is wrong.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    ulResult = AT_CheckBlackCellListPara();
    if (ulResult != AT_SUCCESS)
    {
        AT_ERR_LOG("AT_SetBlackCellListPara:check black cell list para error.");

        return ulResult;
    }

    ulBufLen = sizeof(AT_CSS_BLACK_CELL_LIST_SET_REQ_STRU);

    if (gastAtParaList[4].ulParaValue > 4)
    {
        ulBufLen += gastAtParaList[4].ulParaValue - 4;
    }

    /* 申请消息包AT_CSS_CLOUD_BLACK_LIST_SET_REQ_STRU */
    pstMsg = (AT_CSS_BLACK_CELL_LIST_SET_REQ_STRU *)AT_ALLOC_MSG_WITH_HDR(ulBufLen);

    /* 内存申请失败，返回 */
    if (pstMsg == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetBlackCellListPara:memory alloc fail.");

        return AT_ERROR;
    }

    TAF_MEM_SET_S((VOS_INT8 *)pstMsg + VOS_MSG_HEAD_LENGTH,
                  (VOS_SIZE_T)ulBufLen - VOS_MSG_HEAD_LENGTH,
                  0x00,
                  (VOS_SIZE_T)ulBufLen - VOS_MSG_HEAD_LENGTH);

    /* 填写消息头 */
    AT_CFG_MSG_HDR(pstMsg, PS_PID_CSS, ID_AT_CSS_BLACK_CELL_LIST_SET_REQ);

    /* 填写消息内容 */
    pstMsg->usClientId                  = gastAtClientTab[ucIndex].usClientId;
    pstMsg->ucSeq                       = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    lMemResult = memcpy_s(pstMsg->aucVersionId,
                          sizeof(pstMsg->aucVersionId),
                          gastAtParaList[1].aucPara,
                          gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstMsg->aucVersionId), gastAtParaList[1].usParaLen);

    pstMsg->enOperateType               = (VOS_UINT8)gastAtParaList[2].ulParaValue;
    pstMsg->enRatType                   = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    pstMsg->ulBlackCellListBuffLen      = gastAtParaList[4].ulParaValue;

    if (pstMsg->ulBlackCellListBuffLen > 0)
    {
        /* BS1 */
        lMemResult = memcpy_s(pstMsg->aucBlackCellListBuff,
                              pstMsg->ulBlackCellListBuffLen,
                              gastAtParaList[5].aucPara,
                              gastAtParaList[5].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulBlackCellListBuffLen, gastAtParaList[5].usParaLen);

        /* BS1未携带完所有的云通信黑小区信息，BS2携带了部分信息 */
        if (pstMsg->ulBlackCellListBuffLen > gastAtParaList[5].usParaLen)
        {
            lMemResult = memcpy_s(pstMsg->aucBlackCellListBuff + gastAtParaList[5].usParaLen,
                                  pstMsg->ulBlackCellListBuffLen - gastAtParaList[5].usParaLen,
                                  gastAtParaList[6].aucPara,
                                  gastAtParaList[6].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulBlackCellListBuffLen - gastAtParaList[5].usParaLen, gastAtParaList[6].usParaLen);

            /* BS1 & BS2未携带完所有的云通信黑小区信息，BS3携带了部分信息 */
            if (pstMsg->ulBlackCellListBuffLen > ((VOS_UINT32)gastAtParaList[5].usParaLen + gastAtParaList[6].usParaLen))
            {
                lMemResult = memcpy_s(pstMsg->aucBlackCellListBuff + gastAtParaList[5].usParaLen + gastAtParaList[6].usParaLen,
                                      pstMsg->ulBlackCellListBuffLen - gastAtParaList[5].usParaLen - gastAtParaList[6].usParaLen,
                                      gastAtParaList[7].aucPara,
                                      gastAtParaList[7].usParaLen);
                TAF_MEM_CHK_RTN_VAL(lMemResult, pstMsg->ulBlackCellListBuffLen - gastAtParaList[5].usParaLen - gastAtParaList[6].usParaLen, gastAtParaList[7].usParaLen);
            }
        }
    }

    /* 发送消息，返回命令处理挂起状态 */
    AT_SEND_MSG(pstMsg);

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_BLACKCELLLIST_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 TAF_MMA_BuildBorderInfo(
    VOS_UINT32                                              ulBsTotalLen,
    TAF_MMA_BORDER_INFO_STRU                               *pstBorderInfo
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulOffset;

    /* 流水号 */
    pstBorderInfo->ucSeq    = (VOS_UINT8)gastAtParaList[1].ulParaValue;

    /* 版本号 */
    lMemResult = memcpy_s(pstBorderInfo->aucVersionId, TAF_MMA_VERSION_INFO_LEN, gastAtParaList[2].aucPara, gastAtParaList[2].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_VERSION_INFO_LEN, gastAtParaList[2].usParaLen);

    /* EHPLMN信息 */
    pstBorderInfo->ucEhPlmnNum = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    if (AT_ParseEhplmnStringList(gastAtParaList[4].usParaLen,
                                 gastAtParaList[4].aucPara,
                                 &(pstBorderInfo->ucEhPlmnNum),
                                 pstBorderInfo->astEhPlmnList) == AT_ERROR)
    {
        AT_ERR_LOG("TAF_MMA_BuildBorderInfo: parse EHPLMN list failed!");
        return VOS_FALSE;
    }

    /* 边境信息 */
    pstBorderInfo->ulBorderInfoLen = ulBsTotalLen;

    ulOffset = 0;

    /* BS1 */
    lMemResult = memcpy_s(pstBorderInfo->aucBorderInfoBuff, pstBorderInfo->ulBorderInfoLen, gastAtParaList[6].aucPara, gastAtParaList[6].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, pstBorderInfo->ulBorderInfoLen, gastAtParaList[6].usParaLen);

    ulOffset += gastAtParaList[6].usParaLen;

    /* BS1 未携带完所有的边境信息，BS2 携带了部分信息 */
    if (ulBsTotalLen > ulOffset)
    {

        lMemResult = memcpy_s(pstBorderInfo->aucBorderInfoBuff + ulOffset,
                              gastAtParaList[7].usParaLen,
                              gastAtParaList[7].aucPara,
                              gastAtParaList[7].usParaLen);
        TAF_MEM_CHK_RTN_VAL(lMemResult, gastAtParaList[7].usParaLen, gastAtParaList[7].usParaLen);

        ulOffset += gastAtParaList[7].usParaLen;

        /* BS1 & BS2 未携带完所有的边境信息，BS3 携带了部分信息 */
        if (ulBsTotalLen > ulOffset)
        {

            lMemResult = memcpy_s(pstBorderInfo->aucBorderInfoBuff + ulOffset,
                                  gastAtParaList[8].usParaLen,
                                  gastAtParaList[8].aucPara,
                                  gastAtParaList[8].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, gastAtParaList[8].usParaLen, gastAtParaList[8].usParaLen);

            ulOffset += gastAtParaList[8].usParaLen;
        }

    }

    return VOS_TRUE;
}


VOS_UINT32 AT_SetBorderInfoPara(
    VOS_UINT8                           ucIndex
)
{
    TAF_MMA_BORDER_INFO_STRU                               *pstBorderInfo   = VOS_NULL_PTR;
    VOS_UINT32                                              ulBsTotalLen;
    VOS_UINT32                                              ulRslt;
    errno_t                                                 lMemResult;
    MODEM_ID_ENUM_UINT16                                    enModemId;
    VOS_UINT8                                               i;
    TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ENUM_UINT8         enOperateType;
    VOS_UINT8                                               ucBsCount;

    enModemId       = MODEM_ID_0;
    ulBsTotalLen    = 0;

    ulRslt          = AT_GetModemIdFromClient(ucIndex, &enModemId);

    if (ulRslt != VOS_OK)
    {
        AT_ERR_LOG("AT_SetBorderInfoPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 操作类型 0:增加 1:删除所有 */
    enOperateType = (TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ENUM_UINT8)gastAtParaList[0].ulParaValue;

    /* 参数个数或者VER长度不正确 */
    if (enOperateType == TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ADD)
    {
        if ((gucAtParaIndex > 9)
         || (gucAtParaIndex < 7)
         || (gastAtParaList[2].usParaLen != MCC_INFO_VERSION_LEN))
        {
           AT_ERR_LOG("AT_SetBorderInfoPara:number of parameter error.");
           return AT_CME_INCORRECT_PARAMETERS;
        }

        /* ucBsCount的有效性AT框架已经有合法性检查，此处不再检查 */
        ucBsCount = (VOS_UINT8)gastAtParaList[5].ulParaValue;

        for (i = 0; i < ucBsCount; i++)
        {
            ulBsTotalLen += gastAtParaList[6 + i].usParaLen;
        }

    }
    else
    {
        ulBsTotalLen = 4;
    }

    /* 申请TAF_MMA_BORDER_INFO_STRU结构体 */
    /*lint -save -e516 */
    pstBorderInfo = (TAF_MMA_BORDER_INFO_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_MMA_BORDER_INFO_STRU) + ulBsTotalLen - 4);
    /*lint -restore */
    if (pstBorderInfo == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetBorderInfoPara: Memory malloc failed!");
        return AT_ERROR;
    }

    lMemResult = memset_s(pstBorderInfo, sizeof(TAF_MMA_BORDER_INFO_STRU) + ulBsTotalLen - 4,
                          0x00, sizeof(TAF_MMA_BORDER_INFO_STRU) + ulBsTotalLen - 4);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(TAF_MMA_BORDER_INFO_STRU) + ulBsTotalLen - 4,
                        sizeof(TAF_MMA_BORDER_INFO_STRU) + ulBsTotalLen - 4);

    /* 填写边境信息结构体:删除时不需要这些信息 */
    if (enOperateType == TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ADD)
    {
        if (TAF_MMA_BuildBorderInfo(ulBsTotalLen, pstBorderInfo) == VOS_FALSE)
        {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, pstBorderInfo);
            /*lint -restore */
            return AT_ERROR;
        }
    }

    ulRslt = TAF_MMA_SetBorderInfoReq(WUEPS_PID_AT,
                                      gastAtClientTab[ucIndex].usClientId,
                                      enOperateType,
                                      pstBorderInfo);

    if (ulRslt != VOS_TRUE)
    {
        AT_ERR_LOG("AT_SetBorderInfoPara: snd msg failed!");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstBorderInfo);
        /*lint -restore */
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_BORDERINFO_SET;
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pstBorderInfo);
    /*lint -restore */
    return AT_WAIT_ASYNC_RETURN;

}


VOS_UINT32 AT_ParseDplmnLengthIllegal(
    VOS_UINT16                          usSubStrLen
)
{
    /* Dplmn长度不合法 */
    if ((usSubStrLen != 5)
     && (usSubStrLen != 6))
        {
            AT_ERR_LOG("AT_ParseDplmnLengthIllegal: dplmn len error");
            return AT_ERROR;
        }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParseDplmnStringList(
    VOS_UINT8                           ucIndex,
    VOS_UINT8                          *pucDplmnString,
    TAF_MMA_DPLMN_INFO_SET_STRU        *pstDplmnInfoSet
)
{
    VOS_UINT8                          *pucSubStr  = VOS_NULL_PTR;
    VOS_UINT8                           aucDilms[] = ",";
    VOS_UINT16                          usSubStrLen;
    VOS_UINT16                          usIndex;
    VOS_UINT32                          ulDplmnNum;
    VOS_UINT32                          ulSimRat;
    errno_t                             lMemResult;
    TAF_PLMN_ID_STRU                    stPlmnId;

    pucSubStr   = (VOS_UINT8*)VOS_StrTok((VOS_CHAR*)pucDplmnString, (const VOS_CHAR*)aucDilms);
    ulDplmnNum  = 0;
    usIndex     = 0;
    ulSimRat    = 0;

    /* 解析预置Dplmn & SimRat组合的个数 */
    if (pucSubStr != VOS_NULL_PTR)
    {
        usSubStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR*)pucSubStr);
        if (AT_String2Hex((TAF_UINT8*)pucSubStr, usSubStrLen, &ulDplmnNum) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mnc error");
            return AT_ERROR;
        }
        pucSubStr = (VOS_UINT8*)VOS_StrTok(VOS_NULL_PTR, (const VOS_CHAR*)aucDilms);
    }

    pstDplmnInfoSet->usDplmnNum = (VOS_UINT16)ulDplmnNum;

    if (pucSubStr == VOS_NULL_PTR)
    {
        pstDplmnInfoSet->usDplmnNum = 0;
    }

    while (pucSubStr != VOS_NULL_PTR)
    {
        usSubStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR*)pucSubStr);

        /* Dplmn长度不合法 */
        if (AT_ParseDplmnLengthIllegal(usSubStrLen) == AT_ERROR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn len error");
            return AT_ERROR;
        }

        /* Dplmn Mcc*/
        if(AT_String2Hex(pucSubStr, 3, &stPlmnId.Mcc) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mcc error");
            return AT_ERROR;
        }

        /* Dplmn Mnc */
        if(AT_String2Hex(&pucSubStr[3], usSubStrLen-3, &stPlmnId.Mnc) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mnc error");
            return AT_ERROR;
        }

        stPlmnId.Mcc &= 0x0FFF;

        if (usSubStrLen == 5)
        {
            stPlmnId.Mnc |= 0x0F00;
        }

        stPlmnId.Mnc &= 0x0FFF;

        /* 解析出来的Dplmn是无效的Plmn */
        if (AT_PH_IsPlmnValid(&stPlmnId) == VOS_FALSE)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn is invalid");
            return AT_ERROR;
        }

        /* Dplmn Sim Rat */
        pucSubStr = (VOS_UINT8*)VOS_StrTok(VOS_NULL_PTR, (const VOS_CHAR*)aucDilms);

        if (pucSubStr == VOS_NULL_PTR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: no sim rat");
            return AT_ERROR;
        }

        usSubStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR*)pucSubStr);

        if (AT_String2Hex(pucSubStr, usSubStrLen, &ulSimRat) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: parse sim rat error");
            return AT_ERROR;
        }

        /* AP预置的Dplmn的Simrat为无效值 */
        if ((ulSimRat == AT_AP_PRESET_DPLMN_INVALID_RAT)
         || (ulSimRat > AT_AP_PRESET_DPLMN_ALL_RAT))
        {
            AT_ERR_LOG("AT_ParseDplmnStringList: sim rat invalid");
            return AT_ERROR;
        }

        lMemResult = memcpy_s(&(pstDplmnInfoSet->astDplmnList[usIndex].stPlmnId), sizeof(pstDplmnInfoSet->astDplmnList[usIndex].stPlmnId), &stPlmnId, sizeof(TAF_PLMN_ID_STRU));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(pstDplmnInfoSet->astDplmnList[usIndex].stPlmnId), sizeof(TAF_PLMN_ID_STRU));
        pstDplmnInfoSet->astDplmnList[usIndex].usSimRat = (VOS_UINT16)ulSimRat;
        usIndex++;

        if (pstDplmnInfoSet->usDplmnNum <= usIndex)
        {
            break;
        }

        pucSubStr = (VOS_UINT8*)VOS_StrTok(VOS_NULL_PTR, (const VOS_CHAR*)aucDilms);
    }

    if (pstDplmnInfoSet->usDplmnNum > usIndex)
    {
        pstDplmnInfoSet->usDplmnNum = usIndex;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParseEhplmnStringList(
    VOS_UINT32                          ulParaLen,
    VOS_UINT8                          *pucPara,
    VOS_UINT8                          *pucEhPlmnNum,
    TAF_PLMN_ID_STRU                   *pstEhplmnList
)
{
    TAF_PLMN_ID_STRU                    stPlmnId;
    VOS_UINT16                          usIndex;
    VOS_UINT16                          usSubStrLen;
    VOS_UINT8        aucEhplmnStr[TAF_MMA_MAX_EHPLMN_STR + 1] = {0};
    VOS_UINT8                          *pucSubStr  = VOS_NULL_PTR;
    VOS_UINT8                           aucDilms[] = ",";
    VOS_UINT32                          ulLen;
    errno_t                             lMemResult;

    ulLen           = ulParaLen;

    if (ulLen > TAF_MMA_MAX_EHPLMN_STR)
    {
        ulLen = TAF_MMA_MAX_EHPLMN_STR;
    }

    lMemResult = memcpy_s(aucEhplmnStr, sizeof(aucEhplmnStr), pucPara, ulLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucEhplmnStr), ulLen);


    pucSubStr   = (VOS_UINT8*)VOS_StrTok((VOS_CHAR*)aucEhplmnStr, (const VOS_CHAR*)aucDilms);
    usIndex     = 0;

    while (pucSubStr != VOS_NULL_PTR)
    {
        usSubStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR*)pucSubStr);

        if ((usSubStrLen != 5)
         && (usSubStrLen != 6))
        {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn len error");
            return AT_ERROR;
        }

        /* Ehplmn Mcc*/
        if (AT_String2Hex(pucSubStr, 3, &stPlmnId.Mcc) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn mcc error");
            return AT_ERROR;
        }

        /* Ehplmn Mnc */
        if (AT_String2Hex(&pucSubStr[3], usSubStrLen - 3, &stPlmnId.Mnc) == VOS_ERR)
        {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn mnc error");
            return AT_ERROR;
        }

        stPlmnId.Mcc &= 0x0FFF;

        if (usSubStrLen == 5)
        {
            stPlmnId.Mnc |= 0x0F00;
        }

        stPlmnId.Mnc &= 0x0FFF;

        /* 解析出来的Ehplmn是无效的Plmn */
        if (AT_PH_IsPlmnValid(&stPlmnId) == VOS_FALSE)
        {
            AT_ERR_LOG("AT_ParseEhplmnStringList: plmn is invalid");
            return AT_ERROR;
        }

        lMemResult = memcpy_s(&(pstEhplmnList[usIndex++]), sizeof(TAF_PLMN_ID_STRU), &stPlmnId, sizeof(TAF_PLMN_ID_STRU));
        TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(TAF_PLMN_ID_STRU), sizeof(TAF_PLMN_ID_STRU));

        if (*pucEhPlmnNum <= usIndex)
        {
            break;
        }

        pucSubStr = (VOS_UINT8*)VOS_StrTok(VOS_NULL_PTR, (const VOS_CHAR*)aucDilms);
    }

    if (*pucEhPlmnNum > usIndex)
    {
        *pucEhPlmnNum = (VOS_UINT8)usIndex;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetDplmnListPara(
    VOS_UINT8                           ucIndex
)
{
    errno_t                             lMemResult;
    VOS_UINT8                           ucSeq;
    VOS_UINT32                          ulRst;
    VOS_UINT8                           aucVersionId[TAF_MMA_VERSION_INFO_LEN];
    TAF_MMA_DPLMN_INFO_SET_STRU        *pstDplmnInfo = VOS_NULL_PTR;
    VOS_UINT8                          *pucDplmnString = VOS_NULL_PTR;
    VOS_UINT8                           ucNumDplmnSubStr;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不正确 */
    if (gucAtParaIndex < 6)
    {
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 版本号长度不对 */
    if (gastAtParaList[1].usParaLen != TAF_MMA_VERSION_INFO_LEN)
    {
        AT_ERR_LOG("AT_SetDplmnListPara: incorrect version length ");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DPLMNLIST_SET;

    /* 填充流水号 */
    ucSeq                                  = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 填充版本号 */
    lMemResult = memcpy_s(aucVersionId, sizeof(aucVersionId), gastAtParaList[1].aucPara, gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, sizeof(aucVersionId), gastAtParaList[1].usParaLen);

    /* 申请DPLMN INFO SET结构体 */
    /*lint -save -e516 */
    pstDplmnInfo = (TAF_MMA_DPLMN_INFO_SET_STRU *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_MMA_DPLMN_INFO_SET_STRU));
    /*lint -restore */

    if (pstDplmnInfo == VOS_NULL_PTR)
    {
        AT_ERR_LOG("AT_SetDplmnListPara: Memory malloc failed!");
        return AT_ERROR;
    }

    /* 申请空间将分片的Dplmn String组合成一条完整的字符串 */
    /*lint -save -e516 */
    pucDplmnString = (VOS_UINT8*)PS_MEM_ALLOC(WUEPS_PID_AT, TAF_MMA_MAX_STR_LEN*sizeof(VOS_UINT8));
    /*lint -restore */
    if (pucDplmnString == VOS_NULL_PTR)
    {
       AT_ERR_LOG("AT_SetDplmnListPara: Memory malloc failed!");
       /*lint -save -e516 */
       PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
       /*lint -restore */
       return AT_ERROR;
    }

    memset_s(pstDplmnInfo, sizeof(TAF_MMA_DPLMN_INFO_SET_STRU), 0x00, sizeof(TAF_MMA_DPLMN_INFO_SET_STRU));

    memset_s(pucDplmnString, TAF_MMA_MAX_STR_LEN*sizeof(VOS_UINT8), 0x00, TAF_MMA_MAX_STR_LEN*sizeof(VOS_UINT8));
    ucNumDplmnSubStr = (VOS_UINT8)gastAtParaList[4].ulParaValue;

    if ((gastAtParaList[5].usParaLen + gastAtParaList[6].usParaLen + gastAtParaList[7].usParaLen) > TAF_MMA_MAX_STR_LEN)
    {
        AT_ERR_LOG("AT_SetDplmnListPara: para len error!");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    switch (ucNumDplmnSubStr)
    {
        case 1:
            lMemResult = memcpy_s(pucDplmnString, TAF_MMA_MAX_STR_LEN, (VOS_UINT8*)gastAtParaList[5].aucPara, gastAtParaList[5].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN, gastAtParaList[5].usParaLen);
            break;

        case 2:
            lMemResult = memcpy_s(pucDplmnString, TAF_MMA_MAX_STR_LEN, (VOS_UINT8*)gastAtParaList[5].aucPara, gastAtParaList[5].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN, gastAtParaList[5].usParaLen);
            lMemResult = memcpy_s(pucDplmnString+gastAtParaList[5].usParaLen,
                                  TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen,
                                  (VOS_UINT8*)gastAtParaList[6].aucPara, gastAtParaList[6].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen, gastAtParaList[6].usParaLen);
            break;

        case 3:
            lMemResult = memcpy_s(pucDplmnString, TAF_MMA_MAX_STR_LEN, (VOS_UINT8*)gastAtParaList[5].aucPara, gastAtParaList[5].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN, gastAtParaList[5].usParaLen);
            lMemResult = memcpy_s(pucDplmnString+gastAtParaList[5].usParaLen,
                                  TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen,
                                  (VOS_UINT8*)gastAtParaList[6].aucPara, gastAtParaList[6].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen, gastAtParaList[6].usParaLen);
            lMemResult = memcpy_s(pucDplmnString+gastAtParaList[5].usParaLen+gastAtParaList[6].usParaLen,
                                  TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen - gastAtParaList[6].usParaLen,
                                  (VOS_UINT8*)gastAtParaList[7].aucPara, gastAtParaList[7].usParaLen);
            TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_MAX_STR_LEN - gastAtParaList[5].usParaLen - gastAtParaList[6].usParaLen, gastAtParaList[7].usParaLen);
            break;

        default:
            AT_ERR_LOG("AT_SetDplmnListPara: ucNumDplmnSubStr error!");
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
            PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
            /*lint -restore */
            return AT_ERROR;
    }

    /* Ehplmn解析 */
    pstDplmnInfo->ucEhPlmnNum = (VOS_UINT8)gastAtParaList[2].ulParaValue;

    if (AT_ParseEhplmnStringList(gastAtParaList[3].usParaLen,
                                 gastAtParaList[3].aucPara,
                                 &(pstDplmnInfo->ucEhPlmnNum),
                                 pstDplmnInfo->astEhPlmnInfo) == AT_ERROR)
    {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    /* Dplmn */
    if (AT_ParseDplmnStringList(ucIndex, pucDplmnString, pstDplmnInfo) == AT_ERROR)
    {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    ulRst = TAF_MMA_SetDplmnListReq(WUEPS_PID_AT,
                                    gastAtClientTab[ucIndex].usClientId,
                                    ucSeq,
                                    aucVersionId,
                                    pstDplmnInfo);

    if (ulRst != VOS_TRUE)
    {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
        /*lint -restore */
        return AT_ERROR;
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pstDplmnInfo);
    PS_MEM_FREE(WUEPS_PID_AT, pucDplmnString);
    /*lint -restore */
    return AT_WAIT_ASYNC_RETURN;
}


#if (FEATURE_MULTI_MODEM == FEATURE_ON)

VOS_UINT32 AT_ExchangeModemInfo(
    VOS_UINT8                           ucIndex
)
{
    VOS_UINT32                          ulRst;
    MODEM_ID_ENUM_UINT16                enFirstModemId;
    MODEM_ID_ENUM_UINT16                enSecondModemId;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("AT_ExchangeModemInfo: NOT AT_CMD_OPT_SET_PARA_CMD!");
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数长度为0，返回错误 */
    if ((gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0))
    {
        AT_WARN_LOG("AT_ExchangeModemInfo: para len is 0!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不正确 */
    if (gucAtParaIndex != 2)
    {
        AT_WARN_LOG("AT_ExchangeModemInfo: para num is wrong!");
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 两个modemID相同，返回错误 */
    if (gastAtParaList[0].ulParaValue == gastAtParaList[1].ulParaValue)
    {
        AT_WARN_LOG("AT_ExchangeModemInfo: two modem ID is the same!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enFirstModemId  = (MODEM_ID_ENUM_UINT16)gastAtParaList[0].ulParaValue;
    enSecondModemId = (MODEM_ID_ENUM_UINT16)gastAtParaList[1].ulParaValue;

    /* modemID值无效，返回错误 */
    if ((enFirstModemId >= MODEM_ID_BUTT)
      ||(enSecondModemId >= MODEM_ID_BUTT))
    {
        AT_WARN_LOG("AT_ExchangeModemInfo: modem ID is butt!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ulRst = TAF_MMA_ExchangeModemInfoReq(WUEPS_PID_AT,
                                    gastAtClientTab[ucIndex].usClientId,
                                    enFirstModemId,
                                    enSecondModemId);

    if (ulRst != VOS_TRUE)
    {
        AT_ERR_LOG("AT_ExchangeModemInfo: snd msg failed!");
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_EXCHANGE_MODEM_INFO_SET;

    return AT_WAIT_ASYNC_RETURN;
}
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCdmaDormantTimer(VOS_UINT8 ucIndex)
{
    VOS_UINT8                           ucDormantTimer;

    /* 参数检查 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ucDormantTimer = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 执行命令操作 */
    if (TAF_PS_SetCdmaDormantTimer(WUEPS_PID_AT,
                                   AT_PS_BuildExClientId(gastAtClientTab[ucIndex].usClientId),
                                   0,
                                   ucDormantTimer) != VOS_OK)
    {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_DORMTIMER_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif

VOS_UINT32 AT_SetUECenterPara(VOS_UINT8 ucIndex)
{
    AT_MTA_SET_UE_CENTER_REQ_STRU       stSetUeCenterInfo;
    VOS_UINT32                          ulRst;

    memset_s(&stSetUeCenterInfo, sizeof(stSetUeCenterInfo), 0x00, sizeof(AT_MTA_SET_UE_CENTER_REQ_STRU));

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(gastAtParaList[0].usParaLen == 0)
    {
        stSetUeCenterInfo.enUeCenter = 0;
    }
    else
    {
        stSetUeCenterInfo.enUeCenter = gastAtParaList[0].ulParaValue;
    }

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_UE_CENTER_SET_REQ,
                                   &stSetUeCenterInfo,
                                   sizeof(AT_MTA_SET_UE_CENTER_REQ_STRU),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UE_CENTER_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetHdrCsqPara(VOS_UINT8 ucIndex)
{
    TAF_MMA_HDR_CSQ_PARA_STRU          stHdrCsqPara;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gucAtParaIndex != 5)
        ||(gastAtParaList[0].usParaLen == 0)
        ||(gastAtParaList[1].usParaLen == 0)
        ||(gastAtParaList[2].usParaLen == 0)
        ||(gastAtParaList[3].usParaLen == 0)
        ||(gastAtParaList[4].usParaLen == 0))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stHdrCsqPara, sizeof(stHdrCsqPara), 0x00, sizeof(TAF_MMA_HDR_CSQ_PARA_STRU));
    stHdrCsqPara.enMode             = (TAF_UINT8)gastAtParaList[0].ulParaValue;
    stHdrCsqPara.ucTimeInterval     = (TAF_UINT8)gastAtParaList[1].ulParaValue;
    stHdrCsqPara.ucRssiThreshold    = (TAF_UINT8)gastAtParaList[2].ulParaValue;
    stHdrCsqPara.ucSnrThreshold     = (TAF_UINT8)gastAtParaList[3].ulParaValue;
    stHdrCsqPara.ucEcioThreshold    = (TAF_UINT8)gastAtParaList[4].ulParaValue;

    if (TAF_MMA_ProcHdrCsqSetReq(WUEPS_PID_AT,
                                 gastAtClientTab[ucIndex].usClientId,
                                 0,
                                 &stHdrCsqPara) == VOS_TRUE)
    {
        /* 设置当前操作类型 */
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_HDR_CSQ_SET;
        return AT_WAIT_ASYNC_RETURN;    /* 返回命令处理挂起状态 */
    }


    return AT_ERROR;
}
#endif

VOS_UINT32 At_SetSensorPara(VOS_UINT8       ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_SET_SENSOR_REQ_STRU          stSensorStat;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("At_SetSensorPara: Incorrect Cmd Type.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ( (gastAtParaList[0].usParaLen == 0)
      || (gucAtParaIndex != 1))
    {
        AT_WARN_LOG("At_SetSensorPara: Incorrect Param Length.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stSensorStat, sizeof(stSensorStat), 0x00, sizeof(stSensorStat));

    stSensorStat.ulSensorStat = gastAtParaList[0].ulParaValue;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_SET_SENSOR_REQ,
                                   &stSensorStat,
                                   sizeof(stSensorStat),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SENSOR_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("At_SetSensorPara: Send msg fail!");
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetScreenPara(VOS_UINT8       ucIndex)
{
    VOS_UINT32                          ulRst;
    AT_MTA_SET_SCREEN_REQ_STRU          stScreenStat;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("At_SetScreenPara: Incorrect Cmd Type.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ( (gastAtParaList[0].usParaLen != 1)
       ||(gucAtParaIndex != 1))
    {
        AT_WARN_LOG("At_SetScreenPara: Incorrect Param Length.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    memset_s(&stScreenStat, sizeof(stScreenStat), 0, sizeof(stScreenStat));

    stScreenStat.ucScreenStat = ( VOS_UINT8 )gastAtParaList[0].ulParaValue;

    ulRst = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                   0,
                                   ID_AT_MTA_SET_SCREEN_REQ,
                                   &stScreenStat,
                                   sizeof(stScreenStat),
                                   I0_UEPS_PID_MTA);

    if (ulRst == TAF_SUCCESS)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_SCREEN_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("At_SetScreenPara: Send msg fail!");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetPcuiCtrlConcurrentFlagForTest(VOS_UINT8 ucIndex)
{
    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
       return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ( (gucAtParaIndex != 1)
      || (gastAtParaList[0].usParaLen == 0) )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    AT_SetPcuiCtrlConcurrentFlag((VOS_UINT8)(gastAtParaList[0].ulParaValue));
    return AT_OK;
}


VOS_UINT32 AT_SetFclassPara(VOS_UINT8 ucIndex)
{
    AT_WARN_LOG("AT_SetFclassPara: Not support this command!");
    (VOS_VOID)ucIndex;
    return AT_ERROR;
}


VOS_UINT32 AT_SetGciPara( VOS_UINT8 ucIndex )
{
    AT_WARN_LOG("AT_SetGciPara: Not support this command!");
    (VOS_VOID)ucIndex;
    return AT_ERROR;
}



VOS_UINT32 AT_SetBestFreqPara(VOS_UINT8 ucIndex)
{
    AT_MTA_BESTFREQ_SET_REQ_STRU        stBestFreqSetReq;
    VOS_UINT32                          ulRslt;
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 指令类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("AT_SetBestFreqPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数或长度不正确 */
    if ((gucAtParaIndex != 2)
     || (gastAtParaList[0].usParaLen == 0)
     || (gastAtParaList[1].usParaLen == 0))
    {
        AT_WARN_LOG("AT_SetBestFreqPara : The number of input parameters is error.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stBestFreqSetReq, (VOS_SIZE_T)sizeof(stBestFreqSetReq), 0x00, (VOS_SIZE_T)sizeof(AT_MTA_BESTFREQ_SET_REQ_STRU));
    enModemId = MODEM_ID_BUTT;

    /* 通过clientID获得ModemID */
    ulRslt    = AT_GetModemIdFromClient(gastAtClientTab[ucIndex].usClientId, &enModemId);

    /* 如果ModemID获取失败或不在Modem0，返回失败 */
    if ((ulRslt != VOS_OK)
     || (enModemId != MODEM_ID_0))
    {
        AT_WARN_LOG("AT_SetBestFreqPara: AT_GetModemIdFromClient failed or not modem0!");
        return AT_ERROR;
    }

    /* 填写消息 */
    stBestFreqSetReq.ucDeviceID = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stBestFreqSetReq.ucMode     = (VOS_UINT8)gastAtParaList[1].ulParaValue;

    /* 发送跨核消息到C核, 设置侦听测试模式 */
    ulRslt = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                    gastAtClientTab[ucIndex].opId,
                                    ID_AT_MTA_BESTFREQ_SET_REQ,
                                    &stBestFreqSetReq,
                                    (VOS_SIZE_T)sizeof(stBestFreqSetReq),
                                    I0_UEPS_PID_MTA);

    if (ulRslt != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetBestFreqPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_BESTFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckPseucellInfoParaLen(VOS_VOID)
{
    /* 如果notify type长度为0，返回错误 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Pseucell Notify Type Len is error.");

        return AT_ERROR;
    }

    /* 如果sys mode长度为0，返回错误 */
    if (gastAtParaList[1].usParaLen == 0)
    {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : sys mode Len is error.");

        return AT_ERROR;
    }

    /* PLMN参数长度不等于5也不等于6，返回错误 */
    if ((gastAtParaList[2].usParaLen != AT_MTA_PSEUCELL_PLMN_LEN_FIVE)
     && (gastAtParaList[2].usParaLen != AT_MTA_PSEUCELL_PLMN_LEN_SIX))
    {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Plmn Len is error.");

        return AT_ERROR;
    }

    /*  LAC参数长度不等于4，返回错误 */
    if (gastAtParaList[3].usParaLen != AT_MTA_PSEUCELL_LAC_LEN)
    {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Lac Len is error.");

        return AT_ERROR;
    }

    /*  CellId参数长度大于8，或者长度为0，返回错误 */
    if (gastAtParaList[4].usParaLen != AT_MTA_PSEUCELL_CELLID_LEN)
    {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : CellId Len is error.");

        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_ParsePseucellInfoMccMnc(
    VOS_UINT8                          *pucPara,
    VOS_UINT16                          usParaLen,
    VOS_UINT32                         *pulMcc,
    VOS_UINT32                         *pulMnc
)
{
    errno_t                             lMemResult;
    VOS_UINT32                          ulTempMcc;
    VOS_UINT32                          ulTempMnc;
    VOS_UINT32                          ulMncLen;
    VOS_UINT8                           aucPlmnStr[AT_MTA_PSEUCELL_PLMN_LEN_SIX];

    ulTempMcc = 0;
    ulTempMnc = 0;

    ulMncLen  = usParaLen - AT_MTA_PLMN_MCC_LEN;

    memset_s(aucPlmnStr, AT_MTA_PSEUCELL_PLMN_LEN_SIX, 0, AT_MTA_PSEUCELL_PLMN_LEN_SIX);

    lMemResult = memcpy_s(aucPlmnStr, AT_MTA_PSEUCELL_PLMN_LEN_SIX, pucPara, usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_MTA_PSEUCELL_PLMN_LEN_SIX, usParaLen);

    if (AT_String2Hex(aucPlmnStr, AT_MTA_PLMN_MCC_LEN, &ulTempMcc) == VOS_ERR)
    {
        AT_WARN_LOG("AT_ParsePseucellInfoMccMnc : Mcc is error.");

        return AT_ERROR;
    }

    if (AT_String2Hex(aucPlmnStr + AT_MTA_PLMN_MCC_LEN,
                      (VOS_UINT16)ulMncLen,
                      &ulTempMnc) == VOS_ERR)
    {
        AT_WARN_LOG("AT_ParsePseucellInfoMccMnc : Mnc is error.");

        return AT_ERROR;
    }

    /* 将MCC转化为NAS类型 */
    AT_ConvertMccToNasType(ulTempMcc, pulMcc);

    /* 将MNC转化为NAS类型 */
    if (ulMncLen == AT_MTA_PLMN_MNC_LEN_TWO)
    {
        ulTempMnc |= 0x00000F00;
    }
    else
    {
        ulTempMnc &= 0x00000FFF;
    }

    AT_ConvertMncToNasType(ulTempMnc, ulMncLen, pulMnc);

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParsePseucellInfoLac(
    VOS_UINT8                          *pucPara,
    VOS_UINT16                          usParaLen,
    VOS_UINT32                         *pulLac
)
{
    VOS_UINT8                           aucLacStr[AT_MTA_PSEUCELL_LAC_LEN];
    errno_t                             lMemResult;

    memset_s(aucLacStr, AT_MTA_PSEUCELL_LAC_LEN, 0, AT_MTA_PSEUCELL_LAC_LEN);

    lMemResult = memcpy_s(aucLacStr, AT_MTA_PSEUCELL_LAC_LEN, pucPara, usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_MTA_PSEUCELL_LAC_LEN, usParaLen);

    if (AT_String2Hex(aucLacStr, usParaLen, pulLac) == VOS_ERR)
    {
        AT_WARN_LOG("AT_ParsePseucellInfoLac : Lac is error.");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParsePseucellInfoCellId(
    VOS_UINT8                          *pucPara,
    VOS_UINT16                          usParaLen,
    VOS_UINT32                         *pulCellId
)
{
    VOS_UINT8                           aucCellIdStr[AT_MTA_PSEUCELL_CELLID_LEN];
    errno_t                             lMemResult;

    memset_s(aucCellIdStr, AT_MTA_PSEUCELL_CELLID_LEN, 0, AT_MTA_PSEUCELL_CELLID_LEN);

    lMemResult = memcpy_s(aucCellIdStr, AT_MTA_PSEUCELL_CELLID_LEN, pucPara, usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, AT_MTA_PSEUCELL_CELLID_LEN, usParaLen);

    if (AT_String2Hex(aucCellIdStr, usParaLen, pulCellId) == VOS_ERR)
    {
        AT_WARN_LOG("AT_ParsePseucellInfoCellId : CellId is error.");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetPseucellInfoPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_PSEUCELL_INFO_SET_REQ_STRU   stPseucellInfoSetReq;
    VOS_UINT32                          ulResult;

    ulResult = 0;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者过少 */
    if (gucAtParaIndex != 5)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Para Num is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查输入参数长度是否正确 */
    if (AT_CheckPseucellInfoParaLen() == AT_ERROR)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : para len is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 不是GSM模式，回应参数错误 */
    if (gastAtParaList[1].ulParaValue != AT_MTA_SYS_MODE_GSM)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Not GSM.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stPseucellInfoSetReq,
             (VOS_SIZE_T)sizeof(stPseucellInfoSetReq),
             0x00,
             (VOS_SIZE_T)sizeof(AT_MTA_PSEUCELL_INFO_SET_REQ_STRU));

    /* 解析MCC和MNC */
    if (AT_ParsePseucellInfoMccMnc(gastAtParaList[2].aucPara,
                                   gastAtParaList[2].usParaLen,
                                   &stPseucellInfoSetReq.ulMcc,
                                   &stPseucellInfoSetReq.ulMnc) == AT_ERROR)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse mcc mnc error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析LAC */
    if (AT_ParsePseucellInfoLac(gastAtParaList[3].aucPara,
                                gastAtParaList[3].usParaLen,
                                &stPseucellInfoSetReq.ulLac) == AT_ERROR)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse lac error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析CellId */
    if (AT_ParsePseucellInfoCellId(gastAtParaList[4].aucPara,
                                   gastAtParaList[4].usParaLen,
                                   &stPseucellInfoSetReq.ulCellId) == AT_ERROR)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse cellid error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    stPseucellInfoSetReq.enPseucellNotifyType = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stPseucellInfoSetReq.enSysmode            = gastAtParaList[1].ulParaValue;

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_PSEUCELL_INFO_SET_REQ,
                                      &stPseucellInfoSetReq,
                                      (VOS_SIZE_T)sizeof(stPseucellInfoSetReq),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetPseucellInfoPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PSEUCELL_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetChrAlarmRlatCnfInfoPara(
    VOS_UINT8                           ucIndex
)
{
    AT_MTA_CHR_ALARM_RLAT_CFG_SET_REQ_STRU  stChrAlarmRlatCfgSetReq;
    VOS_UINT32                              ulResult;

    ulResult = 0;

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者过少 */
    if ( (gucAtParaIndex != 1)
      && (gucAtParaIndex != 2))
    {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para Num is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数1长度为0 */
    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para 1 length is 0.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数2长度为0 */
    if ( (gucAtParaIndex == 2)
      && (gastAtParaList[1].usParaLen == 0))
    {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para 2 length is 0.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stChrAlarmRlatCfgSetReq,
             (VOS_SIZE_T)sizeof(stChrAlarmRlatCfgSetReq),
             0x00,
             (VOS_SIZE_T)sizeof(AT_MTA_CHR_ALARM_RLAT_CFG_SET_REQ_STRU));

    stChrAlarmRlatCfgSetReq.ulAlarmId = gastAtParaList[0].ulParaValue;

    if (gucAtParaIndex == 1)
    {
        stChrAlarmRlatCfgSetReq.enAlarmOp       = AT_MTA_CHR_ALARM_RLAT_OP_READ;
    }
    else
    {
        stChrAlarmRlatCfgSetReq.enAlarmOp       = AT_MTA_CHR_ALARM_RLAT_OP_WRITE;
        stChrAlarmRlatCfgSetReq.ulAlarmDetail   = gastAtParaList[1].ulParaValue;
    }

    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      gastAtClientTab[ucIndex].opId,
                                      ID_AT_MTA_CHRALARMRLAT_CFG_SET_REQ,
                                      &stChrAlarmRlatCfgSetReq,
                                      (VOS_SIZE_T)sizeof(stChrAlarmRlatCfgSetReq),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CHRALARMRLATCFG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetMtReattachPara(VOS_UINT8 ucIndex )
{
    AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU         stAtCmd;
    VOS_UINT32                                  ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if(gucAtParaIndex > 1)
    {
        return AT_TOO_MANY_PARA;
    }

    if ( (gastAtParaList[0].usParaLen == 0)
      || (gastAtParaList[0].ulParaValue > 1))
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&stAtCmd, sizeof(stAtCmd), 0x00, sizeof(stAtCmd));
    stAtCmd.enReqType               = AT_MTA_SET_MTREATTACH_RPT_TYPE;
    stAtCmd.u.ucMtReattachRptFlg    = (VOS_UINT8)gastAtParaList[0].ulParaValue;

    /* 给MTA发送^MTREATTACH设置请求 */
    ulResult = AT_FillAndSndAppReqMsg(gastAtClientTab[ucIndex].usClientId,
                                      0,
                                      ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                      &stAtCmd,
                                      sizeof(AT_MTA_UNSOLICITED_RPT_SET_REQ_STRU),
                                      I0_UEPS_PID_MTA);

    if (ulResult != TAF_SUCCESS)
    {
        return AT_ERROR;
    }

    gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_WRITE_ACORE_NV_STRU * AT_FillACoreNvWriteStru(
    VOS_UINT32                          ulModemId,
    VOS_UINT32                          ulNvItemId,
    VOS_VOID                           *pData,
    VOS_UINT32                          ulNvLength
)
{
    g_stWriteAcoreNv.ulModemId     = ulModemId;
    g_stWriteAcoreNv.ulNvItemId    = ulNvItemId;
    g_stWriteAcoreNv.ulNvLength    = ulNvLength;
    g_stWriteAcoreNv.ulIsNeedCheck = VOS_TRUE;
    g_stWriteAcoreNv.ulOffset      = 0;
    g_stWriteAcoreNv.pData         = pData;

    return &g_stWriteAcoreNv;
}


TAF_WRITE_ACORE_NV_STRU * AT_FillACoreNvWriteNoCheckStru(
    VOS_UINT32                          ulModemId,
    VOS_UINT32                          ulNvItemId,
    VOS_VOID                           *pData,
    VOS_UINT32                          ulNvLength
)
{
    g_stWriteAcoreNv.ulModemId     = ulModemId;
    g_stWriteAcoreNv.ulNvItemId    = ulNvItemId;
    g_stWriteAcoreNv.ulNvLength    = ulNvLength;
    g_stWriteAcoreNv.ulIsNeedCheck = VOS_FALSE;
    g_stWriteAcoreNv.ulOffset      = 0;
    g_stWriteAcoreNv.pData         = pData;

    return &g_stWriteAcoreNv;
}


TAF_WRITE_ACORE_NV_STRU * AT_FillACoreNvWritePartStru(
    VOS_UINT32                          ulModemId,
    VOS_UINT32                          ulNvItemId,
    VOS_UINT32                          ulOffset,
    VOS_VOID                           *pData,
    VOS_UINT32                          ulNvLength
)
{
    g_stWriteAcoreNv.ulModemId     = ulModemId;
    g_stWriteAcoreNv.ulNvItemId    = ulNvItemId;
    g_stWriteAcoreNv.ulNvLength    = ulNvLength;
    g_stWriteAcoreNv.ulIsNeedCheck = VOS_TRUE;
    g_stWriteAcoreNv.ulOffset      = ulOffset;
    g_stWriteAcoreNv.pData         = pData;

    return &g_stWriteAcoreNv;
}


TAF_WRITE_ACORE_NV_STRU * AT_FillACoreNvWritePartNoCheckStru(
    VOS_UINT32                          ulModemId,
    VOS_UINT32                          ulNvItemId,
    VOS_UINT32                          ulOffset,
    VOS_VOID                           *pData,
    VOS_UINT32                          ulNvLength
)
{
    g_stWriteAcoreNv.ulModemId     = ulModemId;
    g_stWriteAcoreNv.ulNvItemId    = ulNvItemId;
    g_stWriteAcoreNv.ulNvLength    = ulNvLength;
    g_stWriteAcoreNv.ulIsNeedCheck = VOS_FALSE;
    g_stWriteAcoreNv.ulOffset      = ulOffset;
    g_stWriteAcoreNv.pData         = pData;

    return &g_stWriteAcoreNv;
}


VOS_UINT32 AT_SetCemodePara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulRst;
    ulRst                               = 0;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ( gucAtParaIndex > 1 )
    {
        return AT_TOO_MANY_PARA;
    }

    if ( gastAtParaList[0].usParaLen == 0 )
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    ulRst = TAF_MMA_SetCemodeReq(WUEPS_PID_AT, gastAtClientTab[ucIndex].usClientId, 0, gastAtParaList[0].ulParaValue);
    if (ulRst == VOS_TRUE)
    {
        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_CEMODE_SET;
        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        AT_WARN_LOG("AT_SetCemodePara: TAF_MMA_SetCemodeReq fail.");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCvhuPara(VOS_UINT8 ucIndex)
{
    MODEM_ID_ENUM_UINT16                enModemId;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;

    /* 命令类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数错误 */
    if (gucAtParaIndex > 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将设置参数保存到CC上下文中 */
    if (AT_GetModemIdFromClient(ucIndex, &enModemId) != VOS_OK)
    {
        AT_LOG1("AT_SetCvhuPara AT_GetModemIdFromClient fail", ucIndex);
        return AT_ERROR;
    }

    pstCcCtx = AT_GetModemCcCtxAddrFromModemId(enModemId);

    /* 如果参数为空，默认按照CVHU_MODE_0处理 */
    if (gucAtParaIndex == 0)
    {
        pstCcCtx->enCvhuMode = CVHU_MODE_0;
    }
    else
    {
        pstCcCtx->enCvhuMode = (AT_CVHU_MODE_ENUM_UINT8)(gastAtParaList[0].ulParaValue);
    }

    return AT_OK;
}

VOS_UINT32 AT_QryCvhuPara(VOS_UINT8 ucIndex)
{
    MODEM_ID_ENUM_UINT16                enModemId;
    AT_MODEM_CC_CTX_STRU               *pstCcCtx = VOS_NULL_PTR;
    VOS_UINT16                          usLength;

    /* 命令类型检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_READ_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取ModemID */
    if (AT_GetModemIdFromClient(ucIndex, &enModemId) != VOS_OK)
    {
        AT_LOG1("AT_QryCvhuPara AT_GetModemIdFromClient fail", ucIndex);
        return AT_ERROR;
    }

    /* 获取CC上下文 */
    pstCcCtx = AT_GetModemCcCtxAddrFromModemId(enModemId);

    usLength = (VOS_UINT16)At_sprintf(AT_CMD_MAX_LEN,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      (VOS_CHAR *)pgucAtSndCodeAddr,
                                      "%s: %d",
                                      g_stParseContext[ucIndex].pstCmdElement->pszCmdName,
                                      pstCcCtx->enCvhuMode);
    gstAtSendData.usBufLen = usLength;

    return AT_OK;
}


VOS_UINT32 AT_SetParaRspSimsqPara(VOS_UINT8 ucIndex)
{
    VOS_UINT32                          ulResult;

    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数只能为一个 */
    if (gucAtParaIndex != 1)
    {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ( At_GetSimsqEnable() != gastAtParaList[0].ulParaValue )
    {
        At_SetSimsqEnable((VOS_UINT8)gastAtParaList[0].ulParaValue);

        ulResult = TAF_ACORE_NV_WRITE(MODEM_ID_0,
                                      en_NV_Item_Custom_Usimm_Cfg,
                                      &AT_GetCommCtxAddr()->stCustomUsimmCfg,
                                      sizeof(NAS_NVIM_CUSTOM_USIMM_CFG_STRU));

        if (ulResult != NV_OK)
        {
            AT_WARN_LOG("AT_SetParaRspSimsqPara: write nv failed!");
            return AT_ERROR;
        }

    }

    return AT_OK;
}


VOS_UINT32 AT_QryParaRspSimsqPara(VOS_UINT8 ucIndex)
{
    MODEM_ID_ENUM_UINT16                enModemId;

    /* 将设置参数保存到CC上下文中 */
    if (AT_GetModemIdFromClient(ucIndex, &enModemId) != VOS_OK)
    {
        AT_LOG1("AT_ProcSimsqInd AT_GetModemIdFromClient fail", ucIndex);
        return AT_ERROR;
    }

    AT_ProcReportSimSqInfo(ucIndex, At_GetSimsqStatus(enModemId));

    return AT_OK;
}


VOS_UINT32 At_SetExtUserPlmnSrch(TAF_UINT8 ucIndex)
{
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enPhRat;
    TAF_MMA_CTRL_STRU                   stCtrl;
    TAF_PLMN_USER_SEL_STRU              stExtUserPlmnSrch;
    errno_t                             lMemResult;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_MMA_CTRL_STRU));
    memset_s(&stExtUserPlmnSrch, sizeof(stExtUserPlmnSrch), 0x00, sizeof(TAF_PLMN_USER_SEL_STRU));

    /* 参数检查 */
    if(g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_NORM_LOG("At_SetExtUserPlmnSrch:  not AT_CMD_OPT_SET_PARA_CMD");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ((gucAtParaIndex != 4)
     && (gucAtParaIndex != 5))
    {
        AT_NORM_LOG1("At_SetExtUserPlmnSrch: Param Number not correct:", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口相关信息 */
    stCtrl.ulModuleId = WUEPS_PID_AT;
    stCtrl.usClientId = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId     = 0;

    /* 设置RAT */
    At_SetCopsActPara(&enPhRat, gastAtParaList[2].usParaLen, gastAtParaList[2].ulParaValue);

    stExtUserPlmnSrch.ucFormatType      = AT_COPS_NUMERIC_TYPE;
    stExtUserPlmnSrch.ucBgSrchFlag      = (VOS_UINT8)gastAtParaList[0].ulParaValue;
    stExtUserPlmnSrch.usOperNameLen     = gastAtParaList[1].usParaLen;
    stExtUserPlmnSrch.enAccessMode      = enPhRat;
    stExtUserPlmnSrch.enSrchType        = (VOS_UINT8)gastAtParaList[3].ulParaValue;
    stExtUserPlmnSrch.ucRsrpThresholdFlg = VOS_FALSE;
    if (gucAtParaIndex == 5)
    {
        stExtUserPlmnSrch.ucRsrpThresholdFlg = VOS_TRUE;
        stExtUserPlmnSrch.sRsrp              = (VOS_INT16)gastAtParaList[4].ulParaValue;
        stExtUserPlmnSrch.sRsrp              = 0 - stExtUserPlmnSrch.sRsrp;
    }

    if ((gastAtParaList[1].usParaLen != AT_PLMN_LEN_FIVE)
     && (gastAtParaList[1].usParaLen != AT_PLMN_LEN_SIX))
    {
        AT_NORM_LOG1("At_SetExtUserPlmnSrch: PLMN Length Not correct:", gastAtParaList[1].usParaLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    lMemResult = memcpy_s(stExtUserPlmnSrch.ucOperName, TAF_MMA_PLMN_ID_LEN,
                          (VOS_CHAR*)gastAtParaList[1].aucPara,gastAtParaList[1].usParaLen);
    TAF_MEM_CHK_RTN_VAL(lMemResult, TAF_MMA_PLMN_ID_LEN, gastAtParaList[1].usParaLen);

    if (TAF_MMA_PlmnSearchReq(&stCtrl, TAF_MMA_SEARCH_TYPE_MANUAL, &stExtUserPlmnSrch) == VOS_TRUE)
    {
        AT_NORM_LOG("At_SetExtUserPlmnSrch:  AT_CMD_PLMNSRCH_SET: ASYNC");

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PLMNSRCH_SET;

        return AT_WAIT_ASYNC_RETURN;
    }
    else
    {
        return AT_ERROR;
    }


}


VOS_UINT32 At_SetDetectPlmnRsrp(TAF_UINT8 ucIndex)
{
    TAF_MMA_RAT_TYPE_ENUM_UINT8         enPhRat;
    TAF_MMA_CTRL_STRU                   stCtrl;
    TAF_DETECT_PLMN_STRU                stPlmnDetect;

    memset_s(&stCtrl, sizeof(stCtrl), 0x00, sizeof(TAF_MMA_CTRL_STRU));
    memset_s(&stPlmnDetect, sizeof(stPlmnDetect), 0x00, sizeof(TAF_DETECT_PLMN_STRU));

    /* 参数检查 */
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_NORM_LOG("At_SetDtectPlmnRsrp:  not AT_CMD_OPT_SET_PARA_CMD");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (gucAtParaIndex != 2)
    {
        AT_NORM_LOG1("At_SetDtectPlmnRsrp: Param Number not correct:", gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口相关信息 */
    stCtrl.ulModuleId = WUEPS_PID_AT;
    stCtrl.usClientId = gastAtClientTab[ucIndex].usClientId;
    stCtrl.ucOpId     = 0;

    /* 设置RAT */
    At_SetCopsActPara(&enPhRat, gastAtParaList[1].usParaLen, gastAtParaList[1].ulParaValue);

    stPlmnDetect.enAccessMode      = enPhRat;

    if (enPhRat != TAF_MMA_RAT_LTE)
    {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: Only support LTE");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((gastAtParaList[0].usParaLen != AT_PLMN_LEN_FIVE)
     && (gastAtParaList[0].usParaLen != AT_PLMN_LEN_SIX))
    {
        AT_NORM_LOG1("At_SetDtectPlmnRsrp: PLMN Length Not correct:", gastAtParaList[0].usParaLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* mcc mnc 解析 */
    /* Mcc */
    if (AT_DigitString2Hex((TAF_UINT8*)(gastAtParaList[0].aucPara),
                                             3,
                                             &(stPlmnDetect.stPlmnId.Mcc)) == VOS_FALSE)
    {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: PLMN Illegal");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* Mnc */
    if (AT_DigitString2Hex((TAF_UINT8*)&(gastAtParaList[0].aucPara[3]),
                                              gastAtParaList[0].usParaLen - 3,
                                              &(stPlmnDetect.stPlmnId.Mnc)) == VOS_FALSE)
    {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: PLMN Illegal");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    stPlmnDetect.stPlmnId.Mcc |= 0xFFFFF000;
    stPlmnDetect.stPlmnId.Mnc |= (0xFFFFFFFF << ((gastAtParaList[0].usParaLen - 3) * 4));

    if (TAF_MMA_PlmnDetectReq(&stCtrl, &stPlmnDetect) == VOS_TRUE)
    {
        AT_NORM_LOG("At_SetDtectPlmnRsrp:  AT_CMD_PLMNSRCH_SET: ASYNC");

        gastAtClientTab[ucIndex].CmdCurrentOpt = AT_CMD_PLMNSRCH_SET;

        return AT_OK;
    }
    else
    {
        return AT_ERROR;
    }


}

#if (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON)

VOS_UINT32 At_SetWakelock( VOS_UINT8 ucIndex )
{
    if (g_stATParseCmd.ucCmdOptType != AT_CMD_OPT_SET_PARA_CMD)
    {
        AT_NORM_LOG("At_SetWakelock arguments found, return error!!\n ");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gucAtParaIndex > 1)
    {
        AT_NORM_LOG1("At_SetWakelock: the number of parameter is error ",
                     (VOS_INT32)gucAtParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (gastAtParaList[0].usParaLen == 0)
    {
        AT_NORM_LOG("At_SetWakelock: parameter len is 0 ");

        return AT_ERROR;
    }

    if ((gastAtParaList[0].ulParaValue != 0) &&
        (gastAtParaList[0].ulParaValue != 1))
    {
        AT_NORM_LOG("At_SetWakelock: parameter invalid");
        return AT_ERROR;
    }

    if (gastAtParaList[0].ulParaValue == 0)
    {
        if (g_stAtWakeLock.active)
        {
            AT_NORM_LOG("At_SetWakelock: wake_unlock");
            __pm_relax(&g_stAtWakeLock);
        }
        else
        {
            AT_NORM_LOG("At_SetWakelock: unlocked before");
        }
    }

    if (gastAtParaList[0].ulParaValue == 1)
    {
        if (g_stAtWakeLock.active)
        {
            AT_NORM_LOG("At_SetWakelock: locked before");
        }
        else
        {
            AT_NORM_LOG("At_SetWakelock: wake_lock");
            __pm_stay_awake(&g_stAtWakeLock);
        }
    }

    return AT_OK;
}
#endif



